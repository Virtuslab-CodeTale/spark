[
  {
    "id" : "da3a1cf1-90f9-43ac-b01f-7f73690068c3",
    "prId" : 32969,
    "prUrl" : "https://github.com/apache/spark/pull/32969#pullrequestreview-688703609",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96f725a9-652c-4d67-bb47-a5bfc1d2e300",
        "parentId" : null,
        "authorId" : "ddb80038-2da6-4937-8c45-4d52fbe0300f",
        "body" : "can you keep the Scaladoc for `avroSchema` and `avroPath` from the previous version?",
        "createdAt" : "2021-06-21T16:49:09Z",
        "updatedAt" : "2021-06-21T16:54:59Z",
        "lastEditedBy" : "ddb80038-2da6-4937-8c45-4d52fbe0300f",
        "tags" : [
        ]
      },
      {
        "id" : "f423c08a-f68e-4378-90a6-23be932ad321",
        "parentId" : "96f725a9-652c-4d67-bb47-a5bfc1d2e300",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "+1",
        "createdAt" : "2021-06-21T17:38:01Z",
        "updatedAt" : "2021-06-21T17:38:01Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9e40d747ffc26c16c7e40044388476db7767a7a",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +210,214 @@   * @param avroPath The seq of parent field names leading to `avroSchema`.\n   */\n  class AvroSchemaHelper(avroSchema: Schema, avroPath: Seq[String]) {\n    if (avroSchema.getType != Schema.Type.RECORD) {\n      throw new IncompatibleSchemaException("
  },
  {
    "id" : "9cf0a715-e9d7-44bb-b9ef-e33fa0a10606",
    "prId" : 25017,
    "prUrl" : "https://github.com/apache/spark/pull/25017#pullrequestreview-258237010",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0160dbcd-58e9-466d-b0d9-3fdb5dabe038",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Previously, this was the following (`sharedState.sparkContext.hadoopConfiguration` + `SQLConf`). Is `job.getConfiguration` enough for `Avro`?\r\n```scala\r\nval parsedOptions = new AvroOptions(options, spark.sessionState.newHadoopConf())\r\n```",
        "createdAt" : "2019-07-05T02:27:27Z",
        "updatedAt" : "2019-07-05T07:00:33Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "ec610a83-848e-4242-914d-f07e8331efa9",
        "parentId" : "0160dbcd-58e9-466d-b0d9-3fdb5dabe038",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Yes, it is enough. Orc/Parquet also use the configuration from `job`.",
        "createdAt" : "2019-07-05T06:22:10Z",
        "updatedAt" : "2019-07-05T07:00:33Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc98bd53130f67a4ea140d70a393c0ba4ba9c83e",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +89,93 @@      options: Map[String, String],\n      dataSchema: StructType): OutputWriterFactory = {\n    val parsedOptions = new AvroOptions(options, job.getConfiguration)\n    val outputAvroSchema: Schema = parsedOptions.schema\n      .map(new Schema.Parser().parse)"
  }
]