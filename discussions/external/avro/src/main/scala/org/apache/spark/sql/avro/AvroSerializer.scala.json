[
  {
    "id" : "2b01000c-8508-4ae4-a01d-0c2c10827dee",
    "prId" : 33413,
    "prUrl" : "https://github.com/apache/spark/pull/33413#pullrequestreview-718719515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "120ccf33-7505-40cf-aedb-767e20f613a3",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2021-07-30T04:56:31Z",
        "updatedAt" : "2021-07-30T04:56:31Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "e18b8b2b56b8f1b2ac83c0a9a8ebf3d42d37ffde",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +181,185 @@\n      case (TimestampNTZType, LONG) => avroType.getLogicalType match {\n        // For backward compatibility, if the Avro type is Long and it is not logical type\n        // (the `null` case), output the timestamp value without time zone\n        // as with millisecond precision."
  },
  {
    "id" : "9ee25819-2cb0-4bb8-a399-fee34bafe520",
    "prId" : 28477,
    "prUrl" : "https://github.com/apache/spark/pull/28477#pullrequestreview-408045365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd18cfd4-84af-4d9e-9683-b0b1b992feb4",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "How about to add a type alias to LegacyBehaviorPolicy:\r\n```scala\r\n  object LegacyBehaviorPolicy extends Enumeration {\r\n    type LegacyBehaviorPolicy = Value\r\n    val EXCEPTION, LEGACY, CORRECTED = Value\r\n  }\r\n```",
        "createdAt" : "2020-05-07T18:40:33Z",
        "updatedAt" : "2020-05-12T14:35:21Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "928a2ec6-ee45-47ed-958a-9ac3cb5ff2d2",
        "parentId" : "bd18cfd4-84af-4d9e-9683-b0b1b992feb4",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This doesn't help match, as we need to access both `object LegacyBehaviorPolicy` and `type LegacyBehaviorPolicy` and we still need some prefix to distinguish them.",
        "createdAt" : "2020-05-08T07:12:07Z",
        "updatedAt" : "2020-05-12T14:35:21Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb61edb3058653d40ac35e3e92d4314e7011cc01",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +48,52 @@    rootAvroType: Schema,\n    nullable: Boolean,\n    datetimeRebaseMode: LegacyBehaviorPolicy.Value) extends Logging {\n\n  def this(rootCatalystType: DataType, rootAvroType: Schema, nullable: Boolean) {"
  },
  {
    "id" : "6454df4c-e142-4eca-8527-49d6413b788d",
    "prId" : 27953,
    "prUrl" : "https://github.com/apache/spark/pull/27953#pullrequestreview-378279440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "One more thing, why don't we return a function rather than checking `rebaseDateTime` for every time?",
        "createdAt" : "2020-03-20T07:01:19Z",
        "updatedAt" : "2020-03-20T07:01:19Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "93f12151-c8a5-46a8-b4df-598c274c6e31",
        "parentId" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "1. I assumed timestamps in milliseconds is rare case. By default, Spark writes microseconds.\r\n2. Checking the boolean flag shouldn't have significant overhead.\r\n3. If the function is hot, jvm should optimize it\r\n\r\nI can move the flag checking out of the function body in a follow PR, or in the same for https://github.com/apache/spark/pull/27953#discussion_r395453034",
        "createdAt" : "2020-03-20T07:15:36Z",
        "updatedAt" : "2020-03-20T07:15:37Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "b617a439-8faa-47db-94ea-e3973d69b9b2",
        "parentId" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I think it's easy to switch with almost no additional complexity. Seems fine to change rather than relying on other optimization like JIT, or having a bad example.",
        "createdAt" : "2020-03-20T07:50:14Z",
        "updatedAt" : "2020-03-20T07:50:14Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "2464c905045856fdbf17d2765ae499b96f912621",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +152,156 @@          case null | _: TimestampMillis => (getter, ordinal) =>\n            val micros = getter.getLong(ordinal)\n            val rebasedMicros = if (rebaseDateTime) {\n              DateTimeUtils.rebaseGregorianToJulianMicros(micros)\n            } else micros"
  }
]