[
  {
    "id" : "2b01000c-8508-4ae4-a01d-0c2c10827dee",
    "prId" : 33413,
    "prUrl" : "https://github.com/apache/spark/pull/33413#pullrequestreview-718719515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "120ccf33-7505-40cf-aedb-767e20f613a3",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2021-07-30T04:56:31Z",
        "updatedAt" : "2021-07-30T04:56:31Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "e18b8b2b56b8f1b2ac83c0a9a8ebf3d42d37ffde",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +181,185 @@\n      case (TimestampNTZType, LONG) => avroType.getLogicalType match {\n        // For backward compatibility, if the Avro type is Long and it is not logical type\n        // (the `null` case), output the timestamp value without time zone\n        // as with millisecond precision."
  },
  {
    "id" : "9ee25819-2cb0-4bb8-a399-fee34bafe520",
    "prId" : 28477,
    "prUrl" : "https://github.com/apache/spark/pull/28477#pullrequestreview-408045365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd18cfd4-84af-4d9e-9683-b0b1b992feb4",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "How about to add a type alias to LegacyBehaviorPolicy:\r\n```scala\r\n  object LegacyBehaviorPolicy extends Enumeration {\r\n    type LegacyBehaviorPolicy = Value\r\n    val EXCEPTION, LEGACY, CORRECTED = Value\r\n  }\r\n```",
        "createdAt" : "2020-05-07T18:40:33Z",
        "updatedAt" : "2020-05-12T14:35:21Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "928a2ec6-ee45-47ed-958a-9ac3cb5ff2d2",
        "parentId" : "bd18cfd4-84af-4d9e-9683-b0b1b992feb4",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This doesn't help match, as we need to access both `object LegacyBehaviorPolicy` and `type LegacyBehaviorPolicy` and we still need some prefix to distinguish them.",
        "createdAt" : "2020-05-08T07:12:07Z",
        "updatedAt" : "2020-05-12T14:35:21Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb61edb3058653d40ac35e3e92d4314e7011cc01",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +48,52 @@    rootAvroType: Schema,\n    nullable: Boolean,\n    datetimeRebaseMode: LegacyBehaviorPolicy.Value) extends Logging {\n\n  def this(rootCatalystType: DataType, rootAvroType: Schema, nullable: Boolean) {"
  },
  {
    "id" : "6454df4c-e142-4eca-8527-49d6413b788d",
    "prId" : 27953,
    "prUrl" : "https://github.com/apache/spark/pull/27953#pullrequestreview-378279440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "One more thing, why don't we return a function rather than checking `rebaseDateTime` for every time?",
        "createdAt" : "2020-03-20T07:01:19Z",
        "updatedAt" : "2020-03-20T07:01:19Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "93f12151-c8a5-46a8-b4df-598c274c6e31",
        "parentId" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "1. I assumed timestamps in milliseconds is rare case. By default, Spark writes microseconds.\r\n2. Checking the boolean flag shouldn't have significant overhead.\r\n3. If the function is hot, jvm should optimize it\r\n\r\nI can move the flag checking out of the function body in a follow PR, or in the same for https://github.com/apache/spark/pull/27953#discussion_r395453034",
        "createdAt" : "2020-03-20T07:15:36Z",
        "updatedAt" : "2020-03-20T07:15:37Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "b617a439-8faa-47db-94ea-e3973d69b9b2",
        "parentId" : "2042ddf8-55fa-41a6-bb64-c957fa497c54",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I think it's easy to switch with almost no additional complexity. Seems fine to change rather than relying on other optimization like JIT, or having a bad example.",
        "createdAt" : "2020-03-20T07:50:14Z",
        "updatedAt" : "2020-03-20T07:50:14Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "2464c905045856fdbf17d2765ae499b96f912621",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +152,156 @@          case null | _: TimestampMillis => (getter, ordinal) =>\n            val micros = getter.getLong(ordinal)\n            val rebasedMicros = if (rebaseDateTime) {\n              DateTimeUtils.rebaseGregorianToJulianMicros(micros)\n            } else micros"
  },
  {
    "id" : "6e762bfc-061e-4aad-9ab8-1fbbaf1c97a4",
    "prId" : 24682,
    "prUrl" : "https://github.com/apache/spark/pull/24682#pullrequestreview-240926207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2379138-43da-40b9-ab14-376cbacacb2d",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Yep. This is for a better error!",
        "createdAt" : "2019-05-22T23:21:55Z",
        "updatedAt" : "2019-05-24T21:02:37Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "09197e66a53df33c5cc135012658f3f8ddaac4a2",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +237,241 @@\n  private def resolveNullableType(avroType: Schema, nullable: Boolean): Schema = {\n    if (avroType.getType == Type.UNION && nullable) {\n      // avro uses union to represent nullable type.\n      val fields = avroType.getTypes.asScala"
  },
  {
    "id" : "52912b16-63ac-4778-ac01-21844f5420af",
    "prId" : 24682,
    "prUrl" : "https://github.com/apache/spark/pull/24682#pullrequestreview-240933931",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25412d55-f56d-41e7-8652-6251d32d4816",
        "parentId" : null,
        "authorId" : "677aa336-324b-4b93-8300-21f8bd378f26",
        "body" : "This is a bug, and only when  `avroType.getType == Type.UNION` should go through this code path.",
        "createdAt" : "2019-05-22T23:55:48Z",
        "updatedAt" : "2019-05-24T21:02:37Z",
        "lastEditedBy" : "677aa336-324b-4b93-8300-21f8bd378f26",
        "tags" : [
        ]
      }
    ],
    "commit" : "09197e66a53df33c5cc135012658f3f8ddaac4a2",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +239,243 @@    if (avroType.getType == Type.UNION && nullable) {\n      // avro uses union to represent nullable type.\n      val fields = avroType.getTypes.asScala\n      assert(fields.length == 2)\n      val actualType = fields.filter(_.getType != Type.NULL)"
  },
  {
    "id" : "77271458-f11b-459a-95c5-77f91dc92fc5",
    "prId" : 24635,
    "prUrl" : "https://github.com/apache/spark/pull/24635#pullrequestreview-239768593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76041c22-4de3-4b9f-b64d-3f537475e94d",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "To fix `enum` issue at https://github.com/apache/spark/pull/24635#discussion_r285326100, can we try to use the corresponding field at the same position when `avroField == null`?",
        "createdAt" : "2019-05-18T02:38:35Z",
        "updatedAt" : "2019-05-20T23:26:22Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "a401cfd4-304d-40de-8458-772de4e4ac9e",
        "parentId" : "76041c22-4de3-4b9f-b64d-3f537475e94d",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I think we should try matching the Avro field name under `union`s with `null`.",
        "createdAt" : "2019-05-18T03:07:23Z",
        "updatedAt" : "2019-05-20T23:26:22Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "83fedd8b-8360-405a-89ba-c86c00edda57",
        "parentId" : "76041c22-4de3-4b9f-b64d-3f537475e94d",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "When converting catalyst struct \"a int, b int\" -> avro type \"b int, c int\", we will update only the first avro field.",
        "createdAt" : "2019-05-18T03:23:13Z",
        "updatedAt" : "2019-05-20T23:26:22Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "f6f12e70-7493-47f0-a8da-3732d74ba5af",
        "parentId" : "76041c22-4de3-4b9f-b64d-3f537475e94d",
        "authorId" : "677aa336-324b-4b93-8300-21f8bd378f26",
        "body" : "When `avroField == null`, we should fail the writing because it's inconsistent between catalyst schema and avro schema. ",
        "createdAt" : "2019-05-20T23:31:20Z",
        "updatedAt" : "2019-05-20T23:31:20Z",
        "lastEditedBy" : "677aa336-324b-4b93-8300-21f8bd378f26",
        "tags" : [
        ]
      },
      {
        "id" : "f2220d85-4aae-4eec-b503-c3decfc39e55",
        "parentId" : "76041c22-4de3-4b9f-b64d-3f537475e94d",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "+1 for that.",
        "createdAt" : "2019-05-20T23:41:11Z",
        "updatedAt" : "2019-05-20T23:41:11Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e831933f0172cd5a8a53893de852f70a063be35",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +210,214 @@      catalystStruct.map { catalystField =>\n        val avroField = avroStruct.getField(catalystField.name)\n        if (avroField == null) {\n          throw new IncompatibleSchemaException(\n            s\"Cannot convert Catalyst type $catalystStruct to Avro type $avroStruct.\")"
  }
]