[
  {
    "id" : "11374f0f-0f12-4513-a1a2-85087a7db6dc",
    "prId" : 26012,
    "prUrl" : "https://github.com/apache/spark/pull/26012#pullrequestreview-297413777",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5114591-734f-41b7-be7a-27d59ae44b81",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Out of curious, cannot be MutableProjection too here?",
        "createdAt" : "2019-10-03T22:07:33Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "8ed9bc3c-f64b-46da-b1a8-d2d8daac9b41",
        "parentId" : "f5114591-734f-41b7-be7a-27d59ae44b81",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "We could but it is not really worth it. Code generation is relatively fast but it is not for free, even for situations where merge is called often interpreted execution is probably faster.",
        "createdAt" : "2019-10-04T11:28:00Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebb974e419f786d4f448d340a4ba4a57f7f45feb",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +85,89 @@  @transient\n  private[this] lazy val mergeProjection = initializeProjection {\n    InterpretedMutableProjection.createProjection(mergeExpressions)\n  }\n"
  },
  {
    "id" : "30056e5c-bd04-4e7b-9c93-facdaf2f3f9a",
    "prId" : 26012,
    "prUrl" : "https://github.com/apache/spark/pull/26012#pullrequestreview-299419944",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cabc5295-71c8-4a80-9fa2-e6edbad5ee45",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we be more aggressive and throw exception if `merge` or `value` is called on executor side?",
        "createdAt" : "2019-10-04T06:30:39Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8d99d633-5016-47a1-9a4e-db61ca342513",
        "parentId" : "cabc5295-71c8-4a80-9fa2-e6edbad5ee45",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "Well we will throw a NPE when you do that. Merge and value expressions are not send to the executor.",
        "createdAt" : "2019-10-04T11:28:44Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "1e7b6e77-8b98-4816-9771-bce147e26e47",
        "parentId" : "cabc5295-71c8-4a80-9fa2-e6edbad5ee45",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "What I mean is, we don't need the default value. We can simply `assert(conf != null)` in the method.",
        "createdAt" : "2019-10-04T12:42:15Z",
        "updatedAt" : "2019-10-04T12:42:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8a8a93fd-b6f5-4d42-b6ac-ae886b9a76ff",
        "parentId" : "cabc5295-71c8-4a80-9fa2-e6edbad5ee45",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "In SQL the SQLAppStatusListener calls `merge` and `value` on an accumulator that originates from an executor and which does not carry a `conf` value. I can add the assert but I will probably have to remove it in the follow up PR.",
        "createdAt" : "2019-10-09T13:42:44Z",
        "updatedAt" : "2019-10-09T13:42:45Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebb974e419f786d4f448d340a4ba4a57f7f45feb",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@   * Driver side operations like `merge` and `value` are executed in the DAGScheduler thread. This\n   * thread does not have a SQL configuration so we attach our own here. Note that we can't (and\n   * shouldn't) call `merge` or `value` on an accumulator originating from an executor so we just\n   * return a default value here.\n   */"
  },
  {
    "id" : "a85cf65c-8aad-4e6e-9542-28c3ab944ebd",
    "prId" : 26012,
    "prUrl" : "https://github.com/apache/spark/pull/26012#pullrequestreview-297414404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78efb494-ad4b-4e6c-8ea0-91e9879d83e8",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "when can `mergeExpressions` be null?",
        "createdAt" : "2019-10-04T06:31:26Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "84f0db54-74bd-433e-81c1-2e82ae716779",
        "parentId" : "78efb494-ad4b-4e6c-8ea0-91e9879d83e8",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "`mergeExpressions` are transient, so they will be null on the executor side.",
        "createdAt" : "2019-10-04T11:29:27Z",
        "updatedAt" : "2019-10-04T11:31:01Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebb974e419f786d4f448d340a4ba4a57f7f45feb",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +42,46 @@  assert(bufferSchema.size == initialValues.size)\n  assert(bufferSchema.size == updateExpressions.size)\n  assert(mergeExpressions == null || bufferSchema.size == mergeExpressions.size)\n\n  private[this] var joinedRow: JoinedRow = _"
  },
  {
    "id" : "68d5bb61-8131-44af-8e77-a5da3cd9c4a3",
    "prId" : 26012,
    "prUrl" : "https://github.com/apache/spark/pull/26012#pullrequestreview-299422145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "370f1e59-a137-4276-8e05-f7b1ebe0bd4a",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "take this as an example. If we have a bug and call `value` at executor side. I'd like to fail fast to expose the bug and fix it, instead of returning an empty row which may hide the bug and give undefined behavior.",
        "createdAt" : "2019-10-07T07:00:28Z",
        "updatedAt" : "2019-10-07T07:00:28Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "277709f2-aabb-4f3b-824d-29ee4a8e5b02",
        "parentId" : "370f1e59-a137-4276-8e05-f7b1ebe0bd4a",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "I can add a check based on `isAtDriverSide`",
        "createdAt" : "2019-10-09T13:45:47Z",
        "updatedAt" : "2019-10-09T13:45:47Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebb974e419f786d4f448d340a4ba4a57f7f45feb",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +171,175 @@  }\n\n  override def value: InternalRow = withSQLConf(InternalRow.empty) {\n    // Either use the existing buffer or create a temporary one.\n    val input = if (!isZero) {"
  }
]