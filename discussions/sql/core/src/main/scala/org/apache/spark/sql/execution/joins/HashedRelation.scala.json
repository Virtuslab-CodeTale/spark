[
  {
    "id" : "92fc5b27-59f5-4c09-90c7-42831033c830",
    "prId" : 32939,
    "prUrl" : "https://github.com/apache/spark/pull/32939#pullrequestreview-685882025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "295663f1-7a05-4044-91eb-d819f55d481a",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we return it before creating the binary map?",
        "createdAt" : "2021-06-17T04:35:05Z",
        "updatedAt" : "2021-06-17T04:35:05Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6a1ed5f1-dfd0-48cd-83e7-3ff05e7a0b69",
        "parentId" : "295663f1-7a05-4044-91eb-d819f55d481a",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@cloud-fan - the NULL-aware ANTI join will be done if there's row with NULL join keys. Note the `if (!key.anyNull || allowsNullKey)` at line 472. So it will be taking effect when we reading the row with NULL join keys, and this information is not known before creating the binary map",
        "createdAt" : "2021-06-17T05:37:25Z",
        "updatedAt" : "2021-06-17T05:37:29Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d944e923f9e3a527b8009b34902c984b6bc966bb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +481,485 @@      } else if (isNullAware) {\n        binaryMap.free()\n        return HashedRelationWithAllNullKeys\n      }\n    }"
  },
  {
    "id" : "4cfaa188-6f35-4050-bd14-04747bd8e139",
    "prId" : 32939,
    "prUrl" : "https://github.com/apache/spark/pull/32939#pullrequestreview-685856977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ff43ebb-b82f-4521-aa12-5453bcce3faf",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2021-06-17T04:35:22Z",
        "updatedAt" : "2021-06-17T04:35:22Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "d944e923f9e3a527b8009b34902c984b6bc966bb",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1063,1067 @@      } else if (isNullAware) {\n        map.free()\n        return HashedRelationWithAllNullKeys\n      }\n    }"
  },
  {
    "id" : "61e7c3cd-98f1-477a-b0f6-2174fd9dd1f3",
    "prId" : 32735,
    "prUrl" : "https://github.com/apache/spark/pull/32735#pullrequestreview-673870385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f15ed3fb-dec8-4fd9-9b05-abf75f8f60f7",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I'm not sure why we use canonicalized key here. We don't do comparison but use the key to project key rows later.",
        "createdAt" : "2021-06-02T07:26:56Z",
        "updatedAt" : "2021-06-02T07:27:36Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4e13b2682b624d1d72f93d595a9faeca0b72315",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1137,1141 @@        HashedRelation(rows, key, numRows.toInt, isNullAware = isNullAware)\n      case None =>\n        HashedRelation(rows, key, isNullAware = isNullAware)\n    }\n  }"
  },
  {
    "id" : "70e3007e-11be-4bff-af5a-637bc75eb420",
    "prId" : 29389,
    "prUrl" : "https://github.com/apache/spark/pull/29389#pullrequestreview-463961086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c00ba45b-6f75-4903-9656-c95f590e8931",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "are you sure `UnsafeHashedRelation` returns null not `Iterator.empty`?",
        "createdAt" : "2020-08-10T04:31:39Z",
        "updatedAt" : "2020-08-10T23:45:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "385e4d1d-b68c-4bfc-8e2f-106408d184ed",
        "parentId" : "c00ba45b-6f75-4903-9656-c95f590e8931",
        "authorId" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "body" : "```\r\noverride def get(key: InternalRow): Iterator[InternalRow] = {\r\n    val unsafeKey = key.asInstanceOf[UnsafeRow]\r\n    val map = binaryMap  // avoid the compiler error\r\n    val loc = new map.Location  // this could be allocated in stack\r\n    binaryMap.safeLookup(unsafeKey.getBaseObject, unsafeKey.getBaseOffset,\r\n      unsafeKey.getSizeInBytes, loc, unsafeKey.hashCode())\r\n    if (loc.isDefined) {\r\n      new Iterator[UnsafeRow] {\r\n        private var _hasNext = true\r\n        override def hasNext: Boolean = _hasNext\r\n        override def next(): UnsafeRow = {\r\n          resultRow.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength)\r\n          _hasNext = loc.nextValue()\r\n          resultRow\r\n        }\r\n      }\r\n    } else {\r\n      null // return null if not match\r\n    }\r\n  }\r\n\r\n  def getValue(key: InternalRow): InternalRow = {\r\n    val unsafeKey = key.asInstanceOf[UnsafeRow]\r\n    val map = binaryMap  // avoid the compiler error\r\n    val loc = new map.Location  // this could be allocated in stack\r\n    binaryMap.safeLookup(unsafeKey.getBaseObject, unsafeKey.getBaseOffset,\r\n      unsafeKey.getSizeInBytes, loc, unsafeKey.hashCode())\r\n    if (loc.isDefined) {\r\n      resultRow.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength)\r\n      resultRow\r\n    } else {\r\n      null // return null if not match\r\n    }\r\n  }\r\n```",
        "createdAt" : "2020-08-10T05:14:45Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5309b66b23af2ffe7999edbd8f0c11f26628805d",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +955,959 @@ */\nobject EmptyHashedRelation extends NullAwareHashedRelation {\n  override def get(key: Long): Iterator[InternalRow] = null\n\n  override def get(key: InternalRow): Iterator[InternalRow] = null"
  },
  {
    "id" : "4eed1d4d-6823-4e4f-b89c-7d33abe96f99",
    "prId" : 29389,
    "prUrl" : "https://github.com/apache/spark/pull/29389#pullrequestreview-463961433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26268abf-3e21-4907-a494-34740c8559fc",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "BTW where do we call these methods for `EmptyHashedRelation`?",
        "createdAt" : "2020-08-10T04:32:35Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6f74f0af-69d8-4dd4-be01-420d9c76ccc5",
        "parentId" : "26268abf-3e21-4907-a494-34740c8559fc",
        "authorId" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "body" : "yes. It will be called. EmptyHashedRelation now is also applied at all joinType. I confirmed it while running UT.",
        "createdAt" : "2020-08-10T05:16:23Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5309b66b23af2ffe7999edbd8f0c11f26628805d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +951,955 @@/**\n * A special HashedRelation indicates it built from a empty input:Iterator[InternalRow].\n * get & getValue will return null just like\n * empty LongHashedRelation or empty UnsafeHashedRelation does.\n */"
  }
]