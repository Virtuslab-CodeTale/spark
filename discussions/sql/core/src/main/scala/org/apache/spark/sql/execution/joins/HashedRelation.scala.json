[
  {
    "id" : "92fc5b27-59f5-4c09-90c7-42831033c830",
    "prId" : 32939,
    "prUrl" : "https://github.com/apache/spark/pull/32939#pullrequestreview-685882025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "295663f1-7a05-4044-91eb-d819f55d481a",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we return it before creating the binary map?",
        "createdAt" : "2021-06-17T04:35:05Z",
        "updatedAt" : "2021-06-17T04:35:05Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6a1ed5f1-dfd0-48cd-83e7-3ff05e7a0b69",
        "parentId" : "295663f1-7a05-4044-91eb-d819f55d481a",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@cloud-fan - the NULL-aware ANTI join will be done if there's row with NULL join keys. Note the `if (!key.anyNull || allowsNullKey)` at line 472. So it will be taking effect when we reading the row with NULL join keys, and this information is not known before creating the binary map",
        "createdAt" : "2021-06-17T05:37:25Z",
        "updatedAt" : "2021-06-17T05:37:29Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d944e923f9e3a527b8009b34902c984b6bc966bb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +481,485 @@      } else if (isNullAware) {\n        binaryMap.free()\n        return HashedRelationWithAllNullKeys\n      }\n    }"
  },
  {
    "id" : "4cfaa188-6f35-4050-bd14-04747bd8e139",
    "prId" : 32939,
    "prUrl" : "https://github.com/apache/spark/pull/32939#pullrequestreview-685856977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ff43ebb-b82f-4521-aa12-5453bcce3faf",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2021-06-17T04:35:22Z",
        "updatedAt" : "2021-06-17T04:35:22Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "d944e923f9e3a527b8009b34902c984b6bc966bb",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1063,1067 @@      } else if (isNullAware) {\n        map.free()\n        return HashedRelationWithAllNullKeys\n      }\n    }"
  },
  {
    "id" : "61e7c3cd-98f1-477a-b0f6-2174fd9dd1f3",
    "prId" : 32735,
    "prUrl" : "https://github.com/apache/spark/pull/32735#pullrequestreview-673870385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f15ed3fb-dec8-4fd9-9b05-abf75f8f60f7",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I'm not sure why we use canonicalized key here. We don't do comparison but use the key to project key rows later.",
        "createdAt" : "2021-06-02T07:26:56Z",
        "updatedAt" : "2021-06-02T07:27:36Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4e13b2682b624d1d72f93d595a9faeca0b72315",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1137,1141 @@        HashedRelation(rows, key, numRows.toInt, isNullAware = isNullAware)\n      case None =>\n        HashedRelation(rows, key, isNullAware = isNullAware)\n    }\n  }"
  },
  {
    "id" : "70e3007e-11be-4bff-af5a-637bc75eb420",
    "prId" : 29389,
    "prUrl" : "https://github.com/apache/spark/pull/29389#pullrequestreview-463961086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c00ba45b-6f75-4903-9656-c95f590e8931",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "are you sure `UnsafeHashedRelation` returns null not `Iterator.empty`?",
        "createdAt" : "2020-08-10T04:31:39Z",
        "updatedAt" : "2020-08-10T23:45:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "385e4d1d-b68c-4bfc-8e2f-106408d184ed",
        "parentId" : "c00ba45b-6f75-4903-9656-c95f590e8931",
        "authorId" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "body" : "```\r\noverride def get(key: InternalRow): Iterator[InternalRow] = {\r\n    val unsafeKey = key.asInstanceOf[UnsafeRow]\r\n    val map = binaryMap  // avoid the compiler error\r\n    val loc = new map.Location  // this could be allocated in stack\r\n    binaryMap.safeLookup(unsafeKey.getBaseObject, unsafeKey.getBaseOffset,\r\n      unsafeKey.getSizeInBytes, loc, unsafeKey.hashCode())\r\n    if (loc.isDefined) {\r\n      new Iterator[UnsafeRow] {\r\n        private var _hasNext = true\r\n        override def hasNext: Boolean = _hasNext\r\n        override def next(): UnsafeRow = {\r\n          resultRow.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength)\r\n          _hasNext = loc.nextValue()\r\n          resultRow\r\n        }\r\n      }\r\n    } else {\r\n      null // return null if not match\r\n    }\r\n  }\r\n\r\n  def getValue(key: InternalRow): InternalRow = {\r\n    val unsafeKey = key.asInstanceOf[UnsafeRow]\r\n    val map = binaryMap  // avoid the compiler error\r\n    val loc = new map.Location  // this could be allocated in stack\r\n    binaryMap.safeLookup(unsafeKey.getBaseObject, unsafeKey.getBaseOffset,\r\n      unsafeKey.getSizeInBytes, loc, unsafeKey.hashCode())\r\n    if (loc.isDefined) {\r\n      resultRow.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength)\r\n      resultRow\r\n    } else {\r\n      null // return null if not match\r\n    }\r\n  }\r\n```",
        "createdAt" : "2020-08-10T05:14:45Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5309b66b23af2ffe7999edbd8f0c11f26628805d",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +955,959 @@ */\nobject EmptyHashedRelation extends NullAwareHashedRelation {\n  override def get(key: Long): Iterator[InternalRow] = null\n\n  override def get(key: InternalRow): Iterator[InternalRow] = null"
  },
  {
    "id" : "4eed1d4d-6823-4e4f-b89c-7d33abe96f99",
    "prId" : 29389,
    "prUrl" : "https://github.com/apache/spark/pull/29389#pullrequestreview-463961433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26268abf-3e21-4907-a494-34740c8559fc",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "BTW where do we call these methods for `EmptyHashedRelation`?",
        "createdAt" : "2020-08-10T04:32:35Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6f74f0af-69d8-4dd4-be01-420d9c76ccc5",
        "parentId" : "26268abf-3e21-4907-a494-34740c8559fc",
        "authorId" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "body" : "yes. It will be called. EmptyHashedRelation now is also applied at all joinType. I confirmed it while running UT.",
        "createdAt" : "2020-08-10T05:16:23Z",
        "updatedAt" : "2020-08-10T23:45:58Z",
        "lastEditedBy" : "cce1c782-0596-44b6-8b99-6b77d2cca53c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5309b66b23af2ffe7999edbd8f0c11f26628805d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +951,955 @@/**\n * A special HashedRelation indicates it built from a empty input:Iterator[InternalRow].\n * get & getValue will return null just like\n * empty LongHashedRelation or empty UnsafeHashedRelation does.\n */"
  },
  {
    "id" : "ac8522e7-9347-47b1-9f4f-0e97d796a1b1",
    "prId" : 29342,
    "prUrl" : "https://github.com/apache/spark/pull/29342#pullrequestreview-467157414",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe17e80-d83a-4bd1-a918-bc662ed4ace1",
        "parentId" : null,
        "authorId" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "body" : "If isLookupAware is not implemented to work with isNullAware then we should assert that the two are mutually exclusively enabled. ",
        "createdAt" : "2020-08-06T16:26:23Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "tags" : [
        ]
      },
      {
        "id" : "d4ad8d7c-ad8e-40b9-89ae-f23f923ae6ac",
        "parentId" : "5fe17e80-d83a-4bd1-a918-bc662ed4ace1",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@agrawaldevesh - updated with a check to throw exception in this case.",
        "createdAt" : "2020-08-07T17:00:26Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      },
      {
        "id" : "36a3f6fc-ea0c-4f62-8c7c-a05b73c3a31a",
        "parentId" : "5fe17e80-d83a-4bd1-a918-bc662ed4ace1",
        "authorId" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "body" : "^^^ So now isNullAware can work with allowsNullKey ? I don't see an exclusive or check below anymore.",
        "createdAt" : "2020-08-13T17:46:26Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "tags" : [
        ]
      },
      {
        "id" : "55a4d493-48cd-417e-9185-b056e34aa4d4",
        "parentId" : "5fe17e80-d83a-4bd1-a918-bc662ed4ace1",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@agrawaldevesh - was accidentally removed during iterations. added back. Thanks.",
        "createdAt" : "2020-08-13T21:57:48Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "526709b73b87687f48f68486b9c8c7be0866291f",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +441,445 @@      sizeEstimate: Int,\n      taskMemoryManager: TaskMemoryManager,\n      isNullAware: Boolean = false,\n      allowsNullKey: Boolean = false): HashedRelation = {\n    require(!(isNullAware && allowsNullKey),"
  },
  {
    "id" : "9da1ab33-421d-43b8-820f-abfa06241c24",
    "prId" : 29342,
    "prUrl" : "https://github.com/apache/spark/pull/29342#pullrequestreview-467101936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8eeb08ae-23d2-46e4-866c-f4c7c2890fe5",
        "parentId" : null,
        "authorId" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "body" : "Could it be problematic that resultRow is reuse here as a part of embedding it in valueRowWithKeyIndex ? Ideally I think we allocate a new fresh copy of the row owned by the valueRow that is then updated here. \r\n\r\nCurrently, as written, modifying `resultRow` without valueRow elsewhere might lead to issues.",
        "createdAt" : "2020-08-13T17:43:43Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "tags" : [
        ]
      },
      {
        "id" : "9b6c5ade-280e-4acd-9ee2-af6033b0a5d9",
        "parentId" : "8eeb08ae-23d2-46e4-866c-f4c7c2890fe5",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@agrawaldevesh - not sure if I fully understand this, but if you are talking about potentially misusing between `resultRow` and `valueRowWithKeyIndex`, yes it can lead to arbitrary kind of bug. One can argue that this is same problem for `resultRow` and [`JoinedRow`](https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/JoinedRow.scala) . `valueRowWithKeyIndex` is wrapper for `resultRow`, similar as `JoinedRow` is wrapper for `resultRow`.",
        "createdAt" : "2020-08-13T18:52:11Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      },
      {
        "id" : "4c85cd06-f6a3-46dc-8813-70a2c288f62d",
        "parentId" : "8eeb08ae-23d2-46e4-866c-f4c7c2890fe5",
        "authorId" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "body" : "Okay. Sorry I am new to this code as well :-P But if this is the precedent then fine. \r\n\r\nIf I was coding this, I would have allocate a new row inside of valueRowWithKeyIndex, and then call valueRowWithKeyIndex.row.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength).\r\n\r\nBut its okay since there is already precedent.",
        "createdAt" : "2020-08-13T20:29:51Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "711a9ca0-8b90-435a-bf87-eb621aa1db13",
        "tags" : [
        ]
      }
    ],
    "commit" : "526709b73b87687f48f68486b9c8c7be0866291f",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +296,300 @@        }\n        val loc = iter.next()\n        resultRow.pointTo(loc.getValueBase, loc.getValueOffset, loc.getValueLength)\n        valueRowWithKeyIndex.update(loc.getKeyIndex, resultRow)\n      }"
  },
  {
    "id" : "b8054774-658c-4cbc-83c1-301c8b7fadd3",
    "prId" : 29342,
    "prUrl" : "https://github.com/apache/spark/pull/29342#pullrequestreview-468010952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e729a18e-10eb-4709-b7d3-c6268f010987",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto in https://github.com/apache/spark/pull/29342/files#r470463130",
        "createdAt" : "2020-08-14T07:48:00Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "11506db1-558c-4b22-97ea-6c549e7c69fd",
        "parentId" : "e729a18e-10eb-4709-b7d3-c6268f010987",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@cloud-fan - per your comment in the other place, I take the current naming is okay as well, let me know if it's not the case, thanks.",
        "createdAt" : "2020-08-15T20:45:36Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "526709b73b87687f48f68486b9c8c7be0866291f",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +90,94 @@   * Returns the maximum number of allowed keys index.\n   */\n  def maxNumKeysIndex: Int\n\n  /**"
  },
  {
    "id" : "a5e30d1f-988c-4d67-915a-b300ab8fe03a",
    "prId" : 29342,
    "prUrl" : "https://github.com/apache/spark/pull/29342#pullrequestreview-467925221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bf236c6-a130-407e-b0d5-3e0517c82e13",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Is this for unique key case only?",
        "createdAt" : "2020-08-14T20:15:09Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "dc6d5fb9-0e57-407f-8113-4376c94cdf1c",
        "parentId" : "2bf236c6-a130-407e-b0d5-3e0517c82e13",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@viirya - yes. Similar to definition of `def getValue(key: InternalRow): InternalRow` above. I added comment to say `Returns key index and matched single row.`, to be consistent with comment of `getValue`. Hope this is clear enough.",
        "createdAt" : "2020-08-14T20:41:38Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      },
      {
        "id" : "4987213a-3319-46ef-9251-8e06ea9e5fa7",
        "parentId" : "2bf236c6-a130-407e-b0d5-3e0517c82e13",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Can you add comment saying this is for unique key case?",
        "createdAt" : "2020-08-14T23:02:14Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "5b30c1b9-dfc5-4b53-82b5-d82874507f2c",
        "parentId" : "2bf236c6-a130-407e-b0d5-3e0517c82e13",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@viirya - sure, added.",
        "createdAt" : "2020-08-14T23:53:29Z",
        "updatedAt" : "2020-08-16T18:24:08Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "526709b73b87687f48f68486b9c8c7be0866291f",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +80,84 @@   * Returns null if there is no matched rows.\n   */\n  def getValueWithKeyIndex(key: InternalRow): ValueRowWithKeyIndex\n\n  /**"
  }
]