[
  {
    "id" : "c2fe7733-4fd5-476b-847e-037a87b24a88",
    "prId" : 33081,
    "prUrl" : "https://github.com/apache/spark/pull/33081#pullrequestreview-692589086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f90a1bf2-15e3-45ab-b6de-ed76c9421985",
        "parentId" : null,
        "authorId" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "body" : "There's a case session column is not placed at the end of the key. This line addresses such case.",
        "createdAt" : "2021-06-25T08:33:17Z",
        "updatedAt" : "2021-06-25T08:33:18Z",
        "lastEditedBy" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbade3501f16e9437ba9af4feca3e2029785d273",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +182,186 @@  private val valueProj = GenerateUnsafeProjection.generate(valuesExpressions, inputSchema)\n  private val restoreProj = GenerateUnsafeProjection.generate(inputSchema,\n    groupingWithoutSession.map(_.toAttribute) ++ Seq(sessionExpression.toAttribute) ++\n      valuesExpressions.map(_.toAttribute))\n"
  },
  {
    "id" : "a0403b5f-7146-42d4-b690-a0a751a553b3",
    "prId" : 33081,
    "prUrl" : "https://github.com/apache/spark/pull/33081#pullrequestreview-708099774",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7f9b944-d58f-4773-8f18-387d241efba3",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "why adding this change?",
        "createdAt" : "2021-07-15T05:33:16Z",
        "updatedAt" : "2021-07-15T05:39:10Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "aa880cec-3464-433c-baf3-0d2483bb3a29",
        "parentId" : "e7f9b944-d58f-4773-8f18-387d241efba3",
        "authorId" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "body" : "I found some edge-case that the last two input rows close session. If that happens, `returnRowsIter` is not null in this method (that's why I removed assertion) and we have to append both iterators instead of simply replacing.\r\n\r\nThat's why I have to add `.copy()` in groupingKey as evaluation takes lazily and somehow two iterators would use same key which it shouldn't.",
        "createdAt" : "2021-07-15T07:39:42Z",
        "updatedAt" : "2021-07-15T07:39:42Z",
        "lastEditedBy" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "tags" : [
        ]
      },
      {
        "id" : "ac775740-f110-4dca-99b8-2683cb486073",
        "parentId" : "e7f9b944-d58f-4773-8f18-387d241efba3",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Have you added corresponding test for the edge cases?",
        "createdAt" : "2021-07-16T07:50:06Z",
        "updatedAt" : "2021-07-16T07:50:06Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbade3501f16e9437ba9af4feca3e2029785d273",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +206,210 @@    } else {\n      returnRowsIter = currentRowsIter\n    }\n\n    if (keyChanged) processedKeys.add(currentKeys)"
  }
]