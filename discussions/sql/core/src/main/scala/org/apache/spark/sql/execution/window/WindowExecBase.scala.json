[
  {
    "id" : "56246499-808a-4d7a-b90e-8afa8abf3633",
    "prId" : 31356,
    "prUrl" : "https://github.com/apache/spark/pull/31356#pullrequestreview-602456037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4431ba0f-38ba-4f1b-b33c-77148c2826f4",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This means that we can't use one frame to evaluate `last_value` and other aggregate functions.\r\n\r\nTBH I'm not sure if it's worth extending the framework for such a small optimization.",
        "createdAt" : "2021-03-02T13:29:25Z",
        "updatedAt" : "2021-03-02T13:29:25Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0203ee6d-5274-477f-9927-21e9bae4e776",
        "parentId" : "4431ba0f-38ba-4f1b-b33c-77148c2826f4",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "You mean I understand. It is not worthwhile to optimize the `last_value` alone in the framework.\r\nI also feel that way. If we can find other functions that are the same as `last_value` in the future, then we can do it.",
        "createdAt" : "2021-03-03T02:33:54Z",
        "updatedAt" : "2021-03-03T02:33:54Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "a10115c30472b3ec9ecd2e1499afb1fe0be7fe26",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +241,245 @@            }\n\n          case (\"AGGREGATE_LAST\", _, UnboundedPreceding, UnboundedFollowing, _) =>\n            target: InternalRow => {\n              new UnboundedWindowFunctionFrame(target, processor, true)"
  },
  {
    "id" : "a3df9558-1a03-4b11-ab33-177129c9d7a7",
    "prId" : 31178,
    "prUrl" : "https://github.com/apache/spark/pull/31178#pullrequestreview-568797079",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce4faac8-a9f4-47cb-bf9c-d8683bf0a3cb",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "if we go with the `case _ => collect(\"AGGREGATE\", frame, e, f)` branch, do we still support ignore nulls?",
        "createdAt" : "2021-01-15T03:41:17Z",
        "updatedAt" : "2021-01-20T15:58:23Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ade17953-7cce-4fb2-8391-08f8c24c79ac",
        "parentId" : "ce4faac8-a9f4-47cb-bf9c-d8683bf0a3cb",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "Nth_value also supports ignore nulls",
        "createdAt" : "2021-01-15T03:44:24Z",
        "updatedAt" : "2021-01-20T15:58:23Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf17bae5e8d3f7c0eb1c17d90b75618d60553d4d",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +153,157 @@            case f: OffsetWindowFunction if frame.frameType == RowFrame &&\n              frame.lower == UnboundedPreceding =>\n              frame.upper match {\n                case UnboundedFollowing => collect(\"UNBOUNDED_OFFSET\", f.fakeFrame, e, f)\n                case CurrentRow => collect(\"UNBOUNDED_PRECEDING_OFFSET\", f.fakeFrame, e, f)"
  }
]