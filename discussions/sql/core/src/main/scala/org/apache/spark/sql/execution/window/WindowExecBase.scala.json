[
  {
    "id" : "56246499-808a-4d7a-b90e-8afa8abf3633",
    "prId" : 31356,
    "prUrl" : "https://github.com/apache/spark/pull/31356#pullrequestreview-602456037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4431ba0f-38ba-4f1b-b33c-77148c2826f4",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This means that we can't use one frame to evaluate `last_value` and other aggregate functions.\r\n\r\nTBH I'm not sure if it's worth extending the framework for such a small optimization.",
        "createdAt" : "2021-03-02T13:29:25Z",
        "updatedAt" : "2021-03-02T13:29:25Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0203ee6d-5274-477f-9927-21e9bae4e776",
        "parentId" : "4431ba0f-38ba-4f1b-b33c-77148c2826f4",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "You mean I understand. It is not worthwhile to optimize the `last_value` alone in the framework.\r\nI also feel that way. If we can find other functions that are the same as `last_value` in the future, then we can do it.",
        "createdAt" : "2021-03-03T02:33:54Z",
        "updatedAt" : "2021-03-03T02:33:54Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "a10115c30472b3ec9ecd2e1499afb1fe0be7fe26",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +241,245 @@            }\n\n          case (\"AGGREGATE_LAST\", _, UnboundedPreceding, UnboundedFollowing, _) =>\n            target: InternalRow => {\n              new UnboundedWindowFunctionFrame(target, processor, true)"
  },
  {
    "id" : "a3df9558-1a03-4b11-ab33-177129c9d7a7",
    "prId" : 31178,
    "prUrl" : "https://github.com/apache/spark/pull/31178#pullrequestreview-568797079",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce4faac8-a9f4-47cb-bf9c-d8683bf0a3cb",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "if we go with the `case _ => collect(\"AGGREGATE\", frame, e, f)` branch, do we still support ignore nulls?",
        "createdAt" : "2021-01-15T03:41:17Z",
        "updatedAt" : "2021-01-20T15:58:23Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ade17953-7cce-4fb2-8391-08f8c24c79ac",
        "parentId" : "ce4faac8-a9f4-47cb-bf9c-d8683bf0a3cb",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "Nth_value also supports ignore nulls",
        "createdAt" : "2021-01-15T03:44:24Z",
        "updatedAt" : "2021-01-20T15:58:23Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf17bae5e8d3f7c0eb1c17d90b75618d60553d4d",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +153,157 @@            case f: OffsetWindowFunction if frame.frameType == RowFrame &&\n              frame.lower == UnboundedPreceding =>\n              frame.upper match {\n                case UnboundedFollowing => collect(\"UNBOUNDED_OFFSET\", f.fakeFrame, e, f)\n                case CurrentRow => collect(\"UNBOUNDED_PRECEDING_OFFSET\", f.fakeFrame, e, f)"
  },
  {
    "id" : "184d4680-b2bd-4efa-b3cd-a75bad06eac7",
    "prId" : 29800,
    "prUrl" : "https://github.com/apache/spark/pull/29800#pullrequestreview-505336140",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe1b833-115f-4b08-9d57-1caabb2ef9d6",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "`UNBOUNDED_FOLLOWING_OFFSET` ?",
        "createdAt" : "2020-10-07T07:25:47Z",
        "updatedAt" : "2020-10-28T02:15:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "66debadc-979d-4809-be5c-83a5edd540e4",
        "parentId" : "4fe1b833-115f-4b08-9d57-1caabb2ef9d6",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "I use the name `UNBOUNDED_OFFSET` because there is `UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING`.",
        "createdAt" : "2020-10-09T03:30:25Z",
        "updatedAt" : "2020-10-28T02:15:58Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c0e82ba0ab95af7871b4b16f8be1e0662d49c78",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +141,145 @@              frame.frameType == RowFrame && frame.lower == UnboundedPreceding =>\n              frame.upper match {\n                case UnboundedFollowing => collect(\"UNBOUNDED_OFFSET\", f.fakeFrame, e, f)\n                case CurrentRow => collect(\"UNBOUNDED_PRECEDING_OFFSET\", f.fakeFrame, e, f)\n                case _ => collect(\"AGGREGATE\", frame, e, f)"
  },
  {
    "id" : "38edd765-68c6-4122-b1f0-bc3c6dfcf547",
    "prId" : 29800,
    "prUrl" : "https://github.com/apache/spark/pull/29800#pullrequestreview-515542637",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18bc6c75-612a-468b-a3e6-45104149add9",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "do we have test case for this branch?",
        "createdAt" : "2020-10-23T10:07:40Z",
        "updatedAt" : "2020-10-28T02:15:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0a538e78-e081-48e2-947c-68763cf58cf2",
        "parentId" : "18bc6c75-612a-468b-a3e6-45104149add9",
        "authorId" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "body" : "OK.",
        "createdAt" : "2020-10-23T10:32:17Z",
        "updatedAt" : "2020-10-28T02:15:58Z",
        "lastEditedBy" : "f26e51a2-ed90-47c7-9856-a6cc134b7f39",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c0e82ba0ab95af7871b4b16f8be1e0662d49c78",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +143,147 @@                case UnboundedFollowing => collect(\"UNBOUNDED_OFFSET\", f.fakeFrame, e, f)\n                case CurrentRow => collect(\"UNBOUNDED_PRECEDING_OFFSET\", f.fakeFrame, e, f)\n                case _ => collect(\"AGGREGATE\", frame, e, f)\n              }\n            case f: AggregateWindowFunction => collect(\"AGGREGATE\", frame, e, f)"
  }
]