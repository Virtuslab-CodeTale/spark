[
  {
    "id" : "b7ffcded-4ff9-4075-aa30-ea35cc6efdce",
    "prId" : 31403,
    "prUrl" : "https://github.com/apache/spark/pull/31403#pullrequestreview-580386951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05918c78-2a63-4571-abd9-a4361b085e53",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "It's probably time to figure out the public Scala API for multi-catalogs: Shall we have one single `CatalogImpl` instance, and all its methods support catalog? Or shall we have one `CatalogImpl` instance per catalog?\r\n\r\nThe change here makes `recoverPartitions` to support multi-catalogs.",
        "createdAt" : "2021-02-01T12:58:47Z",
        "updatedAt" : "2021-02-01T12:58:47Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "a8d5ddfc-e027-41cd-be42-18ae9773acf6",
        "parentId" : "05918c78-2a63-4571-abd9-a4361b085e53",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "Currently, other methods in `CatalogImpl` can work with both v1 and v2 tables already. Look at `cacheTable()`, `isCached()`, `refreshTable()`. I don't see much difference between those methods and `recoverPartitions()`.\r\n\r\nAnd the focus of this PR is to re-use new resolution framework, and to have consistent error message. Not taking into account that recovering partition of v2 tables is not supported at the moment.\r\n\r\nIn general, `CatalogImpl` has a lot of pretty specific to v1 catalog implementation things. ",
        "createdAt" : "2021-02-01T13:43:05Z",
        "updatedAt" : "2021-02-01T13:43:05Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "6d1a9b69-b6ce-4245-8c40-b23278c5cd1e",
        "parentId" : "05918c78-2a63-4571-abd9-a4361b085e53",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ah since it's already the case, let's move forward then.",
        "createdAt" : "2021-02-01T14:08:52Z",
        "updatedAt" : "2021-02-01T14:08:52Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "49a9455adf5e5c59e61d2ad6c413171802985b71",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +446,450 @@   * @since 2.1.1\n   */\n  override def recoverPartitions(tableName: String): Unit = {\n    val multiPartIdent = sparkSession.sessionState.sqlParser.parseMultipartIdentifier(tableName)\n    sparkSession.sessionState.executePlan("
  },
  {
    "id" : "e93acbd7-9f6a-4ff9-9f63-f4b4f037ab4d",
    "prId" : 31206,
    "prUrl" : "https://github.com/apache/spark/pull/31206#pullrequestreview-571981476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7cc91fff-6f97-436a-8545-84245d46415d",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This seems duplicated with the above statement `re-cache the table and its dependents lazily.`. Maybe we should change the above to `re-cache the table lazily.`",
        "createdAt" : "2021-01-20T02:21:36Z",
        "updatedAt" : "2021-01-21T09:07:03Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6888eeb8-4630-414a-94d8-5a96a6914cf2",
        "parentId" : "7cc91fff-6f97-436a-8545-84245d46415d",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "Don't think it is a duplicate. It describes the case when a table is not cached. See the PR https://github.com/apache/spark/pull/30187 in which the statement was added by @sunchao and committed by @dongjoon-hyun .",
        "createdAt" : "2021-01-20T08:41:27Z",
        "updatedAt" : "2021-01-21T09:07:03Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      }
    ],
    "commit" : "357c69f888ed4f27ea8db3b78d79d123b4dac019",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +522,526 @@   * If this table is cached as an InMemoryRelation, re-cache the table and its dependents lazily.\n   *\n   * In addition, refreshing a table also clear all caches that have reference to the table\n   * in a cascading manner. This is to prevent incorrect result from the otherwise staled caches.\n   *"
  }
]