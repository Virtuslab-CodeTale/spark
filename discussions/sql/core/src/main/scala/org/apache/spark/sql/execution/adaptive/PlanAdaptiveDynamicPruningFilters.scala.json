[
  {
    "id" : "2aa8c86e-6e74-48be-8f4d-9a0ed3c33750",
    "prId" : 32861,
    "prUrl" : "https://github.com/apache/spark/pull/32861#pullrequestreview-706093329",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b20b441-8a64-4f54-80f3-ffbd39874f01",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we call `QueryExecution.prepareExecutedPlan`? For non-AQE DPP, we will plan the DPP subquery in the rule `PlanSubqueries`, which calls `prepareExecutedPlan`",
        "createdAt" : "2021-07-14T08:38:51Z",
        "updatedAt" : "2021-07-14T08:38:52Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f7b9a14a-85d1-4948-affd-74328ae27960",
        "parentId" : "9b20b441-8a64-4f54-80f3-ffbd39874f01",
        "authorId" : "1b84a7ff-6bf9-4417-bf9f-e46e997e5974",
        "body" : "Updated.",
        "createdAt" : "2021-07-14T10:11:28Z",
        "updatedAt" : "2021-07-14T10:11:28Z",
        "lastEditedBy" : "1b84a7ff-6bf9-4417-bf9f-e46e997e5974",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac56149ba63e399b4a96bb655681ea6d0dac0221",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +77,81 @@          // plan optimization rules be inserted twice, once in AQE framework and\n          // another in prepareExecutedPlan() method.\n          val sparkPlan = QueryExecution.createSparkPlan(session, planner, aggregate)\n          val newAdaptivePlan = adaptivePlan.copy(inputPlan = sparkPlan)\n          val values = SubqueryExec(name, newAdaptivePlan)"
  },
  {
    "id" : "b0d338fd-7a87-4aac-90bd-bb4be739b419",
    "prId" : 31941,
    "prUrl" : "https://github.com/apache/spark/pull/31941#pullrequestreview-619238613",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a54c090-cc9e-42b1-8cf7-3fb98cb2154c",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Seems we don't need this config. It's always beneficial to do so. The AQE + DPP integration is only in master and not released yet, so we don't need to worry about regressions.",
        "createdAt" : "2021-03-23T14:32:45Z",
        "updatedAt" : "2021-03-23T14:32:45Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "e19c72a7-897f-4cab-87a3-b0e4cf32857c",
        "parentId" : "7a54c090-cc9e-42b1-8cf7-3fb98cb2154c",
        "authorId" : "31afe32d-3af0-4fcf-93e2-115f5d7bab18",
        "body" : "Thank you for your time. Yes, we may keep it now for reviewing and remove it finally.",
        "createdAt" : "2021-03-24T01:52:02Z",
        "updatedAt" : "2021-03-24T01:52:02Z",
        "lastEditedBy" : "31afe32d-3af0-4fcf-93e2-115f5d7bab18",
        "tags" : [
        ]
      }
    ],
    "commit" : "0208465f540323f8df849ef761c6d895541eb714",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +76,80 @@            logDebug(s\"PlanAdaptiveDynamicPruningFilters: reuseQueryStage => $reuseQueryStage\")\n            Option(reuseQueryStage)\n          } else if (conf.dynamicPartitionPruningCreateBroadcastEnabled) {\n            var newStage = adaptivePlan.newQueryStage(exchange)\n            val queryStage = stageCache.getOrElseUpdate(exchange.canonicalized, newStage)"
  },
  {
    "id" : "8e25e126-0638-46b2-a6a8-206ac9c3fe45",
    "prId" : 31258,
    "prUrl" : "https://github.com/apache/spark/pull/31258#pullrequestreview-583103388",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6902609-d69e-44ba-b4a1-fc91df74bfec",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "does it still work if the DPP subquery has query stages inside?",
        "createdAt" : "2021-02-03T16:39:40Z",
        "updatedAt" : "2021-02-08T13:36:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "891eea83-192f-42b9-a15a-d1b79a4e602c",
        "parentId" : "c6902609-d69e-44ba-b4a1-fc91df74bfec",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "now we can put `adaptivePlan` directly.",
        "createdAt" : "2021-02-04T07:36:16Z",
        "updatedAt" : "2021-02-08T13:36:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e1b097c38ba468b751260b00262c21781892047",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +44,48 @@        val mode = HashedRelationBroadcastMode(packedKeys)\n        // plan a broadcast exchange of the build side of the join\n        val exchange = BroadcastExchangeExec(mode, adaptivePlan.executedPlan)\n        val existingStage = stageCache.get(exchange.canonicalized)\n        if (existingStage.nonEmpty && conf.exchangeReuseEnabled) {"
  }
]