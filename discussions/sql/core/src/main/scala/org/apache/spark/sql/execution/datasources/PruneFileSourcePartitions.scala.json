[
  {
    "id" : "4dfcbdc6-7e81-4c83-a255-b51dd34d9dca",
    "prId" : 33584,
    "prUrl" : "https://github.com/apache/spark/pull/33584#pullrequestreview-719634360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db3fbd08-f79a-46d3-b55f-45d273a6ba08",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Conceptually, it is a bit weird to have two rules handling pruning partition.",
        "createdAt" : "2021-08-01T07:49:48Z",
        "updatedAt" : "2021-08-01T08:07:03Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbc85db716de1db24bdb67f2ca9075dcaa648ded",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +30,34 @@ * Prune the partitions of file source based table using partition filters. Currently, this rule\n * is applied to [[HadoopFsRelation]] with [[CatalogFileIndex]]. [[DataSourceV2ScanRelation]]\n * with [[FileScan]] is pruned in [[PushDownUtils]].\n *\n * For [[HadoopFsRelation]], the location will be replaced by pruned file index, and corresponding"
  },
  {
    "id" : "1a3a84d4-ade2-43f0-8460-9e2760f26b73",
    "prId" : 29075,
    "prUrl" : "https://github.com/apache/spark/pull/29075#pullrequestreview-447674027",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "574a495e-6ff2-4dfe-8e62-0fcd61a43617",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "```\r\n    val (extraPartitionFilters, otherFilters) = remainingFilterInCnf.partition(f =>\r\n      f.references.subsetOf(partitionSet)\r\n    )\r\n    (ExpressionSet(partitionFilters ++ extraPartitionFilters), otherFilters)\r\n```\r\n?",
        "createdAt" : "2020-07-13T01:24:39Z",
        "updatedAt" : "2020-07-13T08:58:41Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "8b59bfc9-131a-4b05-88e9-d88fa71210c1",
        "parentId" : "574a495e-6ff2-4dfe-8e62-0fcd61a43617",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "In that way, `otherFilters` can be very long, which leads to a longer codegen... I am avoiding that on purpose. Let me add comment here.",
        "createdAt" : "2020-07-13T02:57:54Z",
        "updatedAt" : "2020-07-13T08:58:41Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "631f0fca-3fd3-4ea8-b99c-a4da2412214f",
        "parentId" : "574a495e-6ff2-4dfe-8e62-0fcd61a43617",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "okay.",
        "createdAt" : "2020-07-13T23:16:04Z",
        "updatedAt" : "2020-07-13T23:16:04Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "6fe106ce84e83641d66d572c45050b25761bbf3d",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +67,71 @@    // instead of using the non-convertible part from `remainingFilterInCnf`. Otherwise, the\n    // result filters can be very long.\n    (ExpressionSet(partitionFilters ++ extraPartitionFilters), remainingFilters)\n  }\n"
  }
]