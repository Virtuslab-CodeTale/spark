[
  {
    "id" : "45d6f838-c6b3-46b6-912c-0e9938ee4502",
    "prId" : 33058,
    "prUrl" : "https://github.com/apache/spark/pull/33058#pullrequestreview-692465660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2de5be31-a187-40c5-8e3b-3de95c9f78bd",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is kind of the AQE version of \"execute\", as AQE won't call `execute` of shuffle/broadcast.",
        "createdAt" : "2021-06-24T12:39:30Z",
        "updatedAt" : "2021-06-24T12:39:30Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "d26dc1d7-2718-49f5-8006-6ae5c6e6c960",
        "parentId" : "2de5be31-a187-40c5-8e3b-3de95c9f78bd",
        "authorId" : "1b84a7ff-6bf9-4417-bf9f-e46e997e5974",
        "body" : "Can we add some comments for this method?",
        "createdAt" : "2021-06-25T05:40:50Z",
        "updatedAt" : "2021-06-25T05:40:50Z",
        "lastEditedBy" : "1b84a7ff-6bf9-4417-bf9f-e46e997e5974",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a7e388cc221a1c0b4f8709c53c7cadcbb3c3450",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +60,64 @@   * It also does the preparations work, such as waiting for the subqueries.\n   */\n  final def submitBroadcastJob: scala.concurrent.Future[broadcast.Broadcast[Any]] = executeQuery {\n    completionFuture\n  }"
  },
  {
    "id" : "7ff1b576-28ff-44e1-b709-c8c27101982d",
    "prId" : 32911,
    "prUrl" : "https://github.com/apache/spark/pull/32911#pullrequestreview-684315252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca0b21d5-9eb8-499b-ab58-a3f7fb28c2b9",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Could you add some comments about this condition, @c21 ?",
        "createdAt" : "2021-06-15T15:56:53Z",
        "updatedAt" : "2021-06-15T15:56:54Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "14bfab3e-d3cb-4895-86be-16189c900002",
        "parentId" : "ca0b21d5-9eb8-499b-ab58-a3f7fb28c2b9",
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "@dongjoon-hyun - sure, added.",
        "createdAt" : "2021-06-15T17:45:54Z",
        "updatedAt" : "2021-06-15T17:46:06Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "01652b5e2abe7ed6532c25f5acb43580c8043619",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +112,116 @@      // NOTE: LongHashedRelation is used for single key with LongType. This should be kept\n      // consistent with HashedRelation.apply.\n      if !(key.length == 1 && key.head.dataType == LongType) =>\n      // Since the maximum number of keys that BytesToBytesMap supports is 1 << 29,\n      // and only 70% of the slots can be used before growing in UnsafeHashedRelation,"
  }
]