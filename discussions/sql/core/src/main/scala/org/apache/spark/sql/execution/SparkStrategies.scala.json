[
  {
    "id" : "ee3fb466-e139-45a9-a8a1-57a521189daa",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-727913807",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ac4d4cb-4c77-4dc1-885a-5a4483c43784",
        "parentId" : null,
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "RoundRobin sorts data before shuffling right? That will slow things a lot.",
        "createdAt" : "2021-08-11T19:03:31Z",
        "updatedAt" : "2021-08-11T19:03:31Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "2b240d47-de90-4d62-b8b4-8311642c5313",
        "parentId" : "5ac4d4cb-4c77-4dc1-885a-5a4483c43784",
        "authorId" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "body" : "Yes, that's why we put a TODO there.",
        "createdAt" : "2021-08-11T20:12:33Z",
        "updatedAt" : "2021-08-11T20:12:45Z",
        "lastEditedBy" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +686,690 @@        // TODO create a new identity partitioning instead of using RoundRobinPartitioning.\n        exchange.ShuffleExchangeExec(\n          RoundRobinPartitioning(conf.numShufflePartitions),\n          planLater(newPlan),\n          REPARTITION_BY_COL) :: Nil"
  },
  {
    "id" : "6972f06c-fe91-4ada-bc98-1179cedff43c",
    "prId" : 33093,
    "prUrl" : "https://github.com/apache/spark/pull/33093#pullrequestreview-697558169",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "parentId" : null,
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "`planLater(initialState)` Is it still correct when `initialState` has a batch `FlatMapGroupsWithState`? Could you add a test for this case?",
        "createdAt" : "2021-06-30T21:37:11Z",
        "updatedAt" : "2021-06-30T21:52:57Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      },
      {
        "id" : "00e368ad-1633-4c6c-ae91-6c071dffb37d",
        "parentId" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "authorId" : "0e7383af-ae8f-4891-9ab6-e80efa3990c0",
        "body" : "do we still need to worry about it now since we are passing a keyValueGroupedDataset",
        "createdAt" : "2021-07-01T12:14:16Z",
        "updatedAt" : "2021-07-01T12:14:16Z",
        "lastEditedBy" : "0e7383af-ae8f-4891-9ab6-e80efa3990c0",
        "tags" : [
        ]
      },
      {
        "id" : "63963c8e-7a38-4cef-8323-45162202b2af",
        "parentId" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "> do we still need to worry about it now since we are passing a keyValueGroupedDataset\r\n\r\nWe do. You can still get it from `ds.flatMapGroups(...).groupBy(key)...`. I feel this rule is missing `isStreaming` check, but haven't checked it.",
        "createdAt" : "2021-07-01T18:47:54Z",
        "updatedAt" : "2021-07-01T18:47:54Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb83b684fdc7d62846b3860f90d26ec119c136c5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +567,571 @@          func, keyDeser, valueDeser, sDeser, groupAttr, stateGroupAttr, dataAttr, sda, outputAttr,\n          None, stateEnc, stateVersion, outputMode, timeout, batchTimestampMs = None,\n          eventTimeWatermark = None, planLater(initialState), hasInitialState, planLater(child)\n        )\n        execPlan :: Nil"
  },
  {
    "id" : "4ea782e8-0509-4782-9cb7-06408d0d95d7",
    "prId" : 33081,
    "prUrl" : "https://github.com/apache/spark/pull/33081#pullrequestreview-706976281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4730ad6c-7af7-4c80-8c1b-2f3869b3a719",
        "parentId" : null,
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "nit: we get the aggregation state format version twice https://github.com/apache/spark/pull/33081/files#diff-21f071d73070b8257ad76e6e16ec5ed38a13d1278fe94bd42546c258a69f4410R327",
        "createdAt" : "2021-07-15T04:24:07Z",
        "updatedAt" : "2021-07-15T04:51:30Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      },
      {
        "id" : "560e0595-1906-42d2-8802-9d47e8631f42",
        "parentId" : "4730ad6c-7af7-4c80-8c1b-2f3869b3a719",
        "authorId" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "body" : "I'll remove above one. Nice finding!",
        "createdAt" : "2021-07-15T06:36:46Z",
        "updatedAt" : "2021-07-15T06:36:46Z",
        "lastEditedBy" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbade3501f16e9437ba9af4feca3e2029785d273",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +352,356 @@\n          case None =>\n            val stateVersion = conf.getConf(SQLConf.STREAMING_AGGREGATION_STATE_FORMAT_VERSION)\n\n            AggUtils.planStreamingAggregation("
  }
]