[
  {
    "id" : "ee3fb466-e139-45a9-a8a1-57a521189daa",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-727913807",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ac4d4cb-4c77-4dc1-885a-5a4483c43784",
        "parentId" : null,
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "RoundRobin sorts data before shuffling right? That will slow things a lot.",
        "createdAt" : "2021-08-11T19:03:31Z",
        "updatedAt" : "2021-08-11T19:03:31Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "2b240d47-de90-4d62-b8b4-8311642c5313",
        "parentId" : "5ac4d4cb-4c77-4dc1-885a-5a4483c43784",
        "authorId" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "body" : "Yes, that's why we put a TODO there.",
        "createdAt" : "2021-08-11T20:12:33Z",
        "updatedAt" : "2021-08-11T20:12:45Z",
        "lastEditedBy" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +686,690 @@        // TODO create a new identity partitioning instead of using RoundRobinPartitioning.\n        exchange.ShuffleExchangeExec(\n          RoundRobinPartitioning(conf.numShufflePartitions),\n          planLater(newPlan),\n          REPARTITION_BY_COL) :: Nil"
  },
  {
    "id" : "6972f06c-fe91-4ada-bc98-1179cedff43c",
    "prId" : 33093,
    "prUrl" : "https://github.com/apache/spark/pull/33093#pullrequestreview-697558169",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "parentId" : null,
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "`planLater(initialState)` Is it still correct when `initialState` has a batch `FlatMapGroupsWithState`? Could you add a test for this case?",
        "createdAt" : "2021-06-30T21:37:11Z",
        "updatedAt" : "2021-06-30T21:52:57Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      },
      {
        "id" : "00e368ad-1633-4c6c-ae91-6c071dffb37d",
        "parentId" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "authorId" : "0e7383af-ae8f-4891-9ab6-e80efa3990c0",
        "body" : "do we still need to worry about it now since we are passing a keyValueGroupedDataset",
        "createdAt" : "2021-07-01T12:14:16Z",
        "updatedAt" : "2021-07-01T12:14:16Z",
        "lastEditedBy" : "0e7383af-ae8f-4891-9ab6-e80efa3990c0",
        "tags" : [
        ]
      },
      {
        "id" : "63963c8e-7a38-4cef-8323-45162202b2af",
        "parentId" : "98e4426c-2368-4954-b787-a11cbd233a30",
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "> do we still need to worry about it now since we are passing a keyValueGroupedDataset\r\n\r\nWe do. You can still get it from `ds.flatMapGroups(...).groupBy(key)...`. I feel this rule is missing `isStreaming` check, but haven't checked it.",
        "createdAt" : "2021-07-01T18:47:54Z",
        "updatedAt" : "2021-07-01T18:47:54Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb83b684fdc7d62846b3860f90d26ec119c136c5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +567,571 @@          func, keyDeser, valueDeser, sDeser, groupAttr, stateGroupAttr, dataAttr, sda, outputAttr,\n          None, stateEnc, stateVersion, outputMode, timeout, batchTimestampMs = None,\n          eventTimeWatermark = None, planLater(initialState), hasInitialState, planLater(child)\n        )\n        execPlan :: Nil"
  },
  {
    "id" : "4ea782e8-0509-4782-9cb7-06408d0d95d7",
    "prId" : 33081,
    "prUrl" : "https://github.com/apache/spark/pull/33081#pullrequestreview-706976281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4730ad6c-7af7-4c80-8c1b-2f3869b3a719",
        "parentId" : null,
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "nit: we get the aggregation state format version twice https://github.com/apache/spark/pull/33081/files#diff-21f071d73070b8257ad76e6e16ec5ed38a13d1278fe94bd42546c258a69f4410R327",
        "createdAt" : "2021-07-15T04:24:07Z",
        "updatedAt" : "2021-07-15T04:51:30Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      },
      {
        "id" : "560e0595-1906-42d2-8802-9d47e8631f42",
        "parentId" : "4730ad6c-7af7-4c80-8c1b-2f3869b3a719",
        "authorId" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "body" : "I'll remove above one. Nice finding!",
        "createdAt" : "2021-07-15T06:36:46Z",
        "updatedAt" : "2021-07-15T06:36:46Z",
        "lastEditedBy" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbade3501f16e9437ba9af4feca3e2029785d273",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +352,356 @@\n          case None =>\n            val stateVersion = conf.getConf(SQLConf.STREAMING_AGGREGATION_STATE_FORMAT_VERSION)\n\n            AggUtils.planStreamingAggregation("
  },
  {
    "id" : "90e7c893-633d-4fb0-9487-917cbac796d2",
    "prId" : 32355,
    "prUrl" : "https://github.com/apache/spark/pull/32355#pullrequestreview-656210701",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "can we check this in `ResolveJoinStrategyHints`?",
        "createdAt" : "2021-04-27T06:16:45Z",
        "updatedAt" : "2021-04-27T06:16:45Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f6de0eb1-961d-483d-9732-b0a90538d2b9",
        "parentId" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "authorId" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "body" : "I thought about it but seems we need to do this check in physical side.\r\n\r\nWe don't konw the join strategy at analysis or optimizer (`EliminateResolvedHint`). For example, if user specify `boradcast`, we need to check if it's a equijoin first then check the build side, since this join could be bhj or bnlj.",
        "createdAt" : "2021-04-27T06:51:59Z",
        "updatedAt" : "2021-04-27T06:51:59Z",
        "lastEditedBy" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "tags" : [
        ]
      },
      {
        "id" : "6c3cf8b3-fdb3-4f19-8265-c0ea65eaaf56",
        "parentId" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "maybe we can move `ExtractEquiJoinKeys` to catalyst?",
        "createdAt" : "2021-04-27T06:58:42Z",
        "updatedAt" : "2021-04-27T06:58:42Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "b3d39983-345e-46df-8d48-4b37e237c6d0",
        "parentId" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "authorId" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "body" : "It's a point. How about make a new rule at Optimizer `Finish Analysis` batch to check if join is illegal. Move to Optimizer is to avoid effect like `EliminateOuterJoin`.",
        "createdAt" : "2021-04-27T07:35:00Z",
        "updatedAt" : "2021-04-27T07:35:00Z",
        "lastEditedBy" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "tags" : [
        ]
      },
      {
        "id" : "1a0c57f8-6e4c-491b-9796-93feb1464cd5",
        "parentId" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "`EliminateOuterJoin` is a good point, so we can only know if the hint is valid or not at the planner.\r\n\r\nIt's a bit unfortunate to see the hint code being widespread, @maryannxue do you have any thoughts?",
        "createdAt" : "2021-04-27T08:10:15Z",
        "updatedAt" : "2021-04-27T08:10:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6ec8330d-53bc-45c3-9340-0e4dd75028b2",
        "parentId" : "46c515d7-f5dd-4bcf-bf85-fc4571d82398",
        "authorId" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "body" : "How about move `EliminateResolvedHint` from optimizer to physical side ? then we can add the check in one rule.",
        "createdAt" : "2021-05-11T01:30:29Z",
        "updatedAt" : "2021-05-11T01:30:29Z",
        "lastEditedBy" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1e7ba082bfb557c67adad8f6c5c4ec7af622167",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +142,146 @@    with PredicateHelper\n    with JoinSelectionHelper {\n    private val hintErrorHandler = conf.hintErrorHandler\n\n    private def checkHintBuildSide("
  },
  {
    "id" : "600c991a-e429-413b-adeb-09a0f3d3212d",
    "prId" : 32355,
    "prUrl" : "https://github.com/apache/spark/pull/32355#pullrequestreview-720407628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39a5bd40-8bfc-4e66-a161-4df7c5aa967b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "can we make it more general? I think we can also give a warning if SMJ/SHJ hint is specified but the join has no join keys.",
        "createdAt" : "2021-08-02T16:50:46Z",
        "updatedAt" : "2021-08-02T16:50:46Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1e7ba082bfb557c67adad8f6c5c4ec7af622167",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +199,203 @@      case j @ ExtractEquiJoinKeys(joinType, leftKeys, rightKeys, nonEquiCond, left, right, hint) =>\n        def createBroadcastHashJoin(onlyLookingAtHint: Boolean) = {\n          val buildSide = getBroadcastBuildSide(\n            left, right, joinType, hint, onlyLookingAtHint, conf)\n          checkHintBuildSide(onlyLookingAtHint, buildSide, joinType, hint, true)"
  }
]