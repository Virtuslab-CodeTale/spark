[
  {
    "id" : "8d99f04f-0888-4a8d-b247-c047834ffd22",
    "prId" : 28983,
    "prUrl" : "https://github.com/apache/spark/pull/28983#pullrequestreview-445951723",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6909e96-589b-4a1d-ad34-edfc9084441b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "A followup we can do is to resolve and bind using the actual input data types, so that we can do casting or reorder fields.",
        "createdAt" : "2020-07-09T08:44:48Z",
        "updatedAt" : "2020-07-09T08:44:48Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "9dc48a15-db07-46fe-bcdf-f63238e84c66",
        "parentId" : "c6909e96-589b-4a1d-ad34-edfc9084441b",
        "authorId" : "4c995a1a-1668-4460-9df8-b8244472ae24",
        "body" : "That would be nice.  I tried this and but the way I did it wasn't having any effect.",
        "createdAt" : "2020-07-09T12:44:14Z",
        "updatedAt" : "2020-07-09T12:44:15Z",
        "lastEditedBy" : "4c995a1a-1668-4460-9df8-b8244472ae24",
        "tags" : [
        ]
      },
      {
        "id" : "f3894906-8947-4eca-87b8-e954af22bb8d",
        "parentId" : "c6909e96-589b-4a1d-ad34-edfc9084441b",
        "authorId" : "4c995a1a-1668-4460-9df8-b8244472ae24",
        "body" : "@cloud-fan  what I had done earlier was:\r\n```scala\r\nobject ResolveEncodersInScalaAgg extends Rule[LogicalPlan] {\r\n  override def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\r\n    case p if !p.resolved => p\r\n    case p => p.transformExpressionsUp {\r\n      case agg: ScalaAggregator[_, _, _] =>\r\n        val children = agg.children\r\n        require(children.length > 0, \"Missing aggregator input\")\r\n        val dataType: DataType = if (children.length == 1) children.head.dataType else {\r\n          StructType(children.map(_.dataType).zipWithIndex.map { case (dt, j) =>\r\n            StructField(s\"_$j\", dt, true)\r\n          })\r\n        }\r\n        val attrs = if (agg.inputEncoder.isSerializedAsStructForTopLevel) {\r\n          dataType.asInstanceOf[StructType].toAttributes\r\n        } else {\r\n          (new StructType().add(\"input\", dataType)).toAttributes\r\n        }\r\n        agg.copy(\r\n          inputEncoder = agg.inputEncoder.resolveAndBind(attrs),\r\n          bufferEncoder = agg.bufferEncoder.resolveAndBind())\r\n    }\r\n  }\r\n}\r\n```\r\nThis also passes unit tests, but it would still fail if I tried to give it `Float` data, so it's not automatically casting.",
        "createdAt" : "2020-07-09T20:38:45Z",
        "updatedAt" : "2020-07-09T20:38:45Z",
        "lastEditedBy" : "4c995a1a-1668-4460-9df8-b8244472ae24",
        "tags" : [
        ]
      }
    ],
    "commit" : "622ac1c245e0918d9c99af2c0cb69671284ee7ac",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +530,534 @@      case agg: ScalaAggregator[_, _, _] =>\n        agg.copy(\n          inputEncoder = agg.inputEncoder.resolveAndBind(),\n          bufferEncoder = agg.bufferEncoder.resolveAndBind())\n    }"
  }
]