[
  {
    "id" : "90a4cacb-b2b5-419e-88b3-6a4e14ff9fee",
    "prId" : 31708,
    "prUrl" : "https://github.com/apache/spark/pull/31708#pullrequestreview-601628102",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68f4ef11-122a-4fdc-8495-0eb887532b85",
        "parentId" : null,
        "authorId" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "body" : "Test for `RIGHT OUTER`, `LEFT SEMI`, `LEFT ANTI` is omitted here, as I cannot reproduce a valid test case. The broadcast nested loop join always changes the join type to `INNER` join, or reorder somehow. I think there's some optimization rule are taking effect.",
        "createdAt" : "2021-03-02T09:52:15Z",
        "updatedAt" : "2021-03-03T02:21:09Z",
        "lastEditedBy" : "8df147d9-bc9d-4fd9-bb98-5dcf9619220b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e6729cc89ac05f6842d335e7ac59fb765a827db",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +1374,1378 @@\n      // Test output ordering is not preserved\n      Seq(\"LEFT OUTER\", \"FULL OUTER\").foreach {\n        joinType =>\n          val selectExpr = \"/*+ BROADCAST(left_t) */ k1 as k0\""
  }
]