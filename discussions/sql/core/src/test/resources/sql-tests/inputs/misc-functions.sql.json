[
  {
    "id" : "21fe37f5-f40c-4735-ad1a-c9730ec19566",
    "prId" : 29947,
    "prUrl" : "https://github.com/apache/spark/pull/29947#pullrequestreview-503446343",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b49a913-6970-4158-b7a5-8e11f88438b9",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you add tests like this?\r\n```\r\nscala> sql(\"select * from t\").show()\r\n+---+\r\n|  v|\r\n+---+\r\n|  1|\r\n|  8|\r\n|  2|\r\n+---+\r\n\r\nscala> sql(\"select if(v > 5, raise_error('error found: ' || v), v + 1) from t\").show()\r\njava.lang.RuntimeException: error found: 8\r\n  at org.apache.spark.sql.catalyst.expressions.RaiseError.eval(misc.scala:80)\r\n```\r\nThat is because I think it is a common usecase to print out an error message with an invalid value.",
        "createdAt" : "2020-10-07T00:23:47Z",
        "updatedAt" : "2020-10-08T03:03:41Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b93fd49313152356a3fd2baf6c21123170c4037",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +10,14 @@select typeof(array(1, 2)), typeof(map(1, 2)), typeof(named_struct('a', 1, 'b', 'spark'));\n\n-- Spark-32793: Rewrite AssertTrue with RaiseError\nSELECT assert_true(true), assert_true(boolean(1));\nSELECT assert_true(false);"
  },
  {
    "id" : "1518bb20-cba7-41eb-be87-fdfe269dbcfb",
    "prId" : 26599,
    "prUrl" : "https://github.com/apache/spark/pull/26599#pullrequestreview-319845865",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a76bf99-28d0-4d09-9301-af0164124a74",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "do you know why these tests pass before we add `UTF8String.fromString`?",
        "createdAt" : "2019-11-20T13:21:59Z",
        "updatedAt" : "2019-11-20T13:21:59Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f06d95d3-0031-44ee-ab19-55b50448c3ac",
        "parentId" : "7a76bf99-28d0-4d09-9301-af0164124a74",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ah I got it. The rule constant folding calls `Literal.create(e.eval(EmptyRow), e.dataType)`, which converts the data to internal format.\r\n\r\nNow I'm curious about how we expose this bug with UDT...",
        "createdAt" : "2019-11-20T13:23:52Z",
        "updatedAt" : "2019-11-20T13:24:05Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f8e12029-03df-446c-a52f-91aa36b89977",
        "parentId" : "7a76bf99-28d0-4d09-9301-af0164124a74",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "~~In `CatalystTypeConverters`~~\r\n```scala\r\n /**\r\n   *  Converts Scala objects to Catalyst rows / types.\r\n   *\r\n   *  Note: This should be called before do evaluation on Row\r\n   *        (It does not support UDT)\r\n   *  This is used to create an RDD or test results with correct types for Catalyst.\r\n   */\r\n  def convertToCatalyst(a: Any): Any = a match {\r\n```",
        "createdAt" : "2019-11-20T13:41:56Z",
        "updatedAt" : "2019-11-20T13:45:38Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "5759be3abea554b325d7696961ebf1e2d4385f8c",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +4,8 @@select typeof(null);\nselect typeof(true);\nselect typeof(1Y), typeof(1S), typeof(1), typeof(1L);\nselect typeof(cast(1.0 as float)), typeof(1.0D), typeof(1.2);\nselect typeof(date '1986-05-23'),  typeof(timestamp '1986-05-23'), typeof(interval '23 days');"
  }
]