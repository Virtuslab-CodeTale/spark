[
  {
    "id" : "76b651a2-7a7d-4a99-aa03-f465053ad09f",
    "prId" : 28912,
    "prUrl" : "https://github.com/apache/spark/pull/28912#pullrequestreview-440465915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "652b84fe-76a7-4f57-9428-9625365a6b81",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "nit: add a single blank line.",
        "createdAt" : "2020-07-01T00:09:37Z",
        "updatedAt" : "2020-07-01T16:12:00Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "4aaa34bb85e9d702514978ce31bc740f325294f7",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +100,104 @@      assert(executeStatementOperation.getStatus.getState === finalState)\n    }\n  }\n\n  private class MySparkExecuteStatementOperation("
  },
  {
    "id" : "f2f5bfc4-db2c-4acf-b4cd-123e1a854760",
    "prId" : 28912,
    "prUrl" : "https://github.com/apache/spark/pull/28912#pullrequestreview-440765858",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15100fe2-f292-4613-871c-967a6e388780",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "`eventually` here, too?",
        "createdAt" : "2020-07-01T00:10:31Z",
        "updatedAt" : "2020-07-01T16:12:00Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "7314a291-9443-443f-834e-3e1b9e7f38cc",
        "parentId" : "15100fe2-f292-4613-871c-967a6e388780",
        "authorId" : "6dab27d0-518d-4e22-a61b-9bc2b8fb450a",
        "body" : "In the case where the state is already `finalState` when cleanup() is called, then the following would pass:\r\n\r\n```\r\nsignal.release()\r\neventually(timeout(5 seconds)) {\r\n  assert(getStatus.getState === finalState)\r\n}\r\n```\r\n\r\nbecause we have not given the exception time to propagate in the other thread. Eventually will execute the first iteration (whose assert is true) then exit immediately. By sleeping, we check if ERROR does not surface even after having become `finalState`.",
        "createdAt" : "2020-07-01T09:56:20Z",
        "updatedAt" : "2020-07-01T16:12:00Z",
        "lastEditedBy" : "6dab27d0-518d-4e22-a61b-9bc2b8fb450a",
        "tags" : [
        ]
      },
      {
        "id" : "80cf6389-1834-457a-8cd6-5cbc22783a06",
        "parentId" : "15100fe2-f292-4613-871c-967a6e388780",
        "authorId" : "e5beb795-ac0e-4bd6-ad66-708215b8ae58",
        "body" : "@alismess-db I was wondering about hte same place before as well.\r\nLet's maybe add a comment explaining it like e.g.\r\n`// At this point, operation should already be in finalState (set by either close() or cancel()). We want to check if it stays in finalState after the exception thrown from after releasing the semaphore propagates`",
        "createdAt" : "2020-07-01T11:00:17Z",
        "updatedAt" : "2020-07-01T16:12:00Z",
        "lastEditedBy" : "e5beb795-ac0e-4bd6-ad66-708215b8ae58",
        "tags" : [
        ]
      }
    ],
    "commit" : "4aaa34bb85e9d702514978ce31bc740f325294f7",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +117,121 @@      // cancel()). We want to check if it stays in finalState after the exception thrown by\n      // releasing the semaphore propagates. We hence need to sleep for a short while.\n      Thread.sleep(1000)\n      // State should not be ERROR\n      assert(getStatus.getState === finalState)"
  }
]