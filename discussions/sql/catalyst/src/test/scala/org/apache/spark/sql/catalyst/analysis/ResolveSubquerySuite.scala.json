[
  {
    "id" : "57f0f03d-2e36-4fbe-8b9b-5923911a6fee",
    "prId" : 32787,
    "prUrl" : "https://github.com/apache/spark/pull/32787#pullrequestreview-684739825",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98f228fa-ba5c-4a86-977a-63e5b3bc452a",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you add tests for case-sensitivities?",
        "createdAt" : "2021-06-11T06:36:30Z",
        "updatedAt" : "2021-06-11T06:40:56Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "5f8a3899-f174-4819-9269-8857ab6dbbb0",
        "parentId" : "98f228fa-ba5c-4a86-977a-63e5b3bc452a",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Also, I think we need some tests for `spark.sql.parser.quotedRegexColumnNames`.",
        "createdAt" : "2021-06-11T06:37:56Z",
        "updatedAt" : "2021-06-11T06:40:56Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "9a56cd97-168a-4ca4-b77c-98ae7ffa7ab4",
        "parentId" : "98f228fa-ba5c-4a86-977a-63e5b3bc452a",
        "authorId" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "body" : "@maropu I looked into how regex expressions are resolved and the logic is actually different from star expressions. It won't throw exceptions when there is no match. Instead, it returns an empty sequence. So we can't tell if the regex expression is resolved by the current plan with an empty output, or it can't be resolved.",
        "createdAt" : "2021-06-16T05:35:52Z",
        "updatedAt" : "2021-06-16T05:35:53Z",
        "lastEditedBy" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "tags" : [
        ]
      }
    ],
    "commit" : "0346d3b7c0cbbe3edf88a1451da9bf53726a458d",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +180,184 @@  }\n\n  test(\"SPARK-35618: lateral join with star expansion\") {\n    val outerA = OuterReference(a.withQualifier(Seq(\"t1\"))).as(a.name)\n    val outerB = OuterReference(b.withQualifier(Seq(\"t1\"))).as(b.name)"
  },
  {
    "id" : "e93cf8fa-c2c2-4f17-a071-40672f4569c4",
    "prId" : 32303,
    "prUrl" : "https://github.com/apache/spark/pull/32303#pullrequestreview-678210722",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc2bca06-4c53-48e0-b1ba-c5425cbc73c1",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "note: we can improve the error message in the future, to include columns from the outer plan as well.",
        "createdAt" : "2021-06-08T08:00:58Z",
        "updatedAt" : "2021-06-08T08:00:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "01fa70ec156ad5540b862c4b13dd1257062f31fb",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +140,144 @@    assertAnalysisError(\n      lateralJoin(t1, t0.select('a, 'c)),\n      Seq(\"cannot resolve 'c' given input columns: []\")\n    )\n    // SELECT * FROM t1, LATERAL (SELECT a, b, c, d FROM t2)"
  }
]