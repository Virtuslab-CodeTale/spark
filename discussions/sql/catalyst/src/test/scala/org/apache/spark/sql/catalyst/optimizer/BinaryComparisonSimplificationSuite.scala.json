[
  {
    "id" : "dc2abcb7-80c8-48a1-a986-dc580ea5f8bd",
    "prId" : 29349,
    "prUrl" : "https://github.com/apache/spark/pull/29349#pullrequestreview-463062476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bf8a75f-37af-467f-9f67-f7a22dc3ea3b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Here we construct the resolved plan directly, because we need to reply on case insensitive and `.analyze` use case sensitive analyzer.",
        "createdAt" : "2020-08-07T06:08:53Z",
        "updatedAt" : "2020-08-07T06:08:53Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "d7511591-2210-4c67-abbf-062deb52e57f",
        "parentId" : "3bf8a75f-37af-467f-9f67-f7a22dc3ea3b",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I go to look at this test and its original PR. `fieldA1` and `fieldA2` are not different in letter case, but the `name` in `GetStructField`. That is why above comment is `GetStructField with different names are semantically equal`.",
        "createdAt" : "2020-08-07T06:25:14Z",
        "updatedAt" : "2020-08-07T06:25:15Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a71545264bcbeca679d2fbf22b013c07d054556",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +120,124 @@    // GetStructField with different names are semantically equal; thus, `EqualTo(fieldA1, fieldA2)`\n    // will be optimized to `TrueLiteral` by `SimplifyBinaryComparison`.\n    val originalQuery = nonNullableRelation.where(EqualTo(fieldA1, fieldA2))\n\n    val optimized = Optimize.execute(originalQuery)"
  },
  {
    "id" : "15d770ec-848d-4af5-901f-4e94e4a05e29",
    "prId" : 27008,
    "prUrl" : "https://github.com/apache/spark/pull/27008#pullrequestreview-341191538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb388315-3fc5-4f46-8ad5-35cab564e792",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shouldn't this be `nullableRelation.where(false)`?",
        "createdAt" : "2020-01-10T12:57:23Z",
        "updatedAt" : "2020-01-10T12:57:23Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "e371dd0a-3ba9-479f-b34c-53f4d1d4ef42",
        "parentId" : "eb388315-3fc5-4f46-8ad5-35cab564e792",
        "authorId" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "body" : "`False` has been remove by `PruneFilters`, so result is just empty LocalRelation.",
        "createdAt" : "2020-01-10T14:22:06Z",
        "updatedAt" : "2020-01-10T14:22:06Z",
        "lastEditedBy" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "tags" : [
        ]
      }
    ],
    "commit" : "af0fbd60f6561d989160c1b9fbaedfa2996f00d0",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +171,175 @@        val plan = nullableRelation.where(condition).analyze\n        val actual = Optimize.execute(plan)\n        val correctAnswer = nullableRelation.analyze\n        comparePlans(actual, correctAnswer)\n      }"
  }
]