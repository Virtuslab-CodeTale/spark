[
  {
    "id" : "e15112bc-054c-43e9-895f-218cea6a3654",
    "prId" : 31855,
    "prUrl" : "https://github.com/apache/spark/pull/31855#pullrequestreview-615670483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8ae3e45-3e5e-49af-85b7-77e1ca937141",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "This generator is used to test expressions like `random timestamp + random day-time interval`. I have to adjust the generator to have reasonable intervals, and prevent overflows.",
        "createdAt" : "2021-03-18T17:17:58Z",
        "updatedAt" : "2021-03-18T17:17:58Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      }
    ],
    "commit" : "c851449fd6b76079a0e8694366e892c1833135c9",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +165,169 @@\n  lazy val dayTimeIntervalLiteralGen: Gen[Literal] = {\n    calendarIntervalLiterGen.map { calendarIntervalLiteral =>\n      Literal.create(\n        calendarIntervalLiteral.value.asInstanceOf[CalendarInterval].extractAsDuration(),"
  },
  {
    "id" : "7185d723-ce32-47d8-90d9-37d66885f7ad",
    "prId" : 31812,
    "prUrl" : "https://github.com/apache/spark/pull/31812#pullrequestreview-610564663",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d2f5335-14d6-4682-82e9-1bbad1a9397b",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "I restricted the range of random year-month intervals here because such interval are used in the tests for expressions like `date -/+ interval` where `date` is random too. If we don't restrict the range, we will just get the overflow exception in most cases. The code here is similar to https://github.com/apache/spark/blob/4ea27787bf96c83aeda4ff6d4b1d9b00cc189f7e/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/expressions/LiteralGenerator.scala#L140-L143\r\n\r\nBTW, there is another random generator in `RandomDataGenerator` which doesn't have such restriction, and it can be used in other tests like saving/loading to datasources.",
        "createdAt" : "2021-03-12T08:50:03Z",
        "updatedAt" : "2021-03-12T08:51:28Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      }
    ],
    "commit" : "058591bfad33006d13bcc091ab529a96e7b24890",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +177,181 @@  lazy val yearMonthIntervalLiteralGen: Gen[Literal] = {\n    for { months <- Gen.choose(-1 * maxIntervalInMonths, maxIntervalInMonths) }\n      yield Literal.create(Period.ofMonths(months), YearMonthIntervalType)\n  }\n"
  },
  {
    "id" : "b2325c0b-5b49-4de2-a9e9-5a95755a1110",
    "prId" : 29515,
    "prUrl" : "https://github.com/apache/spark/pull/29515#pullrequestreview-473045348",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eed98113-6ebb-4d71-99b7-05073e4cecf7",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Just a question; what's the range of values this method generates?",
        "createdAt" : "2020-08-22T23:17:10Z",
        "updatedAt" : "2020-09-04T10:37:07Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "06944155-6e0f-492c-b1b2-a34baa4642d5",
        "parentId" : "eed98113-6ebb-4d71-99b7-05073e4cecf7",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "It generates all the possible floating point values equally likely, besides the special values: `Float.NaN, Float.PositiveInfinity, Float.NegativeInfinity`, that are not returned by the `Arbitrary.arbFloat.arbitrary`.",
        "createdAt" : "2020-08-23T01:41:52Z",
        "updatedAt" : "2020-09-04T10:37:07Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "37d222ea-c111-427d-9fc6-b623375f297b",
        "parentId" : "eed98113-6ebb-4d71-99b7-05073e4cecf7",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Except for the special values, original generated range is Float.MinValue / 2, Float.MaxValue / 2. The revised one is different? Although looks like it is okay.",
        "createdAt" : "2020-08-23T20:59:39Z",
        "updatedAt" : "2020-09-04T10:37:07Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "529aba8e7207a22039aebbe379d9d27035a143c1",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +78,82 @@          Float.NaN, Float.PositiveInfinity, Float.NegativeInfinity, Float.MinPositiveValue,\n          Float.MaxValue, -Float.MaxValue, 0.0f, -0.0f, 1.0f, -1.0f),\n        Arbitrary.arbFloat.arbitrary\n      )\n    } yield Literal.create(f, FloatType)"
  },
  {
    "id" : "19f07bf5-959f-4384-8fd7-9e430ecd76a7",
    "prId" : 29515,
    "prUrl" : "https://github.com/apache/spark/pull/29515#pullrequestreview-472973235",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca12cc24-6cea-4209-b45d-ec74529f15aa",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Do you want MaxValue in here too, as the largest non-infinite float? same for double",
        "createdAt" : "2020-08-22T23:24:58Z",
        "updatedAt" : "2020-09-04T10:37:07Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "07f51e53-a667-40e8-8ac3-4e84dff9451c",
        "parentId" : "ca12cc24-6cea-4209-b45d-ec74529f15aa",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "Sure thing",
        "createdAt" : "2020-08-23T01:57:25Z",
        "updatedAt" : "2020-09-04T10:37:07Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      }
    ],
    "commit" : "529aba8e7207a22039aebbe379d9d27035a143c1",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +76,80 @@      f <- Gen.oneOf(\n        Gen.oneOf(\n          Float.NaN, Float.PositiveInfinity, Float.NegativeInfinity, Float.MinPositiveValue,\n          Float.MaxValue, -Float.MaxValue, 0.0f, -0.0f, 1.0f, -1.0f),\n        Arbitrary.arbFloat.arbitrary"
  }
]