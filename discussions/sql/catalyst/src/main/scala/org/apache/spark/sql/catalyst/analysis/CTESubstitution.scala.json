[
  {
    "id" : "7b064783-0c22-42de-ac61-59add1eea324",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-727631385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e378dbb2-e018-4bff-a2e6-cc88357b4f4f",
        "parentId" : null,
        "authorId" : "8c82da5a-f351-4a37-a8a9-13809311b07b",
        "body" : "`plan.collectFirst` would be quicker and less memory-hungry, wouldn't it?",
        "createdAt" : "2021-08-11T14:42:24Z",
        "updatedAt" : "2021-08-11T14:46:43Z",
        "lastEditedBy" : "8c82da5a-f351-4a37-a8a9-13809311b07b",
        "tags" : [
        ]
      },
      {
        "id" : "06615c77-e8a1-41de-b5a8-ff09722e3baf",
        "parentId" : "e378dbb2-e018-4bff-a2e6-cc88357b4f4f",
        "authorId" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "body" : "Maybe I'm missing sth, but I don't see how so.",
        "createdAt" : "2021-08-11T15:26:07Z",
        "updatedAt" : "2021-08-11T15:26:07Z",
        "lastEditedBy" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +49,53 @@object CTESubstitution extends Rule[LogicalPlan] {\n  def apply(plan: LogicalPlan): LogicalPlan = {\n    val isCommand = plan.find {\n      case _: Command | _: ParsedStatement | _: InsertIntoDir => true\n      case _ => false"
  },
  {
    "id" : "524d8d14-b2ed-4753-be8c-a70225210d68",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-731817751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "107615de-c197-46f2-be00-2f7a8ac2ad53",
        "parentId" : null,
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "As the return value of `traverseAndSubstituteCTE` changed a bit, this docs could use some update.",
        "createdAt" : "2021-08-17T14:09:24Z",
        "updatedAt" : "2021-08-17T14:09:24Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +168,172 @@   *   )\n   * @param plan the plan to be traversed\n   * @return the plan where CTE substitution is applied\n   */\n  private def traverseAndSubstituteCTE("
  },
  {
    "id" : "a1792865-0bd5-4f25-bd40-cb82c45ae91f",
    "prId" : 28407,
    "prUrl" : "https://github.com/apache/spark/pull/28407#pullrequestreview-403359701",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "parentId" : null,
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan Just trying to understand. innerCTEResolved indicates a already resolved CTE or the one we are going to resolve in the subsequent call to substituteCTE ?",
        "createdAt" : "2020-04-30T07:29:45Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      },
      {
        "id" : "a2e60535-8431-4e7a-94d7-b881cce8d889",
        "parentId" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "\"resolved\" here means the `With` is resolved inside this relation. The relation needs further processing to substitute `UnresolvedRelation` with the previous CTE relations.\r\n\r\nThe naming is not very accurate when `legacy = true`, but this probably doesn't matter.",
        "createdAt" : "2020-04-30T09:09:37Z",
        "updatedAt" : "2020-04-30T12:09:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f7bb0a0f-fedb-4965-bd00-29492b7d8b0a",
        "parentId" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan OK. sounds good.",
        "createdAt" : "2020-04-30T09:38:46Z",
        "updatedAt" : "2020-04-30T09:38:46Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      }
    ],
    "commit" : "b022e3513a842329b24569840a07a501bed9a188",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +152,156 @@    val resolvedCTERelations = new mutable.ArrayBuffer[(String, LogicalPlan)](relations.size)\n    for ((name, relation) <- relations) {\n      val innerCTEResolved = if (isLegacy) {\n        // In legacy mode, outer CTE relations take precedence. Here we don't resolve the inner\n        // `With` nodes, later we will substitute `UnresolvedRelation`s with outer CTE relations."
  },
  {
    "id" : "11f0251c-006c-49f4-97dd-512ae42cfec2",
    "prId" : 28407,
    "prUrl" : "https://github.com/apache/spark/pull/28407#pullrequestreview-403323467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32cf7bb3-10c6-4fbb-95f4-4629f0ca5863",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "For legacy case, `innerCTEResolved` might contain an inner `WITH`, but seems `substituteCTE` doesn't remove `WITH`.\r\n\r\nThen in later `substituteCTE`s, will we result some untouched `WITH`s in the final query plan ?\r\n\r\n\r\n\r\n\r\n\r\n",
        "createdAt" : "2020-04-30T07:57:27Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "3786d1a6-c744-4d8d-bd01-48f6d5c5aeb9",
        "parentId" : "32cf7bb3-10c6-4fbb-95f4-4629f0ca5863",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "The rule `CTESubstitution` runs in a batch many times (https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala#L208-L212) so those `With`s will be removed in the end because we substitute `child` here: https://github.com/apache/spark/pull/28407/files#diff-d0bfa3367c63988ad7cf33397e643e75R91",
        "createdAt" : "2020-04-30T08:49:33Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b022e3513a842329b24569840a07a501bed9a188",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +163,167 @@      }\n      // CTE definition can reference a previous one\n      resolvedCTERelations += (name -> substituteCTE(innerCTEResolved, resolvedCTERelations))\n    }\n    resolvedCTERelations"
  },
  {
    "id" : "144290ef-98e8-4998-bb17-bba7fa83aaf2",
    "prId" : 28371,
    "prUrl" : "https://github.com/apache/spark/pull/28371#pullrequestreview-401106704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95b29554-9717-474b-afb9-8959b6169bef",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "My bad. I missed to check case-sensitivity.",
        "createdAt" : "2020-04-27T16:10:38Z",
        "updatedAt" : "2020-04-27T16:19:50Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "24a487dce69a0bc55148164d650259268b45dc4f",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +65,69 @@        relations.foreach {\n          case (name, relation) =>\n            if (startOfQuery && outerCTERelationNames.exists(resolver(_, name))) {\n              throw new AnalysisException(s\"Name $name is ambiguous in nested CTE. \" +\n                s\"Please set ${LEGACY_CTE_PRECEDENCE_POLICY.key} to CORRECTED so that name \" +"
  },
  {
    "id" : "72d396e1-034f-4bbc-b5ac-406a1682ccb5",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-399905076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9ba50e7-0308-446a-bc1b-e0e412406bd5",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2020-04-24T12:34:27Z",
        "updatedAt" : "2020-04-24T13:26:35Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +63,67 @@        }.toSet ++ namesInSubqueries\n        assertNoNameConflictsInCTE(child, outerCTERelationNames, newNames)\n        w.innerChildren.foreach(assertNoNameConflictsInCTE(_, newNames, newNames))\n\n      case other =>"
  },
  {
    "id" : "48ffe4fb-2f8c-4bc0-82bd-f7f8d47ef03f",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-399965592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b4ea4aa-98f3-4678-ab2c-09777af0fe2b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shouldn't this be `assertNoNameConflictsInCTE(_, namesInSubqueries, Nil)`?",
        "createdAt" : "2020-04-24T13:35:44Z",
        "updatedAt" : "2020-04-24T13:35:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "c17e6aba-3a64-423f-b36e-69342246f542",
        "parentId" : "7b4ea4aa-98f3-4678-ab2c-09777af0fe2b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "In that case we wouldn't report\r\n```\r\nWITH t AS (SELECT 1)\r\nSELECT (\r\n  SELECT (\r\n    WITH t AS (SELECT 2)\r\n    SELECT * FROM t\r\n  )\r\n)\r\n```\r\nas ambiguous, but it returns `1` in legacy and `2` in corrected modes. ",
        "createdAt" : "2020-04-24T13:52:24Z",
        "updatedAt" : "2020-04-24T13:52:25Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +67,71 @@      case other =>\n        other.subqueries.foreach(\n          assertNoNameConflictsInCTE(_, namesInSubqueries, namesInSubqueries))\n        other.children.foreach(\n          assertNoNameConflictsInCTE(_, outerCTERelationNames, namesInSubqueries))"
  },
  {
    "id" : "ebf82aeb-62ab-4bde-9c85-f711ed6f1fb3",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-400556142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "There are 3 kinds of conflicts:\r\n1. conflicts in the children, e.g. `with t as (...) select * from (with t as (...) select * from t)`\r\n2. conflicts in other CTE relations, e.g. `with t as (...), t2 as (with t as (...) select * from t) ...`\r\n3. conflicts in the subqueries of the children, e.g. `with t as (...) select ... where ... in (with t as (...) select * from t)`\r\n\r\nThe third one can be handled correctly by 2.4 as well, so we shouldn't fail.\r\n\r\nCan you briefly explain how you check the first 2 conflicts and skip the third one?",
        "createdAt" : "2020-04-24T14:18:42Z",
        "updatedAt" : "2020-04-24T14:18:42Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "4d4815c3-b88b-4c9d-b235-06cd2ae9d318",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I thought 3. is not handled correctly in 2.4. (I haven't tested it on Spark 2.4.) But it certainly produces different results in Spark 3 in the 2 different modes.\r\n- In legacy it returns `1` (https://github.com/apache/spark/pull/28318/files#diff-46573f0caf504536cf46d2b267bb5a37R171-R181). This PR hasn't touched this mode, but if you are right then it should.\r\n- In corrected it returns empty result after this PR (before the PR it returned `1`)(https://github.com/apache/spark/pull/28318/files#diff-0c15df52c8221453db6102ff4196cb90R171-R181).",
        "createdAt" : "2020-04-24T14:33:57Z",
        "updatedAt" : "2020-04-24T14:33:57Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "ea13cec1-7087-4abc-9544-336f8dd8ab6c",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I checked 3. in Spark 2.4 with the query in the description and it returns `1` so is not handled correctly and we should fail.\r\n\r\n1. In this case the legacy and corrected mode returns the same result due to the same substitution order so we shouldn't throw an exception. If we call the possible conflicting set of names coming from outer CTEs as `outerCTERelationNames` then I handle this case by not extending the set with new names when I traverse down the child of a `With` (https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R64) or when I traverse down the children of any other node (https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R70-R71).\r\n\r\n2. and 3. In these cases, the two modes have different substitution order and so possibly different results. Obviously we need an extended set of names (`newNames`) when we encounter a `With` and switch to that set (pass in as a new `outerCTERelationNames`) when we traverse down inner children (2.)( https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R65) or traverse down subquery expressions (3.)(https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R68-R69)\r\n\r\nSo what is the contents of `outerCTERelationNames`? The set of CTE names coming from outer CTEs. It doesn't contain the CTEs coming from a parent `With` from the same `LogicalPlan` (1.). But it contains outer CTEs coming from `With`s from outer `LogicalPlan`s (2., 3.)\r\nAnd the content of `namesInSubqueries` is simply all CTE names from all outer `With`s, no matter if the `With` is the same plan or in an outer plan.\r\n\r\nSo I think what we need to do here is basically skip the 1. and check 2. and 3.",
        "createdAt" : "2020-04-24T15:41:23Z",
        "updatedAt" : "2020-04-24T15:46:31Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "2330858f-d5cb-47b5-979d-2d38c534711b",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "I agree with @peter-toth .",
        "createdAt" : "2020-04-26T22:26:54Z",
        "updatedAt" : "2020-04-26T22:26:54Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +62,66 @@            }\n        }.toSet ++ namesInSubqueries\n        assertNoNameConflictsInCTE(child, outerCTERelationNames, newNames)\n        w.innerChildren.foreach(assertNoNameConflictsInCTE(_, newNames, newNames))\n"
  },
  {
    "id" : "a55b76ef-0f95-4d30-b944-33327d9862d5",
    "prId" : 27454,
    "prUrl" : "https://github.com/apache/spark/pull/27454#pullrequestreview-354362276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5da00376-b437-40e3-9cae-687a7ef66087",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "nit:\r\n```\r\nif (isLegacy.isEmpty) {\r\n  assertNoNameConflictsInCTE(...)\r\n  traverseAndSubstituteCTE\r\n} else if ...\r\n\r\n```",
        "createdAt" : "2020-02-06T07:02:13Z",
        "updatedAt" : "2020-02-08T01:42:45Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "1f095ce5-4a5d-43be-81c1-28ae07918389",
        "parentId" : "5da00376-b437-40e3-9cae-687a7ef66087",
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "Thanks, done in c03920a.",
        "createdAt" : "2020-02-06T10:57:03Z",
        "updatedAt" : "2020-02-08T01:42:45Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebd337b9250b9a1426232fe16d5eda92e16b23c8",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +31,35 @@  def apply(plan: LogicalPlan): LogicalPlan = {\n    val isLegacy = SQLConf.get.getConf(LEGACY_CTE_PRECEDENCE_ENABLED)\n    if (isLegacy.isEmpty) {\n      assertNoNameConflictsInCTE(plan, inTraverse = false)\n      traverseAndSubstituteCTE(plan, inTraverse = false)"
  },
  {
    "id" : "ac3b0d78-d261-4968-a895-36e74acd3277",
    "prId" : 25029,
    "prUrl" : "https://github.com/apache/spark/pull/25029#pullrequestreview-258960768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "216c864f-73b3-4312-853a-629dfce764ed",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "It seems this line has an issue about type inferences... could you check again?",
        "createdAt" : "2019-07-07T03:28:57Z",
        "updatedAt" : "2019-07-12T10:14:11Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "2eecde28-8821-4174-85cf-4f36ec60d0e3",
        "parentId" : "216c864f-73b3-4312-853a-629dfce764ed",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "This is a bit strange, because it compiles, but my InteliJ also complains about it. If I force `val traversedChild: LogicalPlan` the issue disappears.",
        "createdAt" : "2019-07-08T14:56:15Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d9d96f6f6e6e41eb6d25d03e4dc9a9fd93728ad",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +109,113 @@            // multiple times we use a lazy construct with call-by-name parameter passing.\n            lazy val substitutedCTEPlan = traverseAndSubstituteCTE(ctePlan, true)\n            substituteCTE(currentPlan, cteName, substitutedCTEPlan)\n        }\n"
  },
  {
    "id" : "09bce4ec-8b9a-4f96-8a31-b3cd63f8be60",
    "prId" : 25029,
    "prUrl" : "https://github.com/apache/spark/pull/25029#pullrequestreview-260500844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "we need this lazy? It seems all the tests below passes without this lazy...",
        "createdAt" : "2019-07-07T03:46:21Z",
        "updatedAt" : "2019-07-12T10:14:11Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "d67f6065-3119-492b-98db-18685bb13e58",
        "parentId" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "lazy is just a minor optimization here to make sure that `traverseAndSubstituteCTE(ctePlan, true)` runs only once even if `substituteCTE(...)` encounters `cteName` multiple times.",
        "createdAt" : "2019-07-08T14:20:32Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "c3e6593a-8759-45e6-94bb-3ccdd5327b3a",
        "parentId" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "We cannot do like this?\r\n```\r\n  private def substituteCTE(\r\n      plan: LogicalPlan,\r\n      cteName: String,\r\n      ctePlan: LogicalPlan)\r\n```\r\nAnyway, I feel it is hard to read around here... ",
        "createdAt" : "2019-07-11T01:28:20Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "46042b66-6a51-4354-a824-3261af547a09",
        "parentId" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "Unfortunately, if I remove call by name parameter passing from `substituteCTE` then `lazy val substitutedCTEPlan` will be evaluated before calling `substituteCTE` with it.\r\nI think both call by name passing of `ctePlan` and `lazy val substitutedCTEPlan` is required to make sure that:\r\n- if `cteName` is never used then `traverseAndSubstituteCTE(ctePlan, true)` shouldn't run\r\n- if `cteName` is used one or more times then `traverseAndSubstituteCTE(ctePlan, true)` should run only once\r\n\r\nI added some comments to `traverseAndSubstituteCTE` to explain the logic there. ",
        "createdAt" : "2019-07-11T06:35:04Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "711b6dd2-7585-437d-a4e2-4f3194058544",
        "parentId" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Which test does fail if we remove the call-by-name parameter?",
        "createdAt" : "2019-07-11T06:47:18Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "73e9c49b-10c0-4d9e-964d-d74ae2960abe",
        "parentId" : "0cb7d925-c859-4cac-b8f5-c87e13646226",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "None of the tests fail actually, but both lazy and call-by-name are part of the optimization.",
        "createdAt" : "2019-07-11T06:59:23Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d9d96f6f6e6e41eb6d25d03e4dc9a9fd93728ad",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +108,112 @@            // computation if it is not used and to avoid multiple recomputation if it is used\n            // multiple times we use a lazy construct with call-by-name parameter passing.\n            lazy val substitutedCTEPlan = traverseAndSubstituteCTE(ctePlan, true)\n            substituteCTE(currentPlan, cteName, substitutedCTEPlan)\n        }"
  },
  {
    "id" : "7f5c560d-5036-4b74-9c83-852d0b307cc7",
    "prId" : 25029,
    "prUrl" : "https://github.com/apache/spark/pull/25029#pullrequestreview-260503023",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8aab241b-8202-425a-94e1-aa3220a5e301",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Why we need `inTraverse`? Some tests fail without this flag?",
        "createdAt" : "2019-07-07T04:35:10Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "b326d011-14e7-4501-b372-54565f7c7bc4",
        "parentId" : "8aab241b-8202-425a-94e1-aa3220a5e301",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "This is another minor optimization here so it is not necessary. In this example query:\r\n```\r\nSELECT (\r\n  WITH t AS (SELECT 1)\r\n  SELECT * FROM t\r\n)\r\n```\r\nwhen `traverseAndSubstituteCTE` is called for the outer SELECT query with `inTraverse = false`, `inTraverse` helps to avoid eager CTE substitution in the subquery expression (`CTESubstitution` will be executed on the subquery a bit later anyway.)\r\n\r\n",
        "createdAt" : "2019-07-08T15:10:28Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "79a552a0-8e7e-4e0a-b293-d9202aaf35bf",
        "parentId" : "8aab241b-8202-425a-94e1-aa3220a5e301",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "aha, ok. could you leave a comment here, too?",
        "createdAt" : "2019-07-11T06:49:01Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "5b9947bd-e9be-45b9-9afd-68c4546f5aba",
        "parentId" : "8aab241b-8202-425a-94e1-aa3220a5e301",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "sure, I've added it",
        "createdAt" : "2019-07-11T07:05:17Z",
        "updatedAt" : "2019-07-12T10:14:12Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d9d96f6f6e6e41eb6d25d03e4dc9a9fd93728ad",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +114,118 @@      // CTE name collision can occur only when inTraverse is true, it helps to avoid eager CTE\n      // substitution in a subquery expression.\n      case other if inTraverse =>\n        other.transformExpressions {\n          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))"
  },
  {
    "id" : "3abd8af1-6d66-4fe3-8c0e-3a1b74d9d84f",
    "prId" : 25029,
    "prUrl" : "https://github.com/apache/spark/pull/25029#pullrequestreview-399388859",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9f6a3db-3351-4de0-a6c4-d845df385c31",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "The subquery expression seems not correctly handled.\r\n\r\n`with t1 as (select 1 i) select * from t1 where i in (with t1 as (select 2 i) select * from t1)` returns 1 in Spark, but empty row in pgsql.",
        "createdAt" : "2020-04-23T13:09:02Z",
        "updatedAt" : "2020-04-23T13:09:02Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "5da2eb60-979f-4abd-99fd-579b76c012e4",
        "parentId" : "e9f6a3db-3351-4de0-a6c4-d845df385c31",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "Yes, it probably should be `transformAllExpressions`. Will look into it soon...",
        "createdAt" : "2020-04-23T13:43:05Z",
        "updatedAt" : "2020-04-23T13:43:05Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "4d89e8e1-8014-45e0-a9c7-41433392f65c",
        "parentId" : "e9f6a3db-3351-4de0-a6c4-d845df385c31",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Oh. Thanks, @cloud-fan .",
        "createdAt" : "2020-04-23T17:10:58Z",
        "updatedAt" : "2020-04-23T17:10:58Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "7bf62362-361b-4aaa-ad98-e333befc0922",
        "parentId" : "e9f6a3db-3351-4de0-a6c4-d845df385c31",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I've opened https://github.com/apache/spark/pull/28318 to fix it.",
        "createdAt" : "2020-04-23T18:58:21Z",
        "updatedAt" : "2020-04-23T18:58:22Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d9d96f6f6e6e41eb6d25d03e4dc9a9fd93728ad",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@        // in child first\n        val traversedChild: LogicalPlan = child transformExpressions {\n          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n        }\n"
  }
]