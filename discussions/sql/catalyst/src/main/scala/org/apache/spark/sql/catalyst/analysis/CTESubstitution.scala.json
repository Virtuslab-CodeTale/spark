[
  {
    "id" : "7b064783-0c22-42de-ac61-59add1eea324",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-727631385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e378dbb2-e018-4bff-a2e6-cc88357b4f4f",
        "parentId" : null,
        "authorId" : "8c82da5a-f351-4a37-a8a9-13809311b07b",
        "body" : "`plan.collectFirst` would be quicker and less memory-hungry, wouldn't it?",
        "createdAt" : "2021-08-11T14:42:24Z",
        "updatedAt" : "2021-08-11T14:46:43Z",
        "lastEditedBy" : "8c82da5a-f351-4a37-a8a9-13809311b07b",
        "tags" : [
        ]
      },
      {
        "id" : "06615c77-e8a1-41de-b5a8-ff09722e3baf",
        "parentId" : "e378dbb2-e018-4bff-a2e6-cc88357b4f4f",
        "authorId" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "body" : "Maybe I'm missing sth, but I don't see how so.",
        "createdAt" : "2021-08-11T15:26:07Z",
        "updatedAt" : "2021-08-11T15:26:07Z",
        "lastEditedBy" : "4916859c-0e27-4e9d-ac39-ad95bc1382d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +49,53 @@object CTESubstitution extends Rule[LogicalPlan] {\n  def apply(plan: LogicalPlan): LogicalPlan = {\n    val isCommand = plan.find {\n      case _: Command | _: ParsedStatement | _: InsertIntoDir => true\n      case _ => false"
  },
  {
    "id" : "524d8d14-b2ed-4753-be8c-a70225210d68",
    "prId" : 33671,
    "prUrl" : "https://github.com/apache/spark/pull/33671#pullrequestreview-731817751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "107615de-c197-46f2-be00-2f7a8ac2ad53",
        "parentId" : null,
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "As the return value of `traverseAndSubstituteCTE` changed a bit, this docs could use some update.",
        "createdAt" : "2021-08-17T14:09:24Z",
        "updatedAt" : "2021-08-17T14:09:24Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cc52f74ab8a12599b74ae163e8f4065a99e359d",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +168,172 @@   *   )\n   * @param plan the plan to be traversed\n   * @return the plan where CTE substitution is applied\n   */\n  private def traverseAndSubstituteCTE("
  },
  {
    "id" : "a1792865-0bd5-4f25-bd40-cb82c45ae91f",
    "prId" : 28407,
    "prUrl" : "https://github.com/apache/spark/pull/28407#pullrequestreview-403359701",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "parentId" : null,
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan Just trying to understand. innerCTEResolved indicates a already resolved CTE or the one we are going to resolve in the subsequent call to substituteCTE ?",
        "createdAt" : "2020-04-30T07:29:45Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      },
      {
        "id" : "a2e60535-8431-4e7a-94d7-b881cce8d889",
        "parentId" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "\"resolved\" here means the `With` is resolved inside this relation. The relation needs further processing to substitute `UnresolvedRelation` with the previous CTE relations.\r\n\r\nThe naming is not very accurate when `legacy = true`, but this probably doesn't matter.",
        "createdAt" : "2020-04-30T09:09:37Z",
        "updatedAt" : "2020-04-30T12:09:57Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "f7bb0a0f-fedb-4965-bd00-29492b7d8b0a",
        "parentId" : "9f38d08f-d71a-4d88-8a9a-e8e4a07d1a94",
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan OK. sounds good.",
        "createdAt" : "2020-04-30T09:38:46Z",
        "updatedAt" : "2020-04-30T09:38:46Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      }
    ],
    "commit" : "b022e3513a842329b24569840a07a501bed9a188",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +152,156 @@    val resolvedCTERelations = new mutable.ArrayBuffer[(String, LogicalPlan)](relations.size)\n    for ((name, relation) <- relations) {\n      val innerCTEResolved = if (isLegacy) {\n        // In legacy mode, outer CTE relations take precedence. Here we don't resolve the inner\n        // `With` nodes, later we will substitute `UnresolvedRelation`s with outer CTE relations."
  },
  {
    "id" : "11f0251c-006c-49f4-97dd-512ae42cfec2",
    "prId" : 28407,
    "prUrl" : "https://github.com/apache/spark/pull/28407#pullrequestreview-403323467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32cf7bb3-10c6-4fbb-95f4-4629f0ca5863",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "For legacy case, `innerCTEResolved` might contain an inner `WITH`, but seems `substituteCTE` doesn't remove `WITH`.\r\n\r\nThen in later `substituteCTE`s, will we result some untouched `WITH`s in the final query plan ?\r\n\r\n\r\n\r\n\r\n\r\n",
        "createdAt" : "2020-04-30T07:57:27Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "3786d1a6-c744-4d8d-bd01-48f6d5c5aeb9",
        "parentId" : "32cf7bb3-10c6-4fbb-95f4-4629f0ca5863",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "The rule `CTESubstitution` runs in a batch many times (https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala#L208-L212) so those `With`s will be removed in the end because we substitute `child` here: https://github.com/apache/spark/pull/28407/files#diff-d0bfa3367c63988ad7cf33397e643e75R91",
        "createdAt" : "2020-04-30T08:49:33Z",
        "updatedAt" : "2020-04-30T09:20:01Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b022e3513a842329b24569840a07a501bed9a188",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +163,167 @@      }\n      // CTE definition can reference a previous one\n      resolvedCTERelations += (name -> substituteCTE(innerCTEResolved, resolvedCTERelations))\n    }\n    resolvedCTERelations"
  },
  {
    "id" : "144290ef-98e8-4998-bb17-bba7fa83aaf2",
    "prId" : 28371,
    "prUrl" : "https://github.com/apache/spark/pull/28371#pullrequestreview-401106704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95b29554-9717-474b-afb9-8959b6169bef",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "My bad. I missed to check case-sensitivity.",
        "createdAt" : "2020-04-27T16:10:38Z",
        "updatedAt" : "2020-04-27T16:19:50Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "24a487dce69a0bc55148164d650259268b45dc4f",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +65,69 @@        relations.foreach {\n          case (name, relation) =>\n            if (startOfQuery && outerCTERelationNames.exists(resolver(_, name))) {\n              throw new AnalysisException(s\"Name $name is ambiguous in nested CTE. \" +\n                s\"Please set ${LEGACY_CTE_PRECEDENCE_POLICY.key} to CORRECTED so that name \" +"
  },
  {
    "id" : "72d396e1-034f-4bbc-b5ac-406a1682ccb5",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-399905076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9ba50e7-0308-446a-bc1b-e0e412406bd5",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto",
        "createdAt" : "2020-04-24T12:34:27Z",
        "updatedAt" : "2020-04-24T13:26:35Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +63,67 @@        }.toSet ++ namesInSubqueries\n        assertNoNameConflictsInCTE(child, outerCTERelationNames, newNames)\n        w.innerChildren.foreach(assertNoNameConflictsInCTE(_, newNames, newNames))\n\n      case other =>"
  },
  {
    "id" : "48ffe4fb-2f8c-4bc0-82bd-f7f8d47ef03f",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-399965592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b4ea4aa-98f3-4678-ab2c-09777af0fe2b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shouldn't this be `assertNoNameConflictsInCTE(_, namesInSubqueries, Nil)`?",
        "createdAt" : "2020-04-24T13:35:44Z",
        "updatedAt" : "2020-04-24T13:35:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "c17e6aba-3a64-423f-b36e-69342246f542",
        "parentId" : "7b4ea4aa-98f3-4678-ab2c-09777af0fe2b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "In that case we wouldn't report\r\n```\r\nWITH t AS (SELECT 1)\r\nSELECT (\r\n  SELECT (\r\n    WITH t AS (SELECT 2)\r\n    SELECT * FROM t\r\n  )\r\n)\r\n```\r\nas ambiguous, but it returns `1` in legacy and `2` in corrected modes. ",
        "createdAt" : "2020-04-24T13:52:24Z",
        "updatedAt" : "2020-04-24T13:52:25Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +67,71 @@      case other =>\n        other.subqueries.foreach(\n          assertNoNameConflictsInCTE(_, namesInSubqueries, namesInSubqueries))\n        other.children.foreach(\n          assertNoNameConflictsInCTE(_, outerCTERelationNames, namesInSubqueries))"
  },
  {
    "id" : "ebf82aeb-62ab-4bde-9c85-f711ed6f1fb3",
    "prId" : 28318,
    "prUrl" : "https://github.com/apache/spark/pull/28318#pullrequestreview-400556142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "There are 3 kinds of conflicts:\r\n1. conflicts in the children, e.g. `with t as (...) select * from (with t as (...) select * from t)`\r\n2. conflicts in other CTE relations, e.g. `with t as (...), t2 as (with t as (...) select * from t) ...`\r\n3. conflicts in the subqueries of the children, e.g. `with t as (...) select ... where ... in (with t as (...) select * from t)`\r\n\r\nThe third one can be handled correctly by 2.4 as well, so we shouldn't fail.\r\n\r\nCan you briefly explain how you check the first 2 conflicts and skip the third one?",
        "createdAt" : "2020-04-24T14:18:42Z",
        "updatedAt" : "2020-04-24T14:18:42Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "4d4815c3-b88b-4c9d-b235-06cd2ae9d318",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I thought 3. is not handled correctly in 2.4. (I haven't tested it on Spark 2.4.) But it certainly produces different results in Spark 3 in the 2 different modes.\r\n- In legacy it returns `1` (https://github.com/apache/spark/pull/28318/files#diff-46573f0caf504536cf46d2b267bb5a37R171-R181). This PR hasn't touched this mode, but if you are right then it should.\r\n- In corrected it returns empty result after this PR (before the PR it returned `1`)(https://github.com/apache/spark/pull/28318/files#diff-0c15df52c8221453db6102ff4196cb90R171-R181).",
        "createdAt" : "2020-04-24T14:33:57Z",
        "updatedAt" : "2020-04-24T14:33:57Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "ea13cec1-7087-4abc-9544-336f8dd8ab6c",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I checked 3. in Spark 2.4 with the query in the description and it returns `1` so is not handled correctly and we should fail.\r\n\r\n1. In this case the legacy and corrected mode returns the same result due to the same substitution order so we shouldn't throw an exception. If we call the possible conflicting set of names coming from outer CTEs as `outerCTERelationNames` then I handle this case by not extending the set with new names when I traverse down the child of a `With` (https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R64) or when I traverse down the children of any other node (https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R70-R71).\r\n\r\n2. and 3. In these cases, the two modes have different substitution order and so possibly different results. Obviously we need an extended set of names (`newNames`) when we encounter a `With` and switch to that set (pass in as a new `outerCTERelationNames`) when we traverse down inner children (2.)( https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R65) or traverse down subquery expressions (3.)(https://github.com/apache/spark/pull/28318/files#diff-d0bfa3367c63988ad7cf33397e643e75R68-R69)\r\n\r\nSo what is the contents of `outerCTERelationNames`? The set of CTE names coming from outer CTEs. It doesn't contain the CTEs coming from a parent `With` from the same `LogicalPlan` (1.). But it contains outer CTEs coming from `With`s from outer `LogicalPlan`s (2., 3.)\r\nAnd the content of `namesInSubqueries` is simply all CTE names from all outer `With`s, no matter if the `With` is the same plan or in an outer plan.\r\n\r\nSo I think what we need to do here is basically skip the 1. and check 2. and 3.",
        "createdAt" : "2020-04-24T15:41:23Z",
        "updatedAt" : "2020-04-24T15:46:31Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "2330858f-d5cb-47b5-979d-2d38c534711b",
        "parentId" : "9aafcc67-242a-438c-9c43-92889c44fa9b",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "I agree with @peter-toth .",
        "createdAt" : "2020-04-26T22:26:54Z",
        "updatedAt" : "2020-04-26T22:26:54Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a3ebf746cc7efa2c7356c79a400b7bd04952764",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +62,66 @@            }\n        }.toSet ++ namesInSubqueries\n        assertNoNameConflictsInCTE(child, outerCTERelationNames, newNames)\n        w.innerChildren.foreach(assertNoNameConflictsInCTE(_, newNames, newNames))\n"
  },
  {
    "id" : "a55b76ef-0f95-4d30-b944-33327d9862d5",
    "prId" : 27454,
    "prUrl" : "https://github.com/apache/spark/pull/27454#pullrequestreview-354362276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5da00376-b437-40e3-9cae-687a7ef66087",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "nit:\r\n```\r\nif (isLegacy.isEmpty) {\r\n  assertNoNameConflictsInCTE(...)\r\n  traverseAndSubstituteCTE\r\n} else if ...\r\n\r\n```",
        "createdAt" : "2020-02-06T07:02:13Z",
        "updatedAt" : "2020-02-08T01:42:45Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "1f095ce5-4a5d-43be-81c1-28ae07918389",
        "parentId" : "5da00376-b437-40e3-9cae-687a7ef66087",
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "Thanks, done in c03920a.",
        "createdAt" : "2020-02-06T10:57:03Z",
        "updatedAt" : "2020-02-08T01:42:45Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebd337b9250b9a1426232fe16d5eda92e16b23c8",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +31,35 @@  def apply(plan: LogicalPlan): LogicalPlan = {\n    val isLegacy = SQLConf.get.getConf(LEGACY_CTE_PRECEDENCE_ENABLED)\n    if (isLegacy.isEmpty) {\n      assertNoNameConflictsInCTE(plan, inTraverse = false)\n      traverseAndSubstituteCTE(plan, inTraverse = false)"
  }
]