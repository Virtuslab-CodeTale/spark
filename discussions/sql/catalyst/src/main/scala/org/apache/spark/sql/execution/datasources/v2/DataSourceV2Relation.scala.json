[
  {
    "id" : "4403646e-1fe3-4502-9fdf-cfe2dba29f04",
    "prId" : 26957,
    "prUrl" : "https://github.com/apache/spark/pull/26957#pullrequestreview-335040353",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "549705f8-2320-467a-9f36-ccd7f1d81ae2",
        "parentId" : null,
        "authorId" : "471c3dfe-259c-447a-9abd-f7fdecccd9a7",
        "body" : "You probably want the catalog identifier here too, not the plugin",
        "createdAt" : "2019-12-20T02:24:24Z",
        "updatedAt" : "2020-01-24T17:49:38Z",
        "lastEditedBy" : "471c3dfe-259c-447a-9abd-f7fdecccd9a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "df29683d38260cb7f69adfccdc7fab2d315e663e",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +42,46 @@    table: Table,\n    output: Seq[AttributeReference],\n    catalog: Option[CatalogPlugin],\n    identifier: Option[Identifier],\n    options: CaseInsensitiveStringMap)"
  },
  {
    "id" : "56c4f8b6-3ff2-4a6b-83bb-40e704f95934",
    "prId" : 25955,
    "prUrl" : "https://github.com/apache/spark/pull/25955#pullrequestreview-303695632",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e370c971-d786-43c7-b31a-e062c6738ad9",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "It seems to me that the maintenance cost is high if we have 2 nodes for ds v2 relation. Whenever we need to pattern match the v2 relation node, we need to take care of the 2 nodes both.\r\n\r\nHow about\r\n```\r\ncase class DataSourceV2Relation(\r\n    table: Table,\r\n    output: Seq[AttributeReference],\r\n    options: CaseInsensitiveStringMap,\r\n    createdScan: Option[Scan])\r\n\r\ndef getScan() = {\r\n  if (isTest) {\r\n    assert(createdScan.isDefined)\r\n    createdScan.get\r\n  } else {\r\n    createdScan.getOrElse ...\r\n  }\r\n}\r\n```",
        "createdAt" : "2019-10-07T06:56:26Z",
        "updatedAt" : "2019-10-30T18:21:04Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8be4307c-ce33-4ec5-bfae-469e07e63833",
        "parentId" : "e370c971-d786-43c7-b31a-e062c6738ad9",
        "authorId" : "0fc9f1bc-0097-451e-915f-52da69a366f3",
        "body" : "This should be a separate node to avoid correctness problems. Otherwise, it is easy to accidentally write rules that match both `DataSourceV2Relation` and `DataSourceV2ScanRelation` but does not handle the case where operators have already been pushed.\r\n\r\nWhen a filter is pushed down, it is also removed from the filters on top of the scan. If push-down happens a second time because rules match the same node, then it is easy for a mistake to ignore the original pushed filter and create a second independent scan. That's a correctness bug that is easy to introduce by accident.\r\n\r\nUsing a separate relation type requires rules to choose whether to support a relation after push-down, or just a relation before push-down. The trade-off is that some places need to match both, but those cases are few and worth the trade.",
        "createdAt" : "2019-10-10T21:42:07Z",
        "updatedAt" : "2019-10-30T18:21:04Z",
        "lastEditedBy" : "0fc9f1bc-0097-451e-915f-52da69a366f3",
        "tags" : [
        ]
      },
      {
        "id" : "b2e60512-069e-48c3-a1ee-1415cb989046",
        "parentId" : "e370c971-d786-43c7-b31a-e062c6738ad9",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Makes sense. But it's still better to reduce the maintenance cost a bit. How about we clearly define the life cycle of a v2 relation as: `UnresolvedRelation` (before analysis) -> `DataSourceV2Relation` (after analysis) -> `DataSourceV2ScanRelation` (after optimization) -> the physical scan node.\r\n\r\nThen we only need to match one node:\r\n1. if dealing with `analyzedPlan`, match `DataSourceV2Relation`\r\n2. if dealing with `optimizedPlan`, match `DataSourceV2ScanRelation`",
        "createdAt" : "2019-10-11T12:20:18Z",
        "updatedAt" : "2019-10-30T18:21:04Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "968a9687-bf68-436f-b704-853febce4003",
        "parentId" : "e370c971-d786-43c7-b31a-e062c6738ad9",
        "authorId" : "0fc9f1bc-0097-451e-915f-52da69a366f3",
        "body" : "I did this to simplify the code. Now places that use `optimizedPlan` expect the scan relation.\r\n\r\nThere was one minor problem with this. To address the concern about relations used by DDL commands like `AlterTable` getting modified, those plans no longer list the relation as a child, so rules are not automatically run on it. For those DDL commands, `DataSourceV2Relation` is still in the optimized plan because it is no longer converted. I think this is correct behavior.",
        "createdAt" : "2019-10-17T23:44:01Z",
        "updatedAt" : "2019-10-30T18:21:04Z",
        "lastEditedBy" : "0fc9f1bc-0097-451e-915f-52da69a366f3",
        "tags" : [
        ]
      },
      {
        "id" : "d2714c1f-9236-4153-87eb-7ba37225ca07",
        "parentId" : "e370c971-d786-43c7-b31a-e062c6738ad9",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I think this is fine. DDL commands don't list the relation as a child, and only the corresponding planner rule need to match the `DataSourceV2Relation`.",
        "createdAt" : "2019-10-18T06:57:50Z",
        "updatedAt" : "2019-10-30T18:21:04Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "c223e0537796c1e0a52bc5a655660f89ab539192",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +87,91 @@ * @param output the output attributes of this relation\n */\ncase class DataSourceV2ScanRelation(\n    table: Table,\n    scan: Scan,"
  }
]