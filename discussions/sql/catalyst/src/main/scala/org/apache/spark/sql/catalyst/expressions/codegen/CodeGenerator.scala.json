[
  {
    "id" : "721522b7-f692-40b1-9202-e731f81852c9",
    "prId" : 33082,
    "prUrl" : "https://github.com/apache/spark/pull/33082#pullrequestreview-693355074",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d4fa73f-a4cc-4b81-bbcc-4e29ecda093b",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Oh, some `SubExprEliminationState` contains not `VariableValue` but still some statements that includes other expressions?",
        "createdAt" : "2021-06-26T15:58:06Z",
        "updatedAt" : "2021-06-26T15:58:06Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "fefae5b8-ef5d-457e-86f4-19e6a8c5b875",
        "parentId" : "3d4fa73f-a4cc-4b81-bbcc-4e29ecda093b",
        "authorId" : "594db420-88ec-4875-8cd3-0d8b0bec131c",
        "body" : "> Oh, some `SubExprEliminationState` contains not `VariableValue` but still some statements that includes other expressions?\r\n\r\nYes, the expression contains input var  may match `SubExprEliminationState` and just skiped.",
        "createdAt" : "2021-06-26T16:22:45Z",
        "updatedAt" : "2021-06-26T16:22:45Z",
        "lastEditedBy" : "594db420-88ec-4875-8cd3-0d8b0bec131c",
        "tags" : [
        ]
      },
      {
        "id" : "cf3acf02-42d3-4d4c-ba3f-06d928eef6fe",
        "parentId" : "3d4fa73f-a4cc-4b81-bbcc-4e29ecda093b",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Hmm, after second look, it looks not root cause. A subexpr should be evaluated before using it. \r\n\r\nSo technically all its children expressions are not needed.\r\n\r\nI found the root cause. `PromotePrecision` overwrites `Expression.genCode` where is subexpression replace happens. So `PromotePrecision` skips subexpression elimination. I will submit another PR and include your test as co-author there. Thanks.",
        "createdAt" : "2021-06-26T20:39:08Z",
        "updatedAt" : "2021-06-26T20:39:55Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a90927831a07b6d77c118d4575d1f2c96bd6089",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1780,1784 @@          val SubExprEliminationState(isNull, value) = subExprs(e)\n          collectLocalVariable(value, e)\n          collectLocalVariable(isNull, e)\n\n        case ref: BoundReference if ctx.currentVars != null &&"
  },
  {
    "id" : "958e51f1-8942-41ef-ba64-648452aacb06",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-688685850",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f03fa64a-e694-4189-ae53-4ca4361a08de",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Now this looks very similar to `ExprCode` with children tracked...",
        "createdAt" : "2021-06-21T17:13:01Z",
        "updatedAt" : "2021-06-21T17:13:01Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "b000798e-8473-4ab3-b6a7-6d18640ef060",
        "parentId" : "f03fa64a-e694-4189-ae53-4ca4361a08de",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Yea, maybe eliminate this and reuse `ExprCode`?",
        "createdAt" : "2021-06-21T17:16:41Z",
        "updatedAt" : "2021-06-21T17:16:41Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +84,88 @@ *                 to make sure we evaluate all children subexpressions too.\n */\ncase class SubExprEliminationState(\n  eval: ExprCode,\n  children: Seq[SubExprEliminationState])"
  },
  {
    "id" : "5e2e9a48-76f4-49d9-af64-a589af8354bc",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-688697308",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46ebaf9d-3d95-4108-a59c-b1438acd079a",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "We may need to improve the method doc of `subexpressionEliminationForWholeStageCodegen`. I can hardly understand this method now...",
        "createdAt" : "2021-06-21T17:28:51Z",
        "updatedAt" : "2021-06-21T17:28:51Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "3fc0791a-7575-4189-a153-e0cb8996b75d",
        "parentId" : "46ebaf9d-3d95-4108-a59c-b1438acd079a",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Okay, I noticed it grows a bit longer. Let me add more comments.",
        "createdAt" : "2021-06-21T17:30:09Z",
        "updatedAt" : "2021-06-21T17:30:10Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 196,
    "diffHunk" : "@@ -1,1 +1205,1209 @@    }\n    SubExprCodes(subExprsMap.toMap, exprCodes.flatten)\n  }\n\n  /**"
  },
  {
    "id" : "b51bdddd-5b36-492f-98f8-bebd1e0486c9",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-689861286",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3551f601-cc77-4496-b3d3-fda90de4fee6",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Your previous PR improves `EquivalentExpressions` to always return child subexpression first. It seems that PR is not useful after this PR because we track the children explicitly?",
        "createdAt" : "2021-06-22T09:30:44Z",
        "updatedAt" : "2021-06-22T09:30:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "fb9b7276-158e-4ddb-bb52-5823ca466e0a",
        "parentId" : "3551f601-cc77-4496-b3d3-fda90de4fee6",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Not exactly. We need to return child subexpressions first. So we can make sure child subexpression is codegen-ed and put into the map before parent subexpression. When we want to codegen parent subexpression, it can look up the child subexpression and put it as child of the parent.\r\n\r\n\r\n",
        "createdAt" : "2021-06-22T16:35:18Z",
        "updatedAt" : "2021-06-22T16:35:19Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "130dbd51-9d8c-40be-b6e1-e31562d756ba",
        "parentId" : "3551f601-cc77-4496-b3d3-fda90de4fee6",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Actually I have a new idea for how to codegen subexpression following child-parent orders without sorting. It is more reliable than the sorting approach. I will open another PR for that.",
        "createdAt" : "2021-06-22T18:21:41Z",
        "updatedAt" : "2021-06-22T23:12:31Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +82,86 @@ *                 subexpressions first. This is used if we want to selectively evaluate\n *                 particular subexpressions, instead of all at once. In the case, we need\n *                 to make sure we evaluate all children subexpressions too.\n */\ncase class SubExprEliminationState("
  },
  {
    "id" : "2567e992-7193-4923-87f6-1f3487519e78",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-693500198",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bef9d59-82ba-43df-b0c8-760927a79ef6",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "nit: `Iterable` -> `Seq`?",
        "createdAt" : "2021-06-28T00:29:37Z",
        "updatedAt" : "2021-06-28T00:44:30Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "a176cca2-116a-432f-89d3-526e36bdcf71",
        "parentId" : "5bef9d59-82ba-43df-b0c8-760927a79ef6",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "All its caller side use `Iterable`. If changing to `Seq` here, all callers need to add `.toSeq`.",
        "createdAt" : "2021-06-28T02:35:05Z",
        "updatedAt" : "2021-06-28T02:35:05Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +1049,1053 @@   * evaluation.\n   */\n  def evaluateSubExprEliminationState(subExprStates: Iterable[SubExprEliminationState]): String = {\n    val code = new StringBuilder()\n"
  },
  {
    "id" : "197f3ef6-01b0-426f-a900-dabbb2e4ac10",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-694337450",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa6f1e59-5c4d-43e8-8ea7-f8ea0934d3a3",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Q: Is it difficult to add some tests for this new behaviour?",
        "createdAt" : "2021-06-28T00:43:58Z",
        "updatedAt" : "2021-06-28T00:44:30Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "9896cdbc-686e-4324-a26f-e51118757479",
        "parentId" : "aa6f1e59-5c4d-43e8-8ea7-f8ea0934d3a3",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Let me add a few tests.",
        "createdAt" : "2021-06-28T02:47:57Z",
        "updatedAt" : "2021-06-28T02:47:57Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "515217b5-862e-4f08-8bf3-50303ca41e86",
        "parentId" : "aa6f1e59-5c4d-43e8-8ea7-f8ea0934d3a3",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Added new test.",
        "createdAt" : "2021-06-28T19:52:21Z",
        "updatedAt" : "2021-06-28T19:52:21Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +1117,1121 @@          exprs.head.foreach {\n            case e if subExprEliminationExprs.contains(e) =>\n              childrenSubExprs += subExprEliminationExprs(e)\n            case _ =>\n          }"
  },
  {
    "id" : "4e4a496b-757a-4dc8-a389-587ba0fa0426",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-695353867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccdd27dd-ffd8-4b42-b956-b7fbfabdceeb",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "We need to add some comments to explain the assumption: this code works because `EquivalentExpressions` returns child expressions first.",
        "createdAt" : "2021-06-29T14:41:10Z",
        "updatedAt" : "2021-06-29T14:41:10Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7d3d6fc3-8ec8-4acf-87ff-3a1f0a0bdaaa",
        "parentId" : "ccdd27dd-ffd8-4b42-b956-b7fbfabdceeb",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "BTW collecting child expressions here looks really inefficient, but I don't have a better idea for now ...",
        "createdAt" : "2021-06-29T14:42:49Z",
        "updatedAt" : "2021-06-29T14:42:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "3bb987a6-e5e9-43b1-9c9e-ea96d684a38e",
        "parentId" : "ccdd27dd-ffd8-4b42-b956-b7fbfabdceeb",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I see. This is not general expression but special (subexpr) ones, so we don't do collecting child expressions in general but in limited range. Except that if you have many subexpr and they are highly nested.",
        "createdAt" : "2021-06-29T15:44:43Z",
        "updatedAt" : "2021-06-29T15:44:43Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "6648232a-1fab-45bd-b167-0d31977e755a",
        "parentId" : "ccdd27dd-ffd8-4b42-b956-b7fbfabdceeb",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "> We need to add some comments to explain the assumption: this code works because EquivalentExpressions returns child expressions first.\r\n\r\nAs I commented before, I plan to remove the sorting. A better idea is to add `SubExprEliminationState` first into the map (not codegen yet). Then during codegen, we can look at the map to chain children.\r\n",
        "createdAt" : "2021-06-29T18:10:49Z",
        "updatedAt" : "2021-06-29T18:10:49Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +1116,1120 @@          val childrenSubExprs = mutable.ArrayBuffer.empty[SubExprEliminationState]\n          exprs.head.foreach {\n            case e if subExprEliminationExprs.contains(e) =>\n              childrenSubExprs += subExprEliminationExprs(e)\n            case _ =>"
  },
  {
    "id" : "607f7ac9-a230-4c32-9e1c-26b7178e54b5",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-695206786",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a18850e6-d3b2-4b4a-bc21-6d4a236b83d0",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Not related to this PR: so here we repeat the logic of generating `SubExprEliminationState`s with splitting the code? `nonSplitCode` is totally wasted?",
        "createdAt" : "2021-06-29T14:49:04Z",
        "updatedAt" : "2021-06-29T14:49:04Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7c7c40dc-6d77-443b-aa2c-4507a203e756",
        "parentId" : "a18850e6-d3b2-4b4a-bc21-6d4a236b83d0",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Previously it is lazy so we can do non-split conditionally. Now we nestedly generate subExprs so it cannot be lazy now. `SubExprEliminationStates` are needed to nestedly generate code for them.",
        "createdAt" : "2021-06-29T15:42:47Z",
        "updatedAt" : "2021-06-29T15:42:47Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +1139,1143 @@\n    val needSplit = nonSplitCode.map(_.eval.code.length).sum > SQLConf.get.methodSplitThreshold\n    val (subExprsMap, exprCodes) = if (needSplit) {\n      if (inputVarsForAllFuncs.map(calculateParamLengthFromExprValues).forall(isValidParamLength)) {\n        val localSubExprEliminationExprs ="
  },
  {
    "id" : "fa737e17-ed33-47ec-b35e-b22d69c2f4dc",
    "prId" : 32980,
    "prUrl" : "https://github.com/apache/spark/pull/32980#pullrequestreview-704456752",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62dced9c-151b-4ac7-a3c3-2d08fc051189",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "nit: shall we use `subexprFunctions += subExprCode` here? otherwise we are calling `addNewFunction` twice.",
        "createdAt" : "2021-07-12T18:05:18Z",
        "updatedAt" : "2021-07-12T18:05:19Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7c122d59-3a9e-49c2-b3d7-22c977190112",
        "parentId" : "62dced9c-151b-4ac7-a3c3-2d08fc051189",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Oh yes, as the functions in class is a map, it will overwrite. But yes, we should use `subExprCode`. Let me submit a followup.",
        "createdAt" : "2021-07-12T19:10:56Z",
        "updatedAt" : "2021-07-12T19:10:56Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "3ade6d53-8edb-437c-86fd-c600760da090",
        "parentId" : "62dced9c-151b-4ac7-a3c3-2d08fc051189",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "#33305",
        "createdAt" : "2021-07-12T19:14:28Z",
        "updatedAt" : "2021-07-12T19:14:28Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "014bc8b69854efd98d1458a01996a9cbf2741721",
    "line" : 204,
    "diffHunk" : "@@ -1,1 +1251,1255 @@\n      val subExprCode = s\"${addNewFunction(fnName, fn)}($INPUT_ROW);\"\n      subexprFunctions += s\"${addNewFunction(fnName, fn)}($INPUT_ROW);\"\n      val state = SubExprEliminationState(\n        ExprCode(code\"$subExprCode\","
  },
  {
    "id" : "da505aca-f799-4e6f-b902-96442a40f206",
    "prId" : 32699,
    "prUrl" : "https://github.com/apache/spark/pull/32699#pullrequestreview-672471375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f4ba443-055d-4fcb-b348-93df6c259ee0",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "what does this recursive call of `withSubExprEliminationExprs` give us?",
        "createdAt" : "2021-05-31T07:03:21Z",
        "updatedAt" : "2021-05-31T07:03:21Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "a5873dfb-6c6b-48e6-ad28-a2de661f0dd5",
        "parentId" : "4f4ba443-055d-4fcb-b348-93df6c259ee0",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "For each set of common expressions, `withSubExprEliminationExprs` only called once so I think it is not actually a recursive call?\r\n\r\n`withSubExprEliminationExprs` takes the given map used for subexpression elimination to replace common expression during expression codegen in the closure. It returns evaluated expression code (value/isNull/code).\r\n\r\nFor the two subexpressions as example:\r\n\r\n1. `simpleUDF($\"id\")`\r\n2. `functions.length(simpleUDF($\"id\"))`\r\n\r\n1st round `withSubExprEliminationExprs`:\r\n\r\nThe map is empty.\r\nGen code for `simpleUDF($\"id\")`.\r\nPut it into the map => (`simpleUDF($\"id\")` -> gen-ed code)\r\n\r\n2nd round `withSubExprEliminationExprs`:\r\n\r\nGen code for `functions.length(simpleUDF($\"id\"))`.\r\nLooking at the map and replace common expression `simpleUDF($\"id\")` as gen-ed code.\r\nPut it into the map => (`simpleUDF($\"id\")` -> gen-ed code, `functions.length(simpleUDF($\"id\"))` -> gen-ed code)\r\n\r\nThe map will be used later for subexpression elimination.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "createdAt" : "2021-05-31T17:43:29Z",
        "updatedAt" : "2021-05-31T17:43:29Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1f64f7ba0f6246a21515ffddc2d99efbe2409db",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1052,1056 @@    val nonSplitExprCode = {\n      commonExprs.map { exprs =>\n        val eval = withSubExprEliminationExprs(localSubExprEliminationExprsForNonSplit.toMap) {\n          val eval = exprs.head.genCode(this)\n          // Generate the code for this expression tree."
  },
  {
    "id" : "d93e5288-da75-4fc9-aab2-c61f602f0bdf",
    "prId" : 32699,
    "prUrl" : "https://github.com/apache/spark/pull/32699#pullrequestreview-672084069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5623ae01-1855-4a54-ab89-32da1e733cc2",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "why does this have to be a mutable state now?",
        "createdAt" : "2021-05-31T07:04:52Z",
        "updatedAt" : "2021-05-31T07:04:52Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "3903e318-45c1-4336-b1e3-2809a993f837",
        "parentId" : "5623ae01-1855-4a54-ab89-32da1e733cc2",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Use the example in the description to explain. For the two subexpressions:\r\n\r\n1. `simpleUDF($\"id\")`\r\n2. `functions.length(simpleUDF($\"id\"))`\r\n\r\n\r\nPreviously we evaluate them independently, i.e.,\r\n\r\n```\r\nString subExpr1 = simpleUDF($\"id\");\r\nInt subExpr2 = functions.length(simpleUDF($\"id\"));\r\n```\r\n\r\nNow we remove redundant evaluation of nested subexpressions:\r\n```\r\nString subExpr1 = simpleUDF($\"id\");\r\nInt subExpr2 = functions.length(subExpr1);\r\n```\r\n\r\nIf we need to split the functions, when we evaluate `functions.length`, it needs access of `subExpr1`. We have two choices. One is to add `subExpr1` to the function parameter list of the split function for `functions.length`. Another one is to use mutable state.\r\n\r\nTo add it to parameter list will complicate the way we compute parameter length. That's said we need to link nested subexpression relations and get the correct parameters. Seems to me it is not worth doing that.\r\n\r\nCurrently I choose the simpler approach that is to use mutable state.\r\n\r\n\r\n",
        "createdAt" : "2021-05-31T08:33:41Z",
        "updatedAt" : "2021-05-31T08:33:41Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1f64f7ba0f6246a21515ffddc2d99efbe2409db",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +1085,1089 @@          }.head\n\n          val value = addMutableState(javaType(expr.dataType), \"subExprValue\")\n\n          val isNullLiteral = eval.isNull match {"
  },
  {
    "id" : "1936d853-2d9d-4fff-984c-f17768724aca",
    "prId" : 32536,
    "prUrl" : "https://github.com/apache/spark/pull/32536#pullrequestreview-660548651",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "It seems fine, but have you checked if this stat value does not change before/after this PR?",
        "createdAt" : "2021-05-13T23:29:54Z",
        "updatedAt" : "2021-05-13T23:29:54Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "4dec124d-8358-4475-bc8e-bff6e10b2f87",
        "parentId" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "authorId" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "body" : "Yes, I did some manual tests to check this. \r\nFor example, add a `afterEach()` method to `CodeGenerationSuite` to record the `CodegenMetrics.METRIC_GENERATED_CLASS_BYTECODE_SIZE.getSnapshot.getValues` after each case and the stat value not change before/after this PR.\r\n\r\n",
        "createdAt" : "2021-05-14T03:00:03Z",
        "updatedAt" : "2021-05-14T03:00:03Z",
        "lastEditedBy" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "tags" : [
        ]
      },
      {
        "id" : "785aca12-9bd5-4abb-8fb0-503d74592a8f",
        "parentId" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "authorId" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "body" : "In the same way, the stat values of `CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE` has not changed before/after this PR.",
        "createdAt" : "2021-05-14T03:07:56Z",
        "updatedAt" : "2021-05-14T03:07:56Z",
        "lastEditedBy" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "tags" : [
        ]
      },
      {
        "id" : "9891cc10-8cdc-4bcc-b463-62112078d0fb",
        "parentId" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "authorId" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "body" : "@maropu If we want to do some code checking, maybe we can enhanced the case `metrics are recorded on compile` in `CodeGenerationSuite` as follows:\r\n```\r\ntest(\"metrics are recorded on compile\") {\r\n    ...\r\n    val metricGeneratedClassByteCodeSizeSnapshot =\r\n      CodegenMetrics.METRIC_GENERATED_CLASS_BYTECODE_SIZE.getSnapshot.getValues\r\n    val metricGeneratedMethodByteCodeSizeSnapshot =\r\n      CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE.getSnapshot.getValues\r\n    GenerateOrdering.generate(Add(Literal(123), Literal(1)).asc :: Nil)\r\n    ...\r\n    // Make sure the stat content doesn't change before/after SPARK-35398\r\n    assert(CodegenMetrics.METRIC_GENERATED_CLASS_BYTECODE_SIZE.getSnapshot.getValues\r\n      .diff(metricGeneratedClassByteCodeSizeSnapshot)\r\n      .sameElements(Array(740, 1293)))\r\n    assert(CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE.getSnapshot.getValues\r\n      .diff(metricGeneratedMethodByteCodeSizeSnapshot)\r\n      .sameElements(Array(5, 5, 6, 7, 10, 15, 46)))\r\n  }\r\n```\r\n\r\nThe new assertion can be passed before and after this pr, however, if we update the version of janino or change the codegen of `Add`, we may need to update the content of the assertion because the size of the generated code may change.\r\nFor example `CodegenMetrics.METRIC_GENERATED_CLASS_BYTECODE_SIZE` with janino 3.1.4 are `Array(740, 1293)`, but with  janino 3.0.16 are `Array(687, 1036)`, so I'm not sure if we need to add these assertions in this pr.",
        "createdAt" : "2021-05-14T03:55:07Z",
        "updatedAt" : "2021-05-14T03:57:51Z",
        "lastEditedBy" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "tags" : [
        ]
      },
      {
        "id" : "8660750d-6734-483d-aaec-54a5d2d38c5a",
        "parentId" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "> @maropu If we want to do some code checking, maybe we can enhanced the case metrics are recorded on compile in CodeGenerationSuite as follows:\r\n\r\nAh, I see. Thank for the explanation, @LuciferYang. Could you add a new test unit for the assert with the prefix `SPARK-35398: `?",
        "createdAt" : "2021-05-17T04:10:49Z",
        "updatedAt" : "2021-05-17T04:13:13Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "ce62d844-5d8a-49da-873f-7a33f4b387bb",
        "parentId" : "83bab319-48dd-4a46-a287-c13cf68b55e8",
        "authorId" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "body" : "ok",
        "createdAt" : "2021-05-17T04:48:25Z",
        "updatedAt" : "2021-05-17T04:48:25Z",
        "lastEditedBy" : "c7afbd1a-ab9f-4878-b837-32685ae783b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8db3551ea9ed012369cb67be1398f2c4dac81e8f",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1433,1437 @@  private def updateAndGetCompilationStats(evaluator: ClassBodyEvaluator): ByteCodeStats = {\n    // First retrieve the generated classes.\n    val classes = evaluator.getBytecodes.asScala\n\n    // Then walk the classes to get at the method bytecode."
  }
]