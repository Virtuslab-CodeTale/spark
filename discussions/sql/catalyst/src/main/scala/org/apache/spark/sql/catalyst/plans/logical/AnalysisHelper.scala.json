[
  {
    "id" : "d49755d7-82a1-4d86-b49b-4074c38140de",
    "prId" : 32692,
    "prUrl" : "https://github.com/apache/spark/pull/32692#pullrequestreview-671009154",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "adaa7d36-7792-49ad-8a38-c2fd21b4c013",
        "parentId" : null,
        "authorId" : "171fe41b-96df-4362-a600-2d1f030de577",
        "body" : "@cloud-fan @dongjoon-hyun  this fixes the test failure.",
        "createdAt" : "2021-05-28T07:28:59Z",
        "updatedAt" : "2021-05-28T07:28:59Z",
        "lastEditedBy" : "171fe41b-96df-4362-a600-2d1f030de577",
        "tags" : [
        ]
      }
    ],
    "commit" : "00d411d7fc5322bd0a1af948e767e895e8ac0bda",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +93,97 @@          CurrentOrigin.withOrigin(origin) {\n            val afterRule = rule.applyOrElse(afterRuleOnChildren, identity[LogicalPlan])\n            afterRule.copyTagsFrom(self)\n            afterRule\n          }"
  },
  {
    "id" : "e76d89a0-b23b-4efe-a4a5-167eddce79b8",
    "prId" : 32135,
    "prUrl" : "https://github.com/apache/spark/pull/32135#pullrequestreview-634322151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bca3b8f2-5d60-4b89-ba09-c232a16b846f",
        "parentId" : null,
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "A bit of OCD, but do we really have to do this check for each recursive call? It seems a bit wasteful. We could also just call transformDownWithPruning at this point.",
        "createdAt" : "2021-04-13T07:46:34Z",
        "updatedAt" : "2021-04-13T07:47:47Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "2eeb604e-2a7d-407d-803b-1a71729be03b",
        "parentId" : "bca3b8f2-5d60-4b89-ba09-c232a16b846f",
        "authorId" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "body" : "Yeah, makes sense.\r\nI'll see if I can remove allowInvokingTransformsInAnalyzer in a subsequent PR.",
        "createdAt" : "2021-04-13T08:08:35Z",
        "updatedAt" : "2021-04-13T08:08:36Z",
        "lastEditedBy" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "tags" : [
        ]
      },
      {
        "id" : "b996fb8a-5961-4d80-a755-7d5df8c37513",
        "parentId" : "bca3b8f2-5d60-4b89-ba09-c232a16b846f",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "Sounds good!",
        "createdAt" : "2021-04-13T08:37:37Z",
        "updatedAt" : "2021-04-13T08:37:38Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "9db15f0ee51bca66e5ca66a47fd93506a421f664",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +164,168 @@  : LogicalPlan = {\n    if (!analyzed && cond.apply(self) && !isRuleIneffective(ruleId)) {\n      AnalysisHelper.allowInvokingTransformsInAnalyzer {\n        val afterRule = CurrentOrigin.withOrigin(origin) {\n          rule.applyOrElse(self, identity[LogicalPlan])"
  }
]