[
  {
    "id" : "ac5addad-a21b-4cc1-99d7-f81565f92151",
    "prId" : 33186,
    "prUrl" : "https://github.com/apache/spark/pull/33186#pullrequestreview-698785798",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78063d05-2d48-4a95-a088-ecbb60b1a1ba",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Just to make sure, are these same with other expressions? other places might have to be fixed (in a separate PR)",
        "createdAt" : "2021-07-05T00:33:21Z",
        "updatedAt" : "2021-07-05T00:33:21Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "543947bf-5e0d-4186-8716-5064f996d98d",
        "parentId" : "78063d05-2d48-4a95-a088-ecbb60b1a1ba",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "The basic math operations (Add, Subtract, etc.) just print something like `a + b` without showing the ANSI flag. This makes sense to me.",
        "createdAt" : "2021-07-05T04:33:44Z",
        "updatedAt" : "2021-07-05T04:33:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4845387aa68b402f25bb3f24b0547ea10973b76",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +164,168 @@  override protected def withNewChildInternal(newChild: Expression): Sum = copy(child = newChild)\n\n  // The flag `failOnError` won't be shown in the `toString` or `toAggString` methods\n  override def flatArguments: Iterator[Any] = Iterator(child)\n}"
  },
  {
    "id" : "d4b4cc6b-9ee2-4fd3-a6a9-49de52dda6aa",
    "prId" : 31932,
    "prUrl" : "https://github.com/apache/spark/pull/31932#pullrequestreview-624637882",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f33b4bd6-6274-48d4-a686-2c71acb395cf",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "2 space indent",
        "createdAt" : "2021-03-30T19:42:27Z",
        "updatedAt" : "2021-03-30T19:50:21Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0e5077722d39b25680870ba9d435aafc62466c",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +40,44 @@  since = \"1.0.0\")\ncase class Sum(child: Expression) extends DeclarativeAggregate with ImplicitCastInputTypes\n    with UnaryLike[Expression] {\n\n  override def nullable: Boolean = true"
  },
  {
    "id" : "183b4339-d11e-4977-99ad-89dae17aec68",
    "prId" : 29026,
    "prUrl" : "https://github.com/apache/spark/pull/29026#pullrequestreview-444404776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c03f77c-769c-463f-8f7d-868399979ec8",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "When in `updateExpressions`, I think ansi-mode or not doesn't change the behavior. Maybe just `The sum can only be null if overflow happens`?\r\n",
        "createdAt" : "2020-07-07T21:11:23Z",
        "updatedAt" : "2020-07-07T21:11:23Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "39eb214f-8e23-499e-b213-98ef590883d1",
        "parentId" : "1c03f77c-769c-463f-8f7d-868399979ec8",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "It's the `Add` expression, and it always respects the ansi mode, no matter it's in update or merge expression.\r\n\r\nThis makes sense. If overflow happens, we will fail anyway. It's better to fail earlier to save resources.",
        "createdAt" : "2020-07-08T03:14:05Z",
        "updatedAt" : "2020-07-08T03:14:05Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "38a6e580-9283-4e33-93f4-4ed838a18812",
        "parentId" : "1c03f77c-769c-463f-8f7d-868399979ec8",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "<del>Do you mean `checkOverflow` in `Add` expression? If it is enabled, for `DecimalType`, `DecimalExactNumeric` is used for `plus` operation.</del>\r\n\r\n<del>But I don't see it has overrided `plus` behavior to check overflow and respect the ansi mode. Am I missing it?</del>",
        "createdAt" : "2020-07-08T04:22:20Z",
        "updatedAt" : "2020-07-08T04:30:50Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "328bc7a0-01fd-41d0-9719-d744d0a5b127",
        "parentId" : "1c03f77c-769c-463f-8f7d-868399979ec8",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Ah, I see. There is separate rule to handle overflow of Decimal.",
        "createdAt" : "2020-07-08T04:29:30Z",
        "updatedAt" : "2020-07-08T04:31:07Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "3717fc618548d80464788d07a9b1f81f4418ed81",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +80,84 @@        // For decimal type, the initial value of `sum` is 0. We need to keep `sum` unchanged if\n        // the input is null, as SUM function ignores null input. The `sum` can only be null if\n        // overflow happens under non-ansi mode.\n        val sumExpr = if (child.nullable) {\n          If(child.isNull, sum, sum + KnownNotNull(child).cast(resultType))"
  }
]