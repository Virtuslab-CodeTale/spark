[
  {
    "id" : "ace84224-0462-463a-9142-b07d1a5c5dcb",
    "prId" : 26279,
    "prUrl" : "https://github.com/apache/spark/pull/26279#pullrequestreview-313375139",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "baaf942b-af24-4586-ba26-d74ae0368ea7",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Why can't we reuse `explode` here?",
        "createdAt" : "2019-11-07T09:27:02Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "56ef30ca-c165-4af2-8821-db25191c02c0",
        "parentId" : "baaf942b-af24-4586-ba26-d74ae0368ea7",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "forgive me for not getting your question’s point here, do you mean they are equivalent?",
        "createdAt" : "2019-11-07T14:26:25Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "49010d2b3287b05bffdfbf922f0423740c81c551",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +364,368 @@  \"\"\",\n  since = \"3.0.0\")\ncase class UnNest(child: Expression) extends UnaryExpression with Generator with CodegenFallback {\n\n  override def elementSchema: StructType = {"
  },
  {
    "id" : "e2eb0f07-a26a-4d93-9d9a-6632923c4808",
    "prId" : 26279,
    "prUrl" : "https://github.com/apache/spark/pull/26279#pullrequestreview-313714016",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "877c4d50-be81-40db-a1d0-6f0837d05b5d",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "@yaooqinn given this examples, yes looks equivalent. How are they different in this PR?\r\nCan we reuse it or deduplicate the same logic?\r\n\r\n```scala\r\nscala> sql(\"select unnest(a) FROM VALUES (array(1,2)), (array(3,4)) AS v1(a)\").show()\r\n+------+\r\n|unnest|\r\n+------+\r\n|     1|\r\n|     2|\r\n|     3|\r\n|     4|\r\n+------+\r\n\r\n\r\nscala> sql(\"select unnest(array(10, 20))\").show()\r\n+------+\r\n|unnest|\r\n+------+\r\n|    10|\r\n|    20|\r\n+------+\r\n\r\n\r\nscala> sql(\"select explode(a) FROM VALUES (array(1,2)), (array(3,4)) AS v1(a)\").show()\r\n+---+\r\n|col|\r\n+---+\r\n|  1|\r\n|  2|\r\n|  3|\r\n|  4|\r\n+---+\r\n\r\n\r\nscala> sql(\"select explode(array(10, 20))\").show()\r\n+---+\r\n|col|\r\n+---+\r\n| 10|\r\n| 20|\r\n+---+\r\n```",
        "createdAt" : "2019-11-07T21:24:41Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "026a16dd-db9e-4c93-aea0-54797cfc061b",
        "parentId" : "877c4d50-be81-40db-a1d0-6f0837d05b5d",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "Sorry，the examples are misleading，should use multidimensional arrays i.e array(array(1,2),array(3,4)). Then it will show the difference between unnest and explode. I\r\n will add some new examples here.",
        "createdAt" : "2019-11-07T23:59:11Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "49010d2b3287b05bffdfbf922f0423740c81c551",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +356,360 @@       2\n       3\n       4\n      > SELECT _FUNC_(a) FROM VALUES (array(array(1,2), array(3,4))) AS v1(a);\n       1"
  },
  {
    "id" : "9689e46c-fa7e-4918-9f85-4ea96ee11720",
    "prId" : 26279,
    "prUrl" : "https://github.com/apache/spark/pull/26279#pullrequestreview-318127948",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4fe1fc5-ea14-47dc-9541-50ac0fe47f82",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Can we implement codegen as well?",
        "createdAt" : "2019-11-15T07:40:28Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "198fea10-1916-4421-b4fd-0d22d8e5ff6e",
        "parentId" : "e4fe1fc5-ea14-47dc-9541-50ac0fe47f82",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "seems very difficult to do codegen",
        "createdAt" : "2019-11-15T10:40:52Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      },
      {
        "id" : "1ef85b62-530b-49e3-853d-7c667415eb7b",
        "parentId" : "e4fe1fc5-ea14-47dc-9541-50ac0fe47f82",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Hm, why? similar expressions look being able to do it.",
        "createdAt" : "2019-11-18T06:56:35Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "f54c8d69-949e-4345-a05f-c82e4a2af467",
        "parentId" : "e4fe1fc5-ea14-47dc-9541-50ac0fe47f82",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "for each round of unnesting, we have to know what dataType it is at that time.",
        "createdAt" : "2019-11-18T07:00:07Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "49010d2b3287b05bffdfbf922f0423740c81c551",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +364,368 @@  \"\"\",\n  since = \"3.0.0\")\ncase class UnNest(child: Expression) extends UnaryExpression with Generator with CodegenFallback {\n\n  override def elementSchema: StructType = {"
  },
  {
    "id" : "559f38fb-0d88-4dbf-bf51-9a5c517b236a",
    "prId" : 26279,
    "prUrl" : "https://github.com/apache/spark/pull/26279#pullrequestreview-317499375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2e6a4db-4f87-4caa-a957-dae96a6370a6",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Can we avoid Scala's foreach in such critical path (see https://github.com/databricks/scala-style-guide#traversal-and-zipwithindex)?  We can at least switch to a regular for loop instead.",
        "createdAt" : "2019-11-15T07:42:21Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "c065bbed-a441-446a-b32a-153789162c6b",
        "parentId" : "a2e6a4db-4f87-4caa-a957-dae96a6370a6",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "is this a scala foreach? I guess it is a Spark ArrayData' own implementation",
        "createdAt" : "2019-11-15T09:33:13Z",
        "updatedAt" : "2019-11-18T07:55:59Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "49010d2b3287b05bffdfbf922f0423740c81c551",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +409,413 @@        val currentElementType = getElementTypeOrItself(currentType)\n        if (!currentElementType.isInstanceOf[ArrayType]) {\n          inputArray.foreach(currentElementType, (_, e) => rows += InternalRow(e))\n        } else {\n          val array = inputArray.toObjectArray(currentElementType).flatMap {"
  }
]