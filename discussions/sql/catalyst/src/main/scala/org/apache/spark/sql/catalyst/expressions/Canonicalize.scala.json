[
  {
    "id" : "7eff8082-4218-44fe-b483-e0ecfb58ab2f",
    "prId" : 30330,
    "prUrl" : "https://github.com/apache/spark/pull/30330#pullrequestreview-527992993",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d236f4a-aeb9-4186-a27f-305f9e1e05ce",
        "parentId" : null,
        "authorId" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "body" : "We can just flatMap the nested `Greatest` to one Greatest.",
        "createdAt" : "2020-11-11T09:16:29Z",
        "updatedAt" : "2020-11-11T09:16:30Z",
        "lastEditedBy" : "baca2fab-b749-483f-8c77-c4db14eca9d9",
        "tags" : [
        ]
      }
    ],
    "commit" : "11a72be638c8b5ccde5ddba3b78fa9ca9b745220",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +112,116 @@    case g: Greatest =>\n      val newChildren = orderCommutative(g, { case Greatest(children) => children })\n      Greatest(newChildren)\n    case l: Least =>\n      val newChildren = orderCommutative(l, { case Least(children) => children })"
  },
  {
    "id" : "eac402c9-ddfe-412f-b2a4-3ab69e3362ed",
    "prId" : 29794,
    "prUrl" : "https://github.com/apache/spark/pull/29794#pullrequestreview-497099157",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f144f3af-ef57-4d50-8035-abce4e749543",
        "parentId" : null,
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "should we check whether both branches are deterministic like or/and in the above?",
        "createdAt" : "2020-09-17T20:24:13Z",
        "updatedAt" : "2020-09-18T05:16:40Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "20b75de1-57d1-4f09-ab31-8d5ca6edd4f4",
        "parentId" : "f144f3af-ef57-4d50-8035-abce4e749543",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "Bitwise operations will always execute both sides. Boolean AND and OR can short circuit and not execute one side.\r\nThe bitwise operations are more like + and * in this regard.",
        "createdAt" : "2020-09-17T20:29:55Z",
        "updatedAt" : "2020-09-18T05:16:40Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "28f375a7-39e1-4729-a66c-007a60f14d75",
        "parentId" : "f144f3af-ef57-4d50-8035-abce4e749543",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "OK. I was thinking more about side-effect from non-deterministic expressions (e.g., println), and the evaluation order matters in this case, but it seems other existing transformations don't handle this as well. ",
        "createdAt" : "2020-09-17T20:48:13Z",
        "updatedAt" : "2020-09-18T05:16:40Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "33f6e506-8f88-47d0-90d9-698ebbd8173c",
        "parentId" : "f144f3af-ef57-4d50-8035-abce4e749543",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Canonicalized expression is only used for determining if two expressions have same result. We don't run it directly. And we usually consider `deterministic` together when using `canonicalized`, e.g. `semanticEquals`.",
        "createdAt" : "2020-09-27T18:02:49Z",
        "updatedAt" : "2020-09-27T18:02:49Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "456ffd23efac94af15749e2bfb79fd262a16fb94",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +82,86 @@\n    case o: BitwiseOr =>\n      orderCommutative(o, { case BitwiseOr(l, r) => Seq(l, r) }).reduce(BitwiseOr)\n    case a: BitwiseAnd =>\n      orderCommutative(a, { case BitwiseAnd(l, r) => Seq(l, r) }).reduce(BitwiseAnd)"
  }
]