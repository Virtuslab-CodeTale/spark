[
  {
    "id" : "645d01bd-b792-4ecd-bdf8-661d61635f1b",
    "prId" : 28741,
    "prUrl" : "https://github.com/apache/spark/pull/28741#pullrequestreview-425723105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bfb3832-e94b-427d-be2b-f07d867ddeb5",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "This method is copied from the original one, except that the join condition is not changed when `enablePushingExtraPredicates` is true",
        "createdAt" : "2020-06-06T08:03:16Z",
        "updatedAt" : "2020-06-06T08:03:17Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ca483e6ccfceb40c579d0094c43832f8896e84f",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +116,120 @@  def apply(plan: LogicalPlan): LogicalPlan = plan transform applyLocally\n\n  val applyLocally: PartialFunction[LogicalPlan, LogicalPlan] = {\n    // push the where condition down into join filter\n    case f @ Filter(filterCondition, Join(left, right, joinType, joinCondition, hint)) =>"
  },
  {
    "id" : "3974e68b-524c-45dd-bf1a-3fb9ec5a7363",
    "prId" : 28741,
    "prUrl" : "https://github.com/apache/spark/pull/28741#pullrequestreview-425738785",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51e1d9ba-d001-4c72-af98-1ff92a9557b5",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Why did you split `PushPredicateThroughJoinBase` into the two rules? You couldn't realize this optimization in a single rule?",
        "createdAt" : "2020-06-06T12:59:35Z",
        "updatedAt" : "2020-06-06T12:59:36Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ca483e6ccfceb40c579d0094c43832f8896e84f",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +24,28 @@\ntrait PushPredicateThroughJoinBase extends Rule[LogicalPlan] with PredicateHelper {\n  protected def enablePushingExtraPredicates: Boolean\n  /**\n   * Splits join condition expressions or filter predicates (on a given join's output) into three"
  },
  {
    "id" : "c32759fb-1f83-4fe2-95ea-40e66a7d4952",
    "prId" : 28741,
    "prUrl" : "https://github.com/apache/spark/pull/28741#pullrequestreview-425739486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a982f56b-20af-4992-a499-8e032fd4e0ec",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "nit: How about the case, `NOT(a = 2 OR b in ('1'))`? This case can be transformed into `NOT(a = 2) AND NOT(b in ('1'))` then I think it can be partially pushed down.",
        "createdAt" : "2020-06-06T13:11:56Z",
        "updatedAt" : "2020-06-06T13:11:56Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ca483e6ccfceb40c579d0094c43832f8896e84f",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +68,72 @@    //\n    // Here is an example used to explain the reason.\n    // Let's say we have NOT(a = 2 AND b in ('1')) and we do not understand how to\n    // convert b in ('1'). If we only convert a = 2, we will end up with a filter\n    // NOT(a = 2), which will generate wrong results."
  }
]