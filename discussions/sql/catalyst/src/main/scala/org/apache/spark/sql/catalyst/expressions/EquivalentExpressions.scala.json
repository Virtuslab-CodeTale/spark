[
  {
    "id" : "a1089efc-9266-4130-aed4-4db5294b5a02",
    "prId" : 33142,
    "prUrl" : "https://github.com/apache/spark/pull/33142#pullrequestreview-703488219",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32e4baac-2fe3-46f8-b847-ac4e2b41d4b4",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This partially solves the perf issue mentioned in https://github.com/apache/spark/pull/32559/files#r633488455\r\n\r\nBy filtering with height first, we can reduce the data to iterate. ",
        "createdAt" : "2021-06-29T19:16:38Z",
        "updatedAt" : "2021-06-29T19:16:38Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "00514198-faa2-457a-b504-da2c6cf0a821",
        "parentId" : "32e4baac-2fe3-46f8-b847-ac4e2b41d4b4",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I opened https://github.com/apache/spark/pull/33281 to improve it further.",
        "createdAt" : "2021-07-10T09:45:59Z",
        "updatedAt" : "2021-07-10T09:45:59Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "92786a625a7288edf93479f0615bd77a254f589b",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +87,91 @@\n    localEquivalenceMap.foreach { case (commonExpr, state) =>\n      val possibleParents = localEquivalenceMap.filter { case (_, v) => v.height > state.height }\n      val notChild = possibleParents.forall { case (k, _) =>\n        k == commonExpr || k.e.find(_.semanticEquals(commonExpr.e)).isEmpty"
  },
  {
    "id" : "84218b56-c2bf-4bb1-a668-5774a788c05c",
    "prId" : 33142,
    "prUrl" : "https://github.com/apache/spark/pull/33142#pullrequestreview-704379579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "not sure we can trigger this bug with some real queries, but it's an obvious bug to me.",
        "createdAt" : "2021-06-29T19:21:03Z",
        "updatedAt" : "2021-06-29T19:21:03Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "fb496fb6-0254-4673-ac80-004184a5dd2f",
        "parentId" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "good catch!",
        "createdAt" : "2021-06-30T15:33:41Z",
        "updatedAt" : "2021-06-30T15:33:41Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "bd17faa7-16f5-4f3a-aaec-d077a8f487e5",
        "parentId" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I think if we wrongly recurse into the children of `CodegenFallback`, it only produces unused subexpressions. Some redundant generated codes, i.e..",
        "createdAt" : "2021-06-30T15:36:13Z",
        "updatedAt" : "2021-06-30T15:36:13Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "2c5e69b2-e7d0-4e9a-80c1-aad8d89ac641",
        "parentId" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Is it better to backport this part into branch-3.1/3.0?",
        "createdAt" : "2021-07-01T01:48:36Z",
        "updatedAt" : "2021-07-01T01:48:36Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "d1753709-a801-4027-9362-e34e9b00a58e",
        "parentId" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "yea will do",
        "createdAt" : "2021-07-01T01:59:54Z",
        "updatedAt" : "2021-07-01T01:59:55Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8c5aadfd-85d2-47f7-b652-c9f3295f8382",
        "parentId" : "6fbe5b88-c7d3-4944-83ec-f1047fee9cbb",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "https://github.com/apache/spark/pull/33304",
        "createdAt" : "2021-07-12T17:41:01Z",
        "updatedAt" : "2021-07-12T17:41:02Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "92786a625a7288edf93479f0615bd77a254f589b",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +123,127 @@  // recursively add the common expressions shared between all of its children.\n  private def commonChildrenToRecurse(expr: Expression): Seq[Seq[Expression]] = expr match {\n    case _: CodegenFallback => Nil\n    case i: If => Seq(Seq(i.trueValue, i.falseValue))\n    case c: CaseWhen =>"
  },
  {
    "id" : "6da4beed-1f03-4a8f-8d18-0d0d8db8de91",
    "prId" : 33142,
    "prUrl" : "https://github.com/apache/spark/pull/33142#pullrequestreview-696378775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This fixes https://github.com/apache/spark/pull/30245#discussion_r660870034\r\n\r\nBasically it takes all the conditions as the `commonChildrenToRecurse`, so that we only get the common expressions that appear in all the conditions.",
        "createdAt" : "2021-06-29T19:21:45Z",
        "updatedAt" : "2021-06-30T14:41:14Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8b46ceb2-fb12-4dfe-87f6-04abab3117bb",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "@Kimahriman I think this fix works? The only drawback is, if there are common subexpressions among the conditions, they will always be counted as \"appear twice\" and gets codegened into methods.\r\n\r\nI think the perf overhead is really small, and if the first condition is false, we evaluate the next condition which gives perf improvement because of common subexpressions elimination.\r\n\r\nFor the value branches of `CaseWhen`, I don't touch them in this PR.",
        "createdAt" : "2021-06-30T14:39:49Z",
        "updatedAt" : "2021-06-30T14:39:50Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "e2266470-ab09-4b4e-903c-a81cf7852360",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Yeah this definitely fixes a potential bug of creating subexpressions for things that are never evaluated, same with the coalesce update. I think the values are already handled fine, it's just the conditionals that had an issue with short circuiting",
        "createdAt" : "2021-06-30T15:15:20Z",
        "updatedAt" : "2021-06-30T15:15:20Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "6db2c21a-c445-4669-8191-b1248c755c44",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "This fixed https://github.com/apache/spark/pull/30245#discussion_r660870034. \r\n\r\n> The only drawback is, if there are common subexpressions among the conditions, they will always be counted as \"appear twice\" and gets codegened into methods.\r\n\r\nI just don't get this. You mean for `If(a + b > 1, 1, a + b + c > 1, 2, a + b + c > 2, 3)`, `a + b + c` will be counted twice and considered as common subexpression?",
        "createdAt" : "2021-06-30T15:41:59Z",
        "updatedAt" : "2021-06-30T15:41:59Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "41116cd5-9fa9-4aa9-8809-fcd406f3aa29",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "I think he means in `CaseWhen(a + b > 1, 1, a + b + c > 1, 2)`, `a + b` will be a subexpression even though it might only be executed once.",
        "createdAt" : "2021-06-30T16:18:23Z",
        "updatedAt" : "2021-06-30T16:18:23Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "111cf594-8c80-44c8-9ed0-86bb46eefb7a",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "But `CaseWhen(a + b > 1, 1, a + b + c > 1, 2, a + b + c > 0, 3)`, `a + b + c` won't even be considered for a subexpression if it's seen elsewhere, which was the bug if CaseWhen supports short circuiting",
        "createdAt" : "2021-06-30T16:20:03Z",
        "updatedAt" : "2021-06-30T16:20:31Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "c9949b4d-2c16-46a7-81e4-2928f1b67591",
        "parentId" : "c2ee3c45-6f62-4666-b2d1-b098f0b27040",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Yes, because the first condition of `CaseWhen` is in both `childrenToRecurse` and `commonChildrenToRecurse`",
        "createdAt" : "2021-06-30T16:21:09Z",
        "updatedAt" : "2021-06-30T16:21:10Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "92786a625a7288edf93479f0615bd77a254f589b",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +131,135 @@      // a subexpression among values doesn't need to be in conditions because no matter which\n      // condition is true, it will be evaluated.\n      val conditions = if (c.branches.length > 1) {\n        c.branches.map(_._1)\n      } else {"
  },
  {
    "id" : "e0560ac1-72b3-4b2b-90d4-2ec20c126803",
    "prId" : 33142,
    "prUrl" : "https://github.com/apache/spark/pull/33142#pullrequestreview-698048218",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70f6d6f9-546e-4f10-830f-5186a280d656",
        "parentId" : null,
        "authorId" : "c12eb4aa-c39d-4fa9-8470-ed071c0be24a",
        "body" : "This also fixed that, previously, for `Or(Coalesce(expr1, expr2, expr2), Coalesce(expr1, expr2, expr2))`, `expr2` will be extracted and considered as a common subexpression. Currently, no subexpression will be extracted.",
        "createdAt" : "2021-07-02T10:25:46Z",
        "updatedAt" : "2021-07-02T10:26:07Z",
        "lastEditedBy" : "c12eb4aa-c39d-4fa9-8470-ed071c0be24a",
        "tags" : [
        ]
      }
    ],
    "commit" : "92786a625a7288edf93479f0615bd77a254f589b",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@      map: mutable.HashMap[ExpressionEquals, ExpressionStats]): Unit = {\n    assert(exprs.length > 1)\n    var localEquivalenceMap = mutable.HashMap.empty[ExpressionEquals, ExpressionStats]\n    addExprTree(exprs.head, localEquivalenceMap)\n"
  },
  {
    "id" : "4d148420-951d-4bef-aea5-55ad610c4a24",
    "prId" : 33142,
    "prUrl" : "https://github.com/apache/spark/pull/33142#pullrequestreview-703725433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24eac762-ec49-40d4-9148-f6b32a3dec43",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "do you mean depth instead of height?",
        "createdAt" : "2021-07-12T05:08:58Z",
        "updatedAt" : "2021-07-12T05:08:58Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "e77357bd-5cbd-4aac-a7ee-58f72aee7552",
        "parentId" : "24eac762-ec49-40d4-9148-f6b32a3dec43",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I think these two are similar?",
        "createdAt" : "2021-07-12T05:19:23Z",
        "updatedAt" : "2021-07-12T05:19:23Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "d006baa6-d42f-4c43-8bec-65e27e94fe3d",
        "parentId" : "24eac762-ec49-40d4-9148-f6b32a3dec43",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "ohh it's correct! sorry for a false alarm",
        "createdAt" : "2021-07-12T05:25:34Z",
        "updatedAt" : "2021-07-12T05:25:34Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "92786a625a7288edf93479f0615bd77a254f589b",
    "line" : 258,
    "diffHunk" : "@@ -1,1 +229,233 @@case class ExpressionStats(expr: Expression)(var useCount: Int = 1) {\n  // This is used to do a fast pre-check for child-parent relationship. For example, expr1 can\n  // only be a parent of expr2 if expr1.height is larger than expr2.height.\n  lazy val height = getHeight(expr)\n"
  },
  {
    "id" : "08aa4ae1-49b1-4d68-b96d-ec7b7d44c59f",
    "prId" : 32870,
    "prUrl" : "https://github.com/apache/spark/pull/32870#pullrequestreview-681402209",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0f49169-f715-497d-83ed-0bf33ed2027b",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Just curious, is there a reason of this move?",
        "createdAt" : "2021-06-11T00:16:21Z",
        "updatedAt" : "2021-06-11T00:16:21Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "b93b7d3e-cfde-4c5b-8647-c949f5fd0c60",
        "parentId" : "d0f49169-f715-497d-83ed-0bf33ed2027b",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Oh, as it is a nested class, I cannot allocate it separately, but\r\n\r\n```scala\r\nval equivalence = new EquivalentExpressions\r\nval exprOrdering = new equivalence.ExpressionContainmentOrdering\r\n```\r\n\r\nI can revert to nested class if you think it's unnecessary change.",
        "createdAt" : "2021-06-11T00:38:25Z",
        "updatedAt" : "2021-06-11T00:38:26Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "eb7389b4-3843-4b91-b2d7-df533ad27fd9",
        "parentId" : "d0f49169-f715-497d-83ed-0bf33ed2027b",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Never mind. New one also looks good~",
        "createdAt" : "2021-06-11T02:43:43Z",
        "updatedAt" : "2021-06-11T02:43:43Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "019fababe0cd4f6630fcec56c4b08f9254d71269",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +219,223 @@ * irrelevant expressions does not matter.\n */\nclass ExpressionContainmentOrdering extends Ordering[Expression] {\n  override def compare(x: Expression, y: Expression): Int = {\n    if (x.find(_.semanticEquals(y)).isDefined) {"
  },
  {
    "id" : "8fa849ef-6d27-42c0-8936-42aa26f9f6e1",
    "prId" : 32870,
    "prUrl" : "https://github.com/apache/spark/pull/32870#pullrequestreview-681414474",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c1d2172-61ff-4b0e-b1e1-94810ed2ef2c",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "To be complete, could you add some description about the semantically-equal expressions?",
        "createdAt" : "2021-06-11T03:12:24Z",
        "updatedAt" : "2021-06-11T03:12:24Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "b7b617ad-5543-4fca-bffc-3775c8e9a2a4",
        "parentId" : "3c1d2172-61ff-4b0e-b1e1-94810ed2ef2c",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Sure. Added.",
        "createdAt" : "2021-06-11T03:22:12Z",
        "updatedAt" : "2021-06-11T03:22:12Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "019fababe0cd4f6630fcec56c4b08f9254d71269",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +217,221 @@ * this is not for general expression ordering. For example, two irrelevant or semantically-equal\n * expressions will be considered as equal by this ordering. But for the usage here, the order of\n * irrelevant expressions does not matter.\n */\nclass ExpressionContainmentOrdering extends Ordering[Expression] {"
  }
]