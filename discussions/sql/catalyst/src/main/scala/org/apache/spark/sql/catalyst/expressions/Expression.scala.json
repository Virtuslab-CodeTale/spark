[
  {
    "id" : "d0a4ce17-ecf7-42e7-9125-ace876bed068",
    "prId" : 32885,
    "prUrl" : "https://github.com/apache/spark/pull/32885#pullrequestreview-682142245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60e3bd7e-33c2-467b-98b2-50ea45c85a61",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Yes, I agree with the idea.",
        "createdAt" : "2021-06-11T19:05:30Z",
        "updatedAt" : "2021-06-11T19:05:30Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "5095fffcd0cd76548eadef802cdb81261029ff12",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +239,243 @@   * See [[Canonicalize]] for more details.\n   */\n  final def semanticEquals(other: Expression): Boolean =\n    deterministic && other.deterministic && canonicalized == other.canonicalized\n"
  },
  {
    "id" : "ce47e615-9ccf-4608-a197-866b69fe1207",
    "prId" : 31500,
    "prUrl" : "https://github.com/apache/spark/pull/31500#pullrequestreview-585431750",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "478e54b9-8bee-4e4e-bef6-aa03288a9be2",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Maybe default to using the class name or something? ",
        "createdAt" : "2021-02-08T02:25:05Z",
        "updatedAt" : "2021-02-08T02:25:06Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "6646bdfe-9be3-4483-a024-06f8e44eab53",
        "parentId" : "478e54b9-8bee-4e4e-bef6-aa03288a9be2",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "It's an internal trait, seems OK to require it.",
        "createdAt" : "2021-02-08T12:06:33Z",
        "updatedAt" : "2021-02-08T12:06:33Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "56c3001ea558efd4e6290bb805a4b59659c21e04",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1090,1094 @@ */\ntrait UserDefinedExpression {\n  def name: String\n}"
  },
  {
    "id" : "1dfd02c2-9420-4c8f-b52f-ffc648176258",
    "prId" : 28420,
    "prUrl" : "https://github.com/apache/spark/pull/28420#pullrequestreview-409094845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3432e683-defc-43d6-b4d2-9d083576116c",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Why do we need two extra interface methods just to make the column name pretty? Seems the output isn't even completely pretty.",
        "createdAt" : "2020-05-11T08:45:30Z",
        "updatedAt" : "2020-05-11T08:45:30Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "e2055ec0-1181-4dfc-935f-f24857bcb18f",
        "parentId" : "3432e683-defc-43d6-b4d2-9d083576116c",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "It's not about pretty or not. It's about consistency. If we call a function with its alias name, then it will not use `PrettyAttribute` and the string representation is different from if we call the function with the original name.",
        "createdAt" : "2020-05-11T09:02:09Z",
        "updatedAt" : "2020-05-11T09:02:10Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "3ce1c495-6e3d-46b8-90ca-9caa48290432",
        "parentId" : "3432e683-defc-43d6-b4d2-9d083576116c",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "The consistency is good but the readability here is the problem. See the implementation side:\r\n\r\n```scala\r\n  override def sql: String = s\"$prettyName(${field.sql} FROM ${source.sql})\"\r\n  override def prettyName: String = \"extract\"\r\n```\r\nvs\r\n```scala\r\n  override def exprsReplaced: Seq[Expression] = Seq(field, source)\r\n\r\n  override def mkString(childrenString: Seq[String]): String = {\r\n    prettyName + childrenString.mkString(\"(\", \" FROM \", \")\")\r\n  }\r\n```\r\n\r\nPreviously, it was fine to only know `sql` and `prettyName` but now you should know what `exprsReplaced` and `mkString` are. From the naming, it's confusing what that means too.",
        "createdAt" : "2020-05-11T09:31:49Z",
        "updatedAt" : "2020-05-11T09:31:49Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "c14a70be-3ca7-40c5-bc42-ed4252250dc9",
        "parentId" : "3432e683-defc-43d6-b4d2-9d083576116c",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I would just document that `sql` and `prettyName` should be properly overridden at `RuntimeReplaceable` just like we have the restriction about the `child`. We could have an util for it as well.",
        "createdAt" : "2020-05-11T09:40:02Z",
        "updatedAt" : "2020-05-11T09:40:20Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "c250a105-ea99-46eb-bcf8-fc3f1ed3c000",
        "parentId" : "3432e683-defc-43d6-b4d2-9d083576116c",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "The caller side decides if he wants pretty string or not, by calling `Expression.sql` or `toPrettySQL(Expression)`. So simply overridden `sql` doesn't work, unless we add a boolean parameter.",
        "createdAt" : "2020-05-11T11:41:48Z",
        "updatedAt" : "2020-05-11T11:41:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "5843ac6a41573bb80482aca27069dbd5baf81d5c",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +337,341 @@  def mkString(childrenString: Seq[String]): String = {\n    prettyName + childrenString.mkString(\"(\", \", \", \")\")\n  }\n}\n"
  },
  {
    "id" : "e6616d9d-19c1-41f6-ae4c-ef1f89ae2336",
    "prId" : 27685,
    "prUrl" : "https://github.com/apache/spark/pull/27685#pullrequestreview-371290697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a1e15d6-d542-4f77-8e44-b6991232de38",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "is it possible to only add one method? I'm worried about adding to many methods to the framework.",
        "createdAt" : "2020-03-09T13:11:10Z",
        "updatedAt" : "2020-04-09T15:06:31Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "2ebb947e-089a-4d60-baf7-53c79b399784",
        "parentId" : "4a1e15d6-d542-4f77-8e44-b6991232de38",
        "authorId" : "c48b13f0-9ce5-4910-a8eb-aee1ac73ffcb",
        "body" : "IMO, the `argumentString` is needed because `AttributeReference` already overwrite `toString`, thus we need the new abstract string function to switch to non-exprid format.  For `flatArgumentStrings`, it only have two callers. I refactored the `toAggString` of `AggregateFunction`, then we don't need to add the method `flatArgumentStrings` in `Expression` but just implement it within `toString`. See commit b74c5006a6880773f18507f6b46a1d5674cf7dd4. ",
        "createdAt" : "2020-03-09T15:35:53Z",
        "updatedAt" : "2020-04-09T15:06:31Z",
        "lastEditedBy" : "c48b13f0-9ce5-4910-a8eb-aee1ac73ffcb",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7daaa6543a51dbd83d56b56030d0d0b4755cb56",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +282,286 @@  }\n\n  def argumentString: String = toString\n\n  /**"
  },
  {
    "id" : "3e4b6f37-d97b-4ed4-8e51-3a0c4de68c54",
    "prId" : 25827,
    "prUrl" : "https://github.com/apache/spark/pull/25827#pullrequestreview-289675600",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f05084be-0e38-457f-8e07-33eab6e3c40d",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "@viirya @cloud-fan Is this correct? I remember @viirya worked on this in #21140 long before, but the pr wasn't merged because of some reasons: performance or design issues?",
        "createdAt" : "2019-09-18T05:09:35Z",
        "updatedAt" : "2019-11-21T01:16:18Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "1c967be6-9819-4d79-afe5-b645d48ba5d1",
        "parentId" : "f05084be-0e38-457f-8e07-33eab6e3c40d",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I recall that is because string-based manipulation was thought too buggy? I didn't remember it is because of performance issue.",
        "createdAt" : "2019-09-18T05:23:23Z",
        "updatedAt" : "2019-11-21T01:16:18Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "f662ec17-666b-4dad-b597-e305e6527cb7",
        "parentId" : "f05084be-0e38-457f-8e07-33eab6e3c40d",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Aha, I see.",
        "createdAt" : "2019-09-18T05:26:36Z",
        "updatedAt" : "2019-11-21T01:16:18Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "543c0167dab23ece2e4db232c0fd7d4c9e5eeb8e",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +162,166 @@    // we don't expect might occur in many queries. Therefore, we currently apply\n    // this split function to specific performance-sensitive places only,\n    // e.g., common subexpression elimination for the whole stage codegen and OR expressions.\n    val splitThreshold = SQLConf.get.methodSplitThreshold\n    if (eval.code.length > splitThreshold && ctx.INPUT_ROW != null && ctx.currentVars == null) {"
  },
  {
    "id" : "c262b688-8353-4639-84ec-f900eca8f270",
    "prId" : 25827,
    "prUrl" : "https://github.com/apache/spark/pull/25827#pullrequestreview-291435161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1126dc92-a718-431e-b1a6-bf8393dd4315",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Why add this comment?",
        "createdAt" : "2019-09-20T21:36:02Z",
        "updatedAt" : "2019-11-21T01:16:18Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "cc8d9770-fcf0-4805-8255-8a0bfc8a10b4",
        "parentId" : "1126dc92-a718-431e-b1a6-bf8393dd4315",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "To avoid duplicate work. Currently, this func and `defineSingleSplitFunction` have too similar logic.",
        "createdAt" : "2019-09-20T23:43:30Z",
        "updatedAt" : "2019-11-21T01:16:18Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "543c0167dab23ece2e4db232c0fd7d4c9e5eeb8e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +158,162 @@    // TODO: support whole stage codegen too\n    //\n    // NOTE: We could use `CodeGenerator.defineSingleSplitFunction` here for the code path\n    // of the whole stage codegen. But, we don't do so now because the performance changes that\n    // we don't expect might occur in many queries. Therefore, we currently apply"
  },
  {
    "id" : "7d1e642a-6fae-4cc2-98ac-d5e1478cb56b",
    "prId" : 24866,
    "prUrl" : "https://github.com/apache/spark/pull/24866#pullrequestreview-251986379",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "847a3a02-a0d8-486b-bf7c-de52926f40dc",
        "parentId" : null,
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "Sorry to be late to the party, but can why can't we make `references` a lazy val?",
        "createdAt" : "2019-06-19T18:36:50Z",
        "updatedAt" : "2019-06-19T18:40:19Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "175a8982-b4f8-4961-ad69-4cd734e07a1c",
        "parentId" : "847a3a02-a0d8-486b-bf7c-de52926f40dc",
        "authorId" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "body" : "Because somehow the scala compiler won't allow us to call super on lazy vals. This workaround makes subclasses' `references` able to call `super.references`.",
        "createdAt" : "2019-06-19T18:47:51Z",
        "updatedAt" : "2019-06-19T18:48:10Z",
        "lastEditedBy" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "tags" : [
        ]
      },
      {
        "id" : "b8772f01-833f-40e6-8605-c7830f502c4a",
        "parentId" : "847a3a02-a0d8-486b-bf7c-de52926f40dc",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "Where do you want to call super?",
        "createdAt" : "2019-06-19T19:08:56Z",
        "updatedAt" : "2019-06-19T19:08:56Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "9da98d33-3413-40e8-9ecc-bd66899126e0",
        "parentId" : "847a3a02-a0d8-486b-bf7c-de52926f40dc",
        "authorId" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "body" : "Git grep gives me `sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/subquery.scala:    if (plan.resolved) super.references -- plan.outputSet else super.references`. This is the case requiring this workaround.",
        "createdAt" : "2019-06-19T21:39:04Z",
        "updatedAt" : "2019-06-19T21:39:04Z",
        "lastEditedBy" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "tags" : [
        ]
      },
      {
        "id" : "1d2d4a8b-fa8b-48b2-995c-d895d070e806",
        "parentId" : "847a3a02-a0d8-486b-bf7c-de52926f40dc",
        "authorId" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "body" : "A related Scala forum discussion: https://www.scala-lang.org/old/node/11315",
        "createdAt" : "2019-06-19T21:40:16Z",
        "updatedAt" : "2019-06-19T21:40:16Z",
        "lastEditedBy" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "tags" : [
        ]
      }
    ],
    "commit" : "4483331586090dc5ddc79c646e1c18eb1aa0742c",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +118,122 @@   */\n  @transient\n  private lazy val _references: AttributeSet =\n    AttributeSet.fromAttributeSets(children.map(_.references))\n"
  }
]