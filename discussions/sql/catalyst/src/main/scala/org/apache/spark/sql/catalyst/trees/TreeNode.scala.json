[
  {
    "id" : "98429e3e-4bb2-482a-a107-0b5d7cd0ffbf",
    "prId" : 32761,
    "prUrl" : "https://github.com/apache/spark/pull/32761#pullrequestreview-676530119",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "675f2acd-9448-4a16-ad35-46e65f0a4b16",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Since this is only used in `TypeCoercion.scala`, shall we keep it there?",
        "createdAt" : "2021-06-04T08:42:35Z",
        "updatedAt" : "2021-06-04T08:42:36Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "bb4ebf44-cd23-45f4-b7f0-afadb619bb90",
        "parentId" : "675f2acd-9448-4a16-ad35-46e65f0a4b16",
        "authorId" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "body" : "(1) we probably don't want to expose markRuleAsIneffective to the outside of trees? If it can be used arbitrarily in a rule, the behavior would be harder to reason.\r\n(2) resolveOperatorUpWithPruning can potentially call it.  I can do it in a separate PR.",
        "createdAt" : "2021-06-04T16:57:47Z",
        "updatedAt" : "2021-06-04T16:57:47Z",
        "lastEditedBy" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "tags" : [
        ]
      },
      {
        "id" : "3961fcde-830e-4079-b0c8-434872e0d03e",
        "parentId" : "675f2acd-9448-4a16-ad35-46e65f0a4b16",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "ok",
        "createdAt" : "2021-06-04T17:43:40Z",
        "updatedAt" : "2021-06-04T17:43:40Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c9cd28ac10163cc4878a13b47e43b6c0af92465",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +567,571 @@   *               varying initial state for different invocations.\n   */\n  def transformUpWithBeforeAndAfterRuleOnChildren(\n      cond: BaseType => Boolean, ruleId: RuleId = UnknownRuleId)(\n    rule: PartialFunction[(BaseType, BaseType), BaseType]): BaseType = {"
  },
  {
    "id" : "35d89db7-0002-4b3a-a81c-36c6253dc92c",
    "prId" : 32557,
    "prUrl" : "https://github.com/apache/spark/pull/32557#pullrequestreview-661916719",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d22e735-68dc-4acf-9e32-f1c7ba218fad",
        "parentId" : null,
        "authorId" : "6b53d819-334a-4038-a2b8-66582f8c76a7",
        "body" : "The `TreeNode` inherits `Product`, I'm wondering if only one check should be kept.\r\n\r\nMaybe this change is redundant, the following one which changes `case p if p.productIterator.exists(_.isInstanceOf[TreeNode[_]]) => true` is the key one.\r\n\r\n",
        "createdAt" : "2021-05-18T02:13:02Z",
        "updatedAt" : "2021-05-18T02:20:45Z",
        "lastEditedBy" : "6b53d819-334a-4038-a2b8-66582f8c76a7",
        "tags" : [
        ]
      },
      {
        "id" : "3dd0ca2a-68d8-480c-9534-b8c2491c6ed2",
        "parentId" : "0d22e735-68dc-4acf-9e32-f1c7ba218fad",
        "authorId" : "cd552757-c9c9-412a-9565-ff23341cdb66",
        "body" : "Nice catch, I think we can remove the TreeNode check. The code change is for Seq,  without this Seq[Product] will be written as null.",
        "createdAt" : "2021-05-18T10:37:11Z",
        "updatedAt" : "2021-05-18T10:37:11Z",
        "lastEditedBy" : "cd552757-c9c9-412a-9565-ff23341cdb66",
        "tags" : [
        ]
      }
    ],
    "commit" : "c307dd0c0c65ceefec69c9612ede4e8ee7670515",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1001,1005 @@    case t: Seq[_] if t.forall(_.isInstanceOf[Partitioning]) ||\n      t.forall(_.isInstanceOf[DataType]) ||\n      t.forall(_.isInstanceOf[Product]) =>\n      JArray(t.map(parseToJson).toList)\n    case t: Seq[_] if t.length > 0 && t.head.isInstanceOf[String] =>"
  }
]