[
  {
    "id" : "4ba9d0ba-a221-4bda-8c70-8251e524d76a",
    "prId" : 32553,
    "prUrl" : "https://github.com/apache/spark/pull/32553#pullrequestreview-661685264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d24e484-2e9f-4212-92ca-c49facfed5d8",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "For this change, I think the definition of `propagateNull` is somehow different now. Previously if `propagateNull` is true, null will be propagated, but now it also depends on if the argument is primitive type. It is better to update `propagateNull` param doc.",
        "createdAt" : "2021-05-18T06:29:03Z",
        "updatedAt" : "2021-05-18T06:29:03Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "9677c893-cb00-4df0-a320-b7dc3812c1cc",
        "parentId" : "6d24e484-2e9f-4212-92ca-c49facfed5d8",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Oh, nvm. I saw you updated it below.",
        "createdAt" : "2021-05-18T06:29:30Z",
        "updatedAt" : "2021-05-18T06:29:30Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb0d959fa2ba7ced2370840e3bb9fd53321b921b",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +53,57 @@  protected lazy val needNullCheck: Boolean = needNullCheckForIndex.contains(true)\n  protected lazy val needNullCheckForIndex: Array[Boolean] =\n    arguments.map(a => a.nullable && (propagateNull ||\n        ScalaReflection.dataTypeJavaClass(a.dataType).isPrimitive)).toArray\n  protected lazy val evaluatedArgs: Array[Object] = new Array[Object](arguments.length)"
  },
  {
    "id" : "f76845b1-5f67-45f5-94cb-ccb3cf2eb894",
    "prId" : 32532,
    "prUrl" : "https://github.com/apache/spark/pull/32532#pullrequestreview-659100615",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25ebc804-f4ad-49fb-88ec-4a567397c407",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "> This could speed up the performance a bit.\r\n\r\nAre you going to attach the new benchmark result?",
        "createdAt" : "2021-05-13T07:45:57Z",
        "updatedAt" : "2021-05-13T07:45:58Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "81b3cb6f-c68e-432e-8139-ed6a8f0d995f",
        "parentId" : "25ebc804-f4ad-49fb-88ec-4a567397c407",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "Thanks. Yes I'll attach benchmark results for this later.",
        "createdAt" : "2021-05-13T16:50:12Z",
        "updatedAt" : "2021-05-13T16:50:12Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      }
    ],
    "commit" : "92f3284bcbae4c2e9476ded875b9847c8b94d34c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +147,151 @@          throw e.getCause\n      }\n      boxingFn(ret)\n    }\n  }"
  },
  {
    "id" : "5ea1a5a3-f5ed-47a8-b683-c97327e3d13f",
    "prId" : 32532,
    "prUrl" : "https://github.com/apache/spark/pull/32532#pullrequestreview-659102194",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c180ab18-6652-47fe-83df-cc04fa1bc833",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I'm probably missing something dumb here but dataType is an argument to this method - how can we have one function for it? I don't see where dataType is available to the trait",
        "createdAt" : "2021-05-13T14:27:17Z",
        "updatedAt" : "2021-05-13T14:27:17Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "8b2c6b63-43b9-4b7c-aa2d-318e91114554",
        "parentId" : "c180ab18-6652-47fe-83df-cc04fa1bc833",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "It's a bit misleading by looking at it, but in the call sites of `invoke` we currently always pass `Expression.dataType` (which is overridden by `Invoke` and `StaticInvoke`) as its argument, so the parameter is actually unnecessary. The same goes to `arguments`. To avoid confusion I think we can just remove these two parameters.",
        "createdAt" : "2021-05-13T16:52:07Z",
        "updatedAt" : "2021-05-13T16:53:15Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      }
    ],
    "commit" : "92f3284bcbae4c2e9476ded875b9847c8b94d34c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +147,151 @@          throw e.getCause\n      }\n      boxingFn(ret)\n    }\n  }"
  },
  {
    "id" : "223b0530-8f85-4dcf-9683-d1939b8dc1e0",
    "prId" : 32527,
    "prUrl" : "https://github.com/apache/spark/pull/32527#pullrequestreview-658556302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b15b225-3c61-439e-bc6b-03e6eb1fbb1d",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "why we need to keep `evaluatedArgs` as a (lazy) val?",
        "createdAt" : "2021-05-13T02:02:12Z",
        "updatedAt" : "2021-05-13T02:02:39Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "0c2f5d7e-1232-43b2-9e35-2fa6456f287b",
        "parentId" : "8b15b225-3c61-439e-bc6b-03e6eb1fbb1d",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "You mean just use val?",
        "createdAt" : "2021-05-13T02:35:07Z",
        "updatedAt" : "2021-05-13T02:35:08Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "0fc5fa14-6eee-4abd-9dd4-e867be4c48f5",
        "parentId" : "8b15b225-3c61-439e-bc6b-03e6eb1fbb1d",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Doesn't we evaluate `arguments` for each time `invoke` is called? Why not just having `val evaluatedArgs: Array[Object] = new Array[Object](arguments.length)` in `invoke`?",
        "createdAt" : "2021-05-13T03:08:43Z",
        "updatedAt" : "2021-05-13T03:08:43Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "eef30cf7-e924-48ca-8e4e-dfba81dbb4f5",
        "parentId" : "8b15b225-3c61-439e-bc6b-03e6eb1fbb1d",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "I guess it aims to reuse `Array[Object]` itself and only changes the values of array.",
        "createdAt" : "2021-05-13T03:38:14Z",
        "updatedAt" : "2021-05-13T03:38:21Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "79447b10-8b95-4fec-b732-ecfba684ccf4",
        "parentId" : "8b15b225-3c61-439e-bc6b-03e6eb1fbb1d",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "Yea even though we evaluate `arguments` for each `invoke` call we can reuse the same array to store the results of evaluation. I guess it's better than allocating a new `Array[Object]` for each input row.",
        "createdAt" : "2021-05-13T03:40:15Z",
        "updatedAt" : "2021-05-13T03:40:15Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2831f9c0b78aa21c6cc906370fb5069e166dbf39",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +132,136 @@    val len = arguments.length\n    while (i < len) {\n      evaluatedArgs(i) = arguments(i).eval(input).asInstanceOf[Object]\n      i += 1\n    }"
  },
  {
    "id" : "2120f031-6c4c-4a4f-8ce7-d7e9db2e6295",
    "prId" : 32527,
    "prUrl" : "https://github.com/apache/spark/pull/32527#pullrequestreview-659127885",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Can we also improve the last piece?\r\n```\r\n      val boxedClass = ScalaReflection.typeBoxedJavaMapping.get(dataType)\r\n      if (boxedClass.isDefined) {\r\n        boxedClass.get.cast(ret)\r\n      } else {\r\n        ret\r\n      }\r\n```\r\nWe can create a function for it\r\n```\r\nprivate lazy val boxing: Any => Any = ScalaReflection.typeBoxedJavaMapping.get(dataType).map(_.cast(_)).getOrElse(identity)\r\n```",
        "createdAt" : "2021-05-13T04:49:13Z",
        "updatedAt" : "2021-05-13T04:49:13Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "2cd5b5b6-3c87-4047-8688-a59b8b475c20",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "We can do the similar thing in `Invoke.eval`",
        "createdAt" : "2021-05-13T04:50:16Z",
        "updatedAt" : "2021-05-13T04:50:16Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ddf93c62-c6dc-4c3d-9679-d03e1f59b3cc",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "Yea let me try it. In the profiling after this PR, `HashMap.get` takes 7.82% from the entire `invoke` call so it seems worthwhile to do this.",
        "createdAt" : "2021-05-13T05:07:00Z",
        "updatedAt" : "2021-05-13T05:07:00Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "ee2ae9dc-feda-4e1b-a9a3-7a08e9fb6724",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "I'm not sure if we can do the similar thing in `Invoke.eval` though since `obj` in `obj.getClass.getMethod(functionName, argClasses: _*)` is different for each call.",
        "createdAt" : "2021-05-13T05:30:17Z",
        "updatedAt" : "2021-05-13T05:30:17Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "060ff724-fa67-44cf-8247-5522192f11d0",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "You are right. Another idea: `obj` from `InternalRow` are always of the same class, we can avoid this\r\n```\r\n@transient lazy val method = {\r\n  val cls = targetObject.dataType match {\r\n    case ObjectType(cls) => cls\r\n    case StringType => classOf[UTF8String]\r\n    case _: DecimalType => classOf[Decimal]\r\n    ...\r\n  }\r\n  findMethod(cls, encodedFunctionName, argClasses)\r\n}\r\n```",
        "createdAt" : "2021-05-13T06:27:46Z",
        "updatedAt" : "2021-05-13T06:27:46Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "71931253-34d0-4f39-939f-bfb2ae820918",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "body" : "Hmm I'm not sure. Looking at usages of `Invoke`, it seems `targetObject.dataType` is usually `ObjectType` (for instance, in `ScalarFunction` we wrap the UDF into a `Literal` with `ObjectType`), so curious how useful this would be and when we'd use `StringType`/`DecimalType` for the `targetObject`.\r\n\r\nLooking at the profiling result for `Invoke.eval`, it is now dominated by `InvokeLike.invoke`:\r\n\r\n<img width=\"1193\" alt=\"Screen Shot 2021-05-13 at 9 44 19 AM\" src=\"https://user-images.githubusercontent.com/506679/118157789-d8183780-b3cf-11eb-92ae-bd9e39988c9c.png\">\r\n\r\nAlthough this is somewhat unrelated to the above as `V2FunctionBenchmark` (and `ScalarFunction`) uses `ObjectType` for `Invoke` so it's already handled by the current code:\r\n```scala\r\n  @transient lazy val method = targetObject.dataType match {\r\n    case ObjectType(cls) =>\r\n      Some(findMethod(cls, encodedFunctionName, argClasses))\r\n    case _ => None\r\n  }\r\n```\r\nwe may need new benchmarks if we decide to do this.",
        "createdAt" : "2021-05-13T16:49:38Z",
        "updatedAt" : "2021-05-13T16:49:39Z",
        "lastEditedBy" : "9ae00886-75a7-4f39-aed7-d47b26b67afb",
        "tags" : [
        ]
      },
      {
        "id" : "244e2e27-66d7-4bd5-9117-b4ee23bfe494",
        "parentId" : "37a4e36f-faa7-4c92-a41c-77617985c968",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "makes sense, for UDF, it's just an extra `method.isDefine` check, and probably not a big issue.",
        "createdAt" : "2021-05-13T17:22:19Z",
        "updatedAt" : "2021-05-13T17:22:19Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "2831f9c0b78aa21c6cc906370fb5069e166dbf39",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +141,145 @@      val ret = try {\n        method.invoke(obj, evaluatedArgs: _*)\n      } catch {\n        // Re-throw the original exception.\n        case e: java.lang.reflect.InvocationTargetException if e.getCause != null =>"
  },
  {
    "id" : "88800084-28c1-4e54-a2f0-8a591a639c81",
    "prId" : 32519,
    "prUrl" : "https://github.com/apache/spark/pull/32519#pullrequestreview-657555687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c49ff710-4b27-4b63-80bb-ea27887a885a",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "This file has one more `sys.error`? https://github.com/apache/spark/blob/1bcc51223141236d0f785c65de4c69f13a257033/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/objects/objects.scala#L488\r\n\r\nThe change looks fine for consistency.",
        "createdAt" : "2021-05-12T07:20:48Z",
        "updatedAt" : "2021-05-12T07:20:48Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "2e136144-dc83-4b35-8bb8-a36aa98409e3",
        "parentId" : "c49ff710-4b27-4b63-80bb-ea27887a885a",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Fix together? Or another minor PR as this is a followup only.",
        "createdAt" : "2021-05-12T07:27:51Z",
        "updatedAt" : "2021-05-12T07:27:51Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "7a7472b2-c2a2-4b70-8079-d772e23b4998",
        "parentId" : "c49ff710-4b27-4b63-80bb-ea27887a885a",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "hm. I think either is okay, but how about assigning a new jira number for replacing all the `sys.error` in this file with `QueryExecutionErrors.xxx` methods?",
        "createdAt" : "2021-05-12T07:32:08Z",
        "updatedAt" : "2021-05-12T07:32:08Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "6c462586-8a3d-4b92-8650-8c2612a96eb3",
        "parentId" : "c49ff710-4b27-4b63-80bb-ea27887a885a",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "sgtm",
        "createdAt" : "2021-05-12T07:36:11Z",
        "updatedAt" : "2021-05-12T07:36:11Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bcc51223141236d0f785c65de4c69f13a257033",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +152,156 @@    val method = MethodUtils.getMatchingAccessibleMethod(cls, functionName, argClasses: _*)\n    if (method == null) {\n      throw QueryExecutionErrors.methodNotDeclaredError(functionName)\n    } else {\n      method"
  },
  {
    "id" : "71a6b18a-6873-4555-b00b-19ae04cc86b0",
    "prId" : 32474,
    "prUrl" : "https://github.com/apache/spark/pull/32474#pullrequestreview-654986517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2fedd06-1978-4e2f-b9d0-663e873fb260",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Technically, this has more code like `setAccessibleWorkaround`. Let's trigger JDK11 test.",
        "createdAt" : "2021-05-08T11:53:40Z",
        "updatedAt" : "2021-05-08T11:53:40Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b96cb265c07fd8f77dbcf7e5503a22751fe5a1c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +150,154 @@\n  final def findMethod(cls: Class[_], functionName: String, argClasses: Seq[Class[_]]): Method = {\n    val method = MethodUtils.getMatchingAccessibleMethod(cls, functionName, argClasses: _*)\n    if (method == null) {\n      sys.error(s\"Couldn't find $functionName on $cls\")"
  },
  {
    "id" : "b43fe166-9aa2-4e21-aa4a-64df2707d01d",
    "prId" : 32474,
    "prUrl" : "https://github.com/apache/spark/pull/32474#pullrequestreview-657421575",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c66d30f4-dff6-4551-9aae-0dc386a3d8f9",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we throw an exception to only fail the query, instead of sys.error which crashes the driver JVM?",
        "createdAt" : "2021-05-12T02:37:04Z",
        "updatedAt" : "2021-05-12T02:37:04Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "1cc5ef4b-e339-4341-bca6-29de427f97dd",
        "parentId" : "c66d30f4-dff6-4551-9aae-0dc386a3d8f9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "ok, will submit a follow-up.",
        "createdAt" : "2021-05-12T02:58:00Z",
        "updatedAt" : "2021-05-12T02:58:00Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b96cb265c07fd8f77dbcf7e5503a22751fe5a1c",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +152,156 @@    val method = MethodUtils.getMatchingAccessibleMethod(cls, functionName, argClasses: _*)\n    if (method == null) {\n      sys.error(s\"Couldn't find $functionName on $cls\")\n    } else {\n      method"
  },
  {
    "id" : "1a104f66-0ee0-46ef-961f-6446782673a7",
    "prId" : 32404,
    "prUrl" : "https://github.com/apache/spark/pull/32404#pullrequestreview-648939999",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27cf69d6-e769-4dd0-9aec-232f296a6004",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Can we move the code to a method in the base class, and share it with `StaticInvoke`?",
        "createdAt" : "2021-04-30T06:18:21Z",
        "updatedAt" : "2021-04-30T19:06:32Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "5df40473-8d90-459f-8fa4-d43c77afca32",
        "parentId" : "27cf69d6-e769-4dd0-9aec-232f296a6004",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "There is a bit difference between two `method` from `Invoke` and `StaticInvoke`.  For example, `StaticInvoke` doesn't use encoded function name. Is it safe to share `method` between them? ",
        "createdAt" : "2021-04-30T06:32:10Z",
        "updatedAt" : "2021-04-30T19:06:32Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "331c4066-83d4-4c97-b203-09c3d0be9f66",
        "parentId" : "27cf69d6-e769-4dd0-9aec-232f296a6004",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "We may backport this change, I'd like make sure we don't introduce regression unintentionally.",
        "createdAt" : "2021-04-30T06:35:03Z",
        "updatedAt" : "2021-04-30T19:06:32Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "b4b4f52a-c486-400c-91e3-358379c49683",
        "parentId" : "27cf69d6-e769-4dd0-9aec-232f296a6004",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I see. Let's unify them later in the master branch only. Ideally, these 2 invoke functions should be consistent.",
        "createdAt" : "2021-04-30T07:07:30Z",
        "updatedAt" : "2021-04-30T19:06:32Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfaaf32cbaf17a56443cf029f724d03b5640f605",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +327,331 @@    case ObjectType(cls) =>\n      // Looking with function name + argument classes first.\n      try {\n        Some(cls.getMethod(encodedFunctionName, argClasses: _*))\n      } catch {"
  },
  {
    "id" : "18f51c48-4078-4830-b0ce-7e42b61d2a61",
    "prId" : 32404,
    "prUrl" : "https://github.com/apache/spark/pull/32404#pullrequestreview-649733981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "436931a0-2aeb-42e9-b1b0-a11ced7db465",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "We cannot filter out synthetic ones in L336?",
        "createdAt" : "2021-05-01T05:42:37Z",
        "updatedAt" : "2021-05-01T05:45:52Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "b82452e5-ea03-43e3-baeb-dc1807958ecd",
        "parentId" : "436931a0-2aeb-42e9-b1b0-a11ced7db465",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I don't know if it is possible that there is only one method and it is also a synthetic one. If we filter synthetic ones at L336, we may miss it?",
        "createdAt" : "2021-05-01T06:50:10Z",
        "updatedAt" : "2021-05-01T06:50:10Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfaaf32cbaf17a56443cf029f724d03b5640f605",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +340,344 @@          } else if (m.length > 1) {\n            // More than one matched method signature. Exclude synthetic one, e.g. generic one.\n            val realMethods = m.filter(!_.isSynthetic)\n            if (realMethods.length > 1) {\n              // Ambiguous case, we don't know which method to choose, just fail it."
  },
  {
    "id" : "9808c07c-130e-4c66-94e8-8fdfe0c3e563",
    "prId" : 32370,
    "prUrl" : "https://github.com/apache/spark/pull/32370#pullrequestreview-647387703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c8ab2d9-2c6b-4358-af15-1757a1635c9d",
        "parentId" : null,
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "nit: a potential NPE here:)",
        "createdAt" : "2021-04-28T12:24:34Z",
        "updatedAt" : "2021-04-28T12:24:35Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      },
      {
        "id" : "4c41bf40-8d8f-4ee2-a0b1-8021373bf188",
        "parentId" : "5c8ab2d9-2c6b-4358-af15-1757a1635c9d",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "do you mean `e.getCause` can be null?",
        "createdAt" : "2021-04-28T13:48:52Z",
        "updatedAt" : "2021-04-28T13:48:52Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "4268708e-402b-4a1a-8f5f-eca991344ff3",
        "parentId" : "5c8ab2d9-2c6b-4358-af15-1757a1635c9d",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "right",
        "createdAt" : "2021-04-28T16:24:37Z",
        "updatedAt" : "2021-04-28T16:24:38Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      },
      {
        "id" : "f326f787-7b52-4afd-86a5-fdeee4a9175b",
        "parentId" : "5c8ab2d9-2c6b-4358-af15-1757a1635c9d",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I don't know how the cause can be null for `InvocationTargetException`, but let me add the null check for safety.",
        "createdAt" : "2021-04-28T18:24:59Z",
        "updatedAt" : "2021-04-28T18:24:59Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "56cea5a475b07d497bb9585e38102e78d8a88d4b",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +134,138 @@      } catch {\n        // Re-throw the original exception.\n        case e: java.lang.reflect.InvocationTargetException => throw e.getCause\n      }\n      val boxedClass = ScalaReflection.typeBoxedJavaMapping.get(dataType)"
  }
]