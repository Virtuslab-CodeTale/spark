[
  {
    "id" : "51755bb3-2ce6-4da3-8136-42dfb9379ca6",
    "prId" : 33040,
    "prUrl" : "https://github.com/apache/spark/pull/33040#pullrequestreview-691615384",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05e511e3-a8a3-4be3-8d6b-9e2a97da68af",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "let's update the comment in this method\r\n```\r\n            // Having an output with same name, but different struct type.\r\n            // We need to add missing fields. Note that if there are deeply nested structs such as\r\n            // nested struct of array in struct, we don't support to add missing deeply nested field\r\n            // like that. We will sort columns in the struct expression to make sure two sides of\r\n            // union have consistent schema.\r\n```",
        "createdAt" : "2021-06-23T16:37:18Z",
        "updatedAt" : "2021-06-23T16:37:18Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7b4bbd92-4d7d-46f7-b568-c292e67a4d6e",
        "parentId" : "05e511e3-a8a3-4be3-8d6b-9e2a97da68af",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Are you referring to `addFields` or `compareAndAddFields`?",
        "createdAt" : "2021-06-23T17:02:33Z",
        "updatedAt" : "2021-06-23T17:02:34Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "9726434b-3ba1-4d03-88fe-6386c93bacc5",
        "parentId" : "05e511e3-a8a3-4be3-8d6b-9e2a97da68af",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "`compareAndAddFields`, I just copied the comment that should be updated, you can search it in this file as well.",
        "createdAt" : "2021-06-23T17:12:17Z",
        "updatedAt" : "2021-06-23T17:12:17Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "a62eb4aa-7c64-448a-9c2c-0d80deba2975",
        "parentId" : "05e511e3-a8a3-4be3-8d6b-9e2a97da68af",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Whoops comment \"in\" this method, not comment \"for\" this method, my bad",
        "createdAt" : "2021-06-23T17:14:50Z",
        "updatedAt" : "2021-06-23T17:14:50Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "746b109e-e5d5-4ff6-a866-d9048c540dda",
        "parentId" : "05e511e3-a8a3-4be3-8d6b-9e2a97da68af",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Attempted to update",
        "createdAt" : "2021-06-24T10:57:28Z",
        "updatedAt" : "2021-06-24T10:57:29Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb8ddfb432ee120ba617b71f77a0f3f71d56e01c",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +78,82 @@  }\n\n\n  /**\n   * This method will compare right to left plan's outputs. If there is one struct attribute"
  },
  {
    "id" : "e2b8241c-016c-4545-9372-609d191e697e",
    "prId" : 33040,
    "prUrl" : "https://github.com/apache/spark/pull/33040#pullrequestreview-691334733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39d2aa5f-181d-46a5-8011-3f40c30118aa",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I think `allowMissing` should also be applied here. We can union `struct<a: int, b: int>` and `struct<b: int, a: int>` even if `allowMissing=false`",
        "createdAt" : "2021-06-23T16:42:23Z",
        "updatedAt" : "2021-06-23T16:42:23Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "520edc1e-31f8-42db-b0a0-edbaf863e865",
        "parentId" : "39d2aa5f-181d-46a5-8011-3f40c30118aa",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Yep that's exactly what I had in mind as the solution for https://github.com/apache/spark/pull/32972 once this got merged",
        "createdAt" : "2021-06-23T16:55:09Z",
        "updatedAt" : "2021-06-23T16:55:09Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "062b1281-b763-41af-937e-96324bb674f2",
        "parentId" : "39d2aa5f-181d-46a5-8011-3f40c30118aa",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Do you want me to just add that in here or save that for a separate PR?",
        "createdAt" : "2021-06-23T20:26:59Z",
        "updatedAt" : "2021-06-23T20:26:59Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "967acd44-a2f5-4200-aa68-c3a8caa7ca0a",
        "parentId" : "39d2aa5f-181d-46a5-8011-3f40c30118aa",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "let's save for a separate PR",
        "createdAt" : "2021-06-24T04:54:13Z",
        "updatedAt" : "2021-06-24T04:54:13Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb8ddfb432ee120ba617b71f77a0f3f71d56e01c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +41,45 @@   * or maps.\n   */\n  private def addFields(col: Expression, targetType: StructType): Expression = {\n    assert(col.dataType.isInstanceOf[StructType], \"Only support StructType.\")\n"
  },
  {
    "id" : "12e5f71d-6d06-4c69-837f-5d25f21e09f6",
    "prId" : 33040,
    "prUrl" : "https://github.com/apache/spark/pull/33040#pullrequestreview-691003642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Is this to add fields only in left side at the end of struct? Doesn't it match original field order?",
        "createdAt" : "2021-06-23T17:15:35Z",
        "updatedAt" : "2021-06-23T17:15:35Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "bd326bcc-e355-4960-bdc7-70d57c65c080",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "When the left is projected this should match the original, but when the right is projected this will contain things on the right that aren't in the left. Basically it's\r\n\r\n```\r\nrightChild = left ++ (right - left)\r\nleftChild = rightChild ++ (left - rightChild) = rightChild\r\n```",
        "createdAt" : "2021-06-23T17:20:12Z",
        "updatedAt" : "2021-06-23T17:20:12Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "34c544ad-2937-4098-9606-fc185fc39422",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Where is the project? Do you mean\r\n\r\n```scala\r\nval rightChild = Project(rightProjectList ++ notFoundAttrs, right)\r\n```\r\n?\r\n\r\nIt is top level column projection. I mean the nested column field order.\r\n\r\n`newStructFields` contains the (nested) struct fields both in left and right column in right order.\r\n\r\nThen here it adds (nested) struct fields only in left back to `newStructFields`, before create new struct (`CreateNamedStruct`).\r\n\r\nDo we reorder the fields later?\r\n",
        "createdAt" : "2021-06-23T17:29:05Z",
        "updatedAt" : "2021-06-23T17:33:31Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "80f09bb0-d20e-43aa-b26f-76660ae457a5",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "`rightProjectList` contains the nested structs mapped in the order of left fields then remaining right fields recursively, so that's where all the reordering happens",
        "createdAt" : "2021-06-23T17:42:06Z",
        "updatedAt" : "2021-06-23T17:42:07Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "7aae30fa-e3ec-4469-ba01-19aaf36262f0",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "And then leftChild is created from the fields in rightChild which already has all the fields as that point, which is the left fields and then the right fields",
        "createdAt" : "2021-06-23T17:43:19Z",
        "updatedAt" : "2021-06-23T17:43:19Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      },
      {
        "id" : "17cb2864-e399-40a1-a25f-314b239b1b35",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "> rightProjectList contains the nested structs mapped in the order of left fields then remaining right fields recursively, so that's where all the reordering happens\r\n\r\nThe projection projects original right attributes to `rightProjectList`. If you have different nested column order, it will be projected to new order.\r\n",
        "createdAt" : "2021-06-23T18:07:54Z",
        "updatedAt" : "2021-06-23T18:07:54Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "dc060f43-f9f7-44e9-98b9-97b0b6b94e04",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "The projection is not for reordering the nested column.\r\n\r\nI look the code more in details.\r\n\r\n`targetType` is actually left side type in first call. So here we align a right struct column to left struct column.\r\n\r\nSo it makes sense to add left nested columns first (`newStructFields`), then add nested columns only in right struct.\r\n\r\n",
        "createdAt" : "2021-06-23T18:14:20Z",
        "updatedAt" : "2021-06-23T18:15:15Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "ab905d3e-805b-423c-80e7-ba04d8c07739",
        "parentId" : "fe3f0213-2a5a-4e67-a6c9-821caf581f59",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "Yeah I kept most of the naming which gets a little weird with how left/right/source/target are constructed and depends on where in the codepath you are",
        "createdAt" : "2021-06-23T18:17:59Z",
        "updatedAt" : "2021-06-23T18:18:00Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb8ddfb432ee120ba617b71f77a0f3f71d56e01c",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +67,71 @@      .filter(f => targetType.fields.find(tf => resolver(f.name, tf.name)).isEmpty)\n      .foreach { f =>\n        newStructFields ++= Literal(f.name) :: ExtractValue(col, Literal(f.name), resolver) :: Nil\n      }\n"
  },
  {
    "id" : "032f798e-c6ac-4121-bc00-0a49bded0537",
    "prId" : 33040,
    "prUrl" : "https://github.com/apache/spark/pull/33040#pullrequestreview-693016659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a13873ef-3574-4fab-88ae-03d8f8474a10",
        "parentId" : null,
        "authorId" : "c12eb4aa-c39d-4fa9-8470-ed071c0be24a",
        "body" : "nit: `inluding` -> `including`",
        "createdAt" : "2021-06-24T16:33:20Z",
        "updatedAt" : "2021-06-24T16:33:20Z",
        "lastEditedBy" : "c12eb4aa-c39d-4fa9-8470-ed071c0be24a",
        "tags" : [
        ]
      },
      {
        "id" : "9ce52d67-1665-46d0-a951-ffddd5c47225",
        "parentId" : "a13873ef-3574-4fab-88ae-03d8f8474a10",
        "authorId" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "body" : "ðŸ¤¦ ",
        "createdAt" : "2021-06-25T16:47:25Z",
        "updatedAt" : "2021-06-25T16:47:25Z",
        "lastEditedBy" : "92aa9573-b64a-4a86-aebf-54c827df3ed0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb8ddfb432ee120ba617b71f77a0f3f71d56e01c",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +104,108 @@              if allowMissingCol && !source.sameType(target) =>\n            // We have two structs with different types, so make sure the two structs have their\n            // fields in the same order by using `target`'s fields and then inluding any remaining\n            // in `foundAttr`.\n            aliased += foundAttr"
  }
]