[
  {
    "id" : "869ad14f-3664-4fca-acab-a8fa2d359935",
    "prId" : 33666,
    "prUrl" : "https://github.com/apache/spark/pull/33666#pullrequestreview-724478450",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we put these 3 in `DateTimeOperations`? The doc of this rule says `Promotes string literals that appear in arithmetic and comparison expressions.`.",
        "createdAt" : "2021-08-06T14:38:27Z",
        "updatedAt" : "2021-08-06T14:38:27Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0872ba4e-6d99-44ad-a7fb-4d6322a88448",
        "parentId" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Well, DateAdd is a sort of arithmetic expression",
        "createdAt" : "2021-08-06T15:02:44Z",
        "updatedAt" : "2021-08-06T15:02:45Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "50512e23-73d6-4050-9c43-4292410c59dd",
        "parentId" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I prefer to put all the string literal promotion here. Let me update the comment.",
        "createdAt" : "2021-08-06T15:31:36Z",
        "updatedAt" : "2021-08-06T15:31:36Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e7ce1dc1903625d9c8b3320dafea91b6b186703",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +291,295 @@        p.makeCopy(Array(a, newList))\n\n      case d @ DateAdd(left @ StringType(), _) if left.foldable =>\n        d.copy(startDate = Cast(d.startDate, DateType))\n      case d @ DateSub(left @ StringType(), _) if left.foldable =>"
  },
  {
    "id" : "a74e36d1-f1cb-42f0-845f-25c9a57a1bd4",
    "prId" : 33136,
    "prUrl" : "https://github.com/apache/spark/pull/33136#pullrequestreview-695852717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "965f17ed-c330-46ab-a5ac-ee6274744985",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we support Date -> Timestamp NTZ? in case we have such functions in the future.",
        "createdAt" : "2021-06-30T08:31:22Z",
        "updatedAt" : "2021-06-30T08:31:22Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "73385877-2536-4b74-8296-dda7cfdd7c9c",
        "parentId" : "965f17ed-c330-46ab-a5ac-ee6274744985",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Well we can have it but it is not related to this PR and there is no test case for the change",
        "createdAt" : "2021-06-30T08:40:34Z",
        "updatedAt" : "2021-06-30T08:40:35Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c206f2a9d05a3413494e6634c48d84cfc396225c",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +189,193 @@        }\n\n      case (DateType, TimestampType) => Some(TimestampType)\n      case (DateType, AnyTimestampType) => Some(AnyTimestampType.defaultConcreteType)\n"
  },
  {
    "id" : "fcb0e47f-78ce-4386-88be-ddb404d75450",
    "prId" : 31859,
    "prUrl" : "https://github.com/apache/spark/pull/31859#pullrequestreview-619273757",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "How about doing it like this so that we could quickly notice potential bugs?\r\n```\r\n          val foundTypes = convertibleTypes.filter { dt =>\r\n            convertibleTypes.forall { target =>\r\n              implicitCast(dt, target, isInputFoldable = false).isDefined\r\n            }\r\n          }\r\n\r\n          assert(foundTypes.length <= 1)\r\n\r\n          val closestConvertibleType = foundTypes.headOption\r\n```",
        "createdAt" : "2021-03-17T23:02:49Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "49acc806-af22-4489-bd78-4611dff79a8f",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Actually, this logic always selects the convertible leftmost data type from the type precedence list ?",
        "createdAt" : "2021-03-17T23:17:58Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "6c6d21e6-9ab7-40c7-bdb9-b052ec303ef6",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> Actually, this logic always selects the convertible leftmost data type from the type precedence list ?\r\n\r\nYes. The pain point is NullType and String Literal has multiple type precedence lists.\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/1097932/111567348-0aa10d80-875c-11eb-9655-b4545dffc400.png)\r\n\r\n",
        "createdAt" : "2021-03-18T03:05:01Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "a4467a6f-a695-44c4-9d3b-528ea563164d",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> How about doing it like this so that we could quickly notice potential bugs?\r\n\r\nHere is my concern: if there are duplicated types(E.g. UDT) in `TypeCollection`, then the assert will fail. ",
        "createdAt" : "2021-03-18T03:07:16Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "33f6b98e-63d0-4472-b1e6-69324e6920a1",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "> Yes. The pain point is NullType and String Literal has multiple type precedence lists.\r\n\r\nAh, I see. For example, what if we have `from=NullType, to=TypeCollection[StringType, BinaryType]`? It seems `convertibleTypes ` is not empty, but `closestConvertibleType` is `None`?",
        "createdAt" : "2021-03-19T07:50:43Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "b9311e40-9667-420f-a30e-3a8d57481ec6",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Yes, the `convertibleTypes` is [StringType, BinaryType]. Since there is no such a type in [StringType, BinaryType] that can be converted to all the other types, the `closestConvertibleType` is None.",
        "createdAt" : "2021-03-23T14:01:28Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "f45f6e4d-5e9d-4c6a-aed9-c88a758a4399",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Ah, okay. I got it. Thanks for the explanation. If so, could you add more test for these negative cases (the cases where the logic returns `None`), too?",
        "createdAt" : "2021-03-23T23:40:14Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "1a7c7040-f1e5-4f63-a477-58e21cd8e938",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Sure :)",
        "createdAt" : "2021-03-24T03:11:39Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a72dcfbf4919f8ff6c3070240cb390aeedbb8fb0",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +210,214 @@          // find the closet convertible data type, which can be implicit cast to all other\n          // convertible types.\n          val closestConvertibleType = convertibleTypes.find { dt =>\n            convertibleTypes.forall { target =>\n              implicitCast(dt, target, isInputFoldable = false).isDefined"
  }
]