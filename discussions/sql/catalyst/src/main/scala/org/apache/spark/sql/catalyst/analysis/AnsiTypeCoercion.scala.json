[
  {
    "id" : "869ad14f-3664-4fca-acab-a8fa2d359935",
    "prId" : 33666,
    "prUrl" : "https://github.com/apache/spark/pull/33666#pullrequestreview-724478450",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we put these 3 in `DateTimeOperations`? The doc of this rule says `Promotes string literals that appear in arithmetic and comparison expressions.`.",
        "createdAt" : "2021-08-06T14:38:27Z",
        "updatedAt" : "2021-08-06T14:38:27Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0872ba4e-6d99-44ad-a7fb-4d6322a88448",
        "parentId" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Well, DateAdd is a sort of arithmetic expression",
        "createdAt" : "2021-08-06T15:02:44Z",
        "updatedAt" : "2021-08-06T15:02:45Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "50512e23-73d6-4050-9c43-4292410c59dd",
        "parentId" : "7b61973b-cf48-4d16-9335-c2e48db934ea",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I prefer to put all the string literal promotion here. Let me update the comment.",
        "createdAt" : "2021-08-06T15:31:36Z",
        "updatedAt" : "2021-08-06T15:31:36Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e7ce1dc1903625d9c8b3320dafea91b6b186703",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +291,295 @@        p.makeCopy(Array(a, newList))\n\n      case d @ DateAdd(left @ StringType(), _) if left.foldable =>\n        d.copy(startDate = Cast(d.startDate, DateType))\n      case d @ DateSub(left @ StringType(), _) if left.foldable =>"
  },
  {
    "id" : "a74e36d1-f1cb-42f0-845f-25c9a57a1bd4",
    "prId" : 33136,
    "prUrl" : "https://github.com/apache/spark/pull/33136#pullrequestreview-695852717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "965f17ed-c330-46ab-a5ac-ee6274744985",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we support Date -> Timestamp NTZ? in case we have such functions in the future.",
        "createdAt" : "2021-06-30T08:31:22Z",
        "updatedAt" : "2021-06-30T08:31:22Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "73385877-2536-4b74-8296-dda7cfdd7c9c",
        "parentId" : "965f17ed-c330-46ab-a5ac-ee6274744985",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Well we can have it but it is not related to this PR and there is no test case for the change",
        "createdAt" : "2021-06-30T08:40:34Z",
        "updatedAt" : "2021-06-30T08:40:35Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c206f2a9d05a3413494e6634c48d84cfc396225c",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +189,193 @@        }\n\n      case (DateType, TimestampType) => Some(TimestampType)\n      case (DateType, AnyTimestampType) => Some(AnyTimestampType.defaultConcreteType)\n"
  },
  {
    "id" : "fcb0e47f-78ce-4386-88be-ddb404d75450",
    "prId" : 31859,
    "prUrl" : "https://github.com/apache/spark/pull/31859#pullrequestreview-619273757",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "How about doing it like this so that we could quickly notice potential bugs?\r\n```\r\n          val foundTypes = convertibleTypes.filter { dt =>\r\n            convertibleTypes.forall { target =>\r\n              implicitCast(dt, target, isInputFoldable = false).isDefined\r\n            }\r\n          }\r\n\r\n          assert(foundTypes.length <= 1)\r\n\r\n          val closestConvertibleType = foundTypes.headOption\r\n```",
        "createdAt" : "2021-03-17T23:02:49Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "49acc806-af22-4489-bd78-4611dff79a8f",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Actually, this logic always selects the convertible leftmost data type from the type precedence list ?",
        "createdAt" : "2021-03-17T23:17:58Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "6c6d21e6-9ab7-40c7-bdb9-b052ec303ef6",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> Actually, this logic always selects the convertible leftmost data type from the type precedence list ?\r\n\r\nYes. The pain point is NullType and String Literal has multiple type precedence lists.\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/1097932/111567348-0aa10d80-875c-11eb-9655-b4545dffc400.png)\r\n\r\n",
        "createdAt" : "2021-03-18T03:05:01Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "a4467a6f-a695-44c4-9d3b-528ea563164d",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> How about doing it like this so that we could quickly notice potential bugs?\r\n\r\nHere is my concern: if there are duplicated types(E.g. UDT) in `TypeCollection`, then the assert will fail. ",
        "createdAt" : "2021-03-18T03:07:16Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "33f6b98e-63d0-4472-b1e6-69324e6920a1",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "> Yes. The pain point is NullType and String Literal has multiple type precedence lists.\r\n\r\nAh, I see. For example, what if we have `from=NullType, to=TypeCollection[StringType, BinaryType]`? It seems `convertibleTypes ` is not empty, but `closestConvertibleType` is `None`?",
        "createdAt" : "2021-03-19T07:50:43Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "b9311e40-9667-420f-a30e-3a8d57481ec6",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Yes, the `convertibleTypes` is [StringType, BinaryType]. Since there is no such a type in [StringType, BinaryType] that can be converted to all the other types, the `closestConvertibleType` is None.",
        "createdAt" : "2021-03-23T14:01:28Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "f45f6e4d-5e9d-4c6a-aed9-c88a758a4399",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Ah, okay. I got it. Thanks for the explanation. If so, could you add more test for these negative cases (the cases where the logic returns `None`), too?",
        "createdAt" : "2021-03-23T23:40:14Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "1a7c7040-f1e5-4f63-a477-58e21cd8e938",
        "parentId" : "3cf5a619-85c1-4b68-93c9-483c58b57003",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Sure :)",
        "createdAt" : "2021-03-24T03:11:39Z",
        "updatedAt" : "2021-03-24T08:41:05Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a72dcfbf4919f8ff6c3070240cb390aeedbb8fb0",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +210,214 @@          // find the closet convertible data type, which can be implicit cast to all other\n          // convertible types.\n          val closestConvertibleType = convertibleTypes.find { dt =>\n            convertibleTypes.forall { target =>\n              implicitCast(dt, target, isInputFoldable = false).isDefined"
  },
  {
    "id" : "bbe636b7-5e09-4200-bacf-23df3624214c",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-577901820",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34ea113d-9695-4137-b2f0-1f3761297a5e",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Looks we need a default case (`case (t1, t2) =>`)  for a newer scala compiler?",
        "createdAt" : "2021-01-28T01:25:33Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +116,120 @@        } else {\n          Some(widerType)\n        }\n\n      case (_: TimestampType, _: DateType) | (_: DateType, _: TimestampType) =>"
  },
  {
    "id" : "a788dca1-b878-47fb-8746-f2951ce2414b",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-578003186",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a13b5d5-449c-4c82-b195-a47bb8107645",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "How about defining the common set of the rules in `TypeCoercionBase`? What's differences of the ansi/non-ansi are `BooleanEquality` and `EltCoercion`?",
        "createdAt" : "2021-01-28T01:30:34Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "2061c15f-6579-44d8-bd87-4e02ac56ea1b",
        "parentId" : "7a13b5d5-449c-4c82-b195-a47bb8107645",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> How about defining the common set of the rules in TypeCoercionBase?\r\n\r\nThe order of the rules matters. So it can be tricky to add special ansi/non-ansi rules.\r\n\r\n> What's differences of the ansi/non-ansi are BooleanEquality and EltCoercion\r\n\r\nThere is no BooleanEquality in ANSI mode. \r\nFor EltCoercion, the difference is in the function `implicitCast`. The ANSI version is stricter.",
        "createdAt" : "2021-01-28T05:44:46Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +74,78 @@ */\nobject AnsiTypeCoercion extends TypeCoercionBase {\n  override def typeCoercionRules: List[Rule[LogicalPlan]] =\n    InConversion ::\n      WidenSetOperationTypes ::"
  },
  {
    "id" : "4ca35dfa-93a0-4466-9883-2dc7433612f4",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-586680689",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0dff929a-b430-414f-913c-a7d6da9b2836",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Just out of curiosity; I know the other DBMSs, e.g., postgresql, has the same behaviour. The standard says something about it, too? ",
        "createdAt" : "2021-02-05T01:28:49Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "283053ad-0143-4822-a23c-09a7baef6678",
        "parentId" : "0dff929a-b430-414f-913c-a7d6da9b2836",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "It's not from the standard. The concern is that float type is no practical. ",
        "createdAt" : "2021-02-09T15:34:36Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +113,117 @@          // the tightest common type to avoid potential precision loss on converting the Integral\n          // type as Float type.\n          Some(DoubleType)\n        } else {\n          Some(widerType)"
  },
  {
    "id" : "be559eaf-a709-4f15-8b8b-a13bcf70caac",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-586695271",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2eb05a8c-e097-4aaa-b0db-13b84c80b5f8",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Widening decimal types is only accepted in the ANSI mode? What does the standard says? (I noticed this entry was added in the latest commit)",
        "createdAt" : "2021-02-05T01:56:08Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "0c851b8b-07f6-45d3-98ce-ff71cde823ce",
        "parentId" : "2eb05a8c-e097-4aaa-b0db-13b84c80b5f8",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "> Widening decimal types is only accepted in the ANSI mode? \r\n\r\nNo, it is in both ANSI/NonANSI. I did some code refactoring in the last commit.\r\n\r\n> What does the standard says? \r\n```\r\nIf T is DECIMAL or NUMERIC, then the effective binary precision is the product of log2(10)\r\nand the implementation-defined maximum precision of T.\r\n```\r\n```\r\nIf the effective binary precision of T1 is greater than the effective binary precision of T2, then T2 â‰º T1.\r\n```\r\nIt's very general. Considering our decimal type has a max precision limit and the data type itself is complex, I suggest following the original solution here.",
        "createdAt" : "2021-02-09T15:47:25Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +128,132 @@  override def findWiderTypeForTwo(t1: DataType, t2: DataType): Option[DataType] = {\n    findTightestCommonType(t1, t2)\n      .orElse(findWiderTypeForDecimal(t1, t2))\n      .orElse(findTypeForComplex(t1, t2, findWiderTypeForTwo))\n  }"
  },
  {
    "id" : "d33942fa-039b-4be0-b34a-6ee32a64f661",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-583961256",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "517b70f9-654e-470f-b1eb-4df77c01aa4d",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "It looks like we need to update the `WidenSetOperationTypes` comment, too:\r\nhttps://github.com/apache/spark/blob/961c85166a259cd4e5343e54f27228767a841a88/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/TypeCoercion.scala#L304-L327",
        "createdAt" : "2021-02-05T02:11:53Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +76,80 @@  override def typeCoercionRules: List[Rule[LogicalPlan]] =\n    InConversion ::\n      WidenSetOperationTypes ::\n      PromoteStringLiterals ::\n      DecimalPrecision ::"
  },
  {
    "id" : "dbaefce0-4d1d-4c8d-a064-8dab5433d474",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-586737178",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcff13da-afc6-4012-b2b9-5b024d3df783",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "We need to update it, too?\r\nhttps://github.com/apache/spark/blob/961c85166a259cd4e5343e54f27228767a841a88/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/TypeCoercion.scala#L478-L482",
        "createdAt" : "2021-02-05T02:14:31Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "5f8dd055-e32a-4467-af7c-d9190e713c99",
        "parentId" : "fcff13da-afc6-4012-b2b9-5b024d3df783",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "This one seems fine.",
        "createdAt" : "2021-02-09T16:25:05Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@object AnsiTypeCoercion extends TypeCoercionBase {\n  override def typeCoercionRules: List[Rule[LogicalPlan]] =\n    InConversion ::\n      WidenSetOperationTypes ::\n      PromoteStringLiterals ::"
  },
  {
    "id" : "645cdd5e-8b8b-4e27-a0a9-f7a5b2dcafbe",
    "prId" : 31349,
    "prUrl" : "https://github.com/apache/spark/pull/31349#pullrequestreview-586744101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca140e42-fd36-4c69-8cae-1fdda7292608",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you add more tests for this new rule?",
        "createdAt" : "2021-02-05T02:31:53Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "7c38c2ba-24d9-41a6-87c1-3a41fd4830c5",
        "parentId" : "ca140e42-fd36-4c69-8cae-1fdda7292608",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "done",
        "createdAt" : "2021-02-09T16:31:29Z",
        "updatedAt" : "2021-02-24T04:07:09Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f5ecdc58e7ca1a87675880f722f74ae2777f753",
    "line" : 232,
    "diffHunk" : "@@ -1,1 +230,234 @@   * Promotes string literals that appear in arithmetic and comparison expressions.\n   */\n  object PromoteStringLiterals extends TypeCoercionRule {\n    private def castExpr(expr: Expression, targetType: DataType): Expression = {\n      (expr.dataType, targetType) match {"
  }
]