[
  {
    "id" : "17b9f5b5-e3d7-4e2f-a014-0461722962df",
    "prId" : 32060,
    "prUrl" : "https://github.com/apache/spark/pull/32060#pullrequestreview-629733741",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d98a473a-0f62-4dc8-9aa3-56379dec8176",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "nit: This is the same as \r\n```\r\nnodePatterns.foreach {...}\r\n```",
        "createdAt" : "2021-04-07T06:23:21Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "bc31dd4a-451f-4a23-8567-f87b8876792a",
        "parentId" : "d98a473a-0f62-4dc8-9aa3-56379dec8176",
        "authorId" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "body" : "Lazily constructing `treePatternBits` is a frequent operation and thus I avoided for-loops as the style guide suggests:\r\nhttps://github.com/databricks/scala-style-guide#traversal-and-zipwithindex",
        "createdAt" : "2021-04-07T07:47:15Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "tags" : [
        ]
      },
      {
        "id" : "766e3340-a422-4c99-ad6a-bd9ac9983c7f",
        "parentId" : "d98a473a-0f62-4dc8-9aa3-56379dec8176",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "But if you see the defination of `foreach`, you will see the same implementation as you do here.",
        "createdAt" : "2021-04-07T07:51:28Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "d8c79c0b-4ebd-4565-9f2a-3a108d36f490",
        "parentId" : "d98a473a-0f62-4dc8-9aa3-56379dec8176",
        "authorId" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "body" : "foreach is more expensive... it calls a function. This is fine.",
        "createdAt" : "2021-04-07T08:01:25Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "80d631a6-73e8-46a6-a01b-a80d1f1cc6cc",
        "tags" : [
        ]
      },
      {
        "id" : "96b8a108-ecb5-4e91-95a8-aebaf4f7d077",
        "parentId" : "d98a473a-0f62-4dc8-9aa3-56379dec8176",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I see. Thanks for the explanation @sigmod @hvanhovell ",
        "createdAt" : "2021-04-07T08:29:39Z",
        "updatedAt" : "2021-04-12T00:32:44Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "718a92a743e731a698473b9170ace55187755b55",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +58,62 @@    val bits: BitSet = new BitSet(TreePattern.maxId)\n    // Propagate node pattern bits\n    val nodeTypeIterator = nodePatterns.iterator\n    while (nodeTypeIterator.hasNext) {\n      bits.set(nodeTypeIterator.next().id)"
  },
  {
    "id" : "7bac7c53-fe40-41c9-968c-6b311f5a47b7",
    "prId" : 32060,
    "prUrl" : "https://github.com/apache/spark/pull/32060#pullrequestreview-629692459",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26f183c5-c508-40b0-99a5-d469c204cf60",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "ditto",
        "createdAt" : "2021-04-07T06:23:32Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "1fd2cf22-1996-44f4-8b8d-a416047516c1",
        "parentId" : "26f183c5-c508-40b0-99a5-d469c204cf60",
        "authorId" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "body" : "The same reason as above.",
        "createdAt" : "2021-04-07T07:47:44Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "tags" : [
        ]
      }
    ],
    "commit" : "718a92a743e731a698473b9170ace55187755b55",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +63,67 @@    }\n    // Propagate children's pattern bits\n    val childIterator = children.iterator\n    while (childIterator.hasNext) {\n      bits.union(childIterator.next().treePatternBits)"
  },
  {
    "id" : "ee903902-fe03-48a2-814f-cbb2d738afa1",
    "prId" : 32060,
    "prUrl" : "https://github.com/apache/spark/pull/32060#pullrequestreview-629692516",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51c17cf0-c43d-4c34-8207-88116d571ff6",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "ditto",
        "createdAt" : "2021-04-07T06:23:37Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "89484546-b573-4b1f-b4d0-5afa2b9c2a72",
        "parentId" : "51c17cf0-c43d-4c34-8207-88116d571ff6",
        "authorId" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "body" : "The same reason as above.",
        "createdAt" : "2021-04-07T07:47:47Z",
        "updatedAt" : "2021-04-12T00:32:43Z",
        "lastEditedBy" : "8b518862-583d-43a2-a10e-b33ef1b6d824",
        "tags" : [
        ]
      }
    ],
    "commit" : "718a92a743e731a698473b9170ace55187755b55",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +68,72 @@    }\n    // Propagate expressions' pattern bits\n    val exprIterator = expressions.iterator\n    while (exprIterator.hasNext) {\n      bits.union(exprIterator.next.treePatternBits)"
  },
  {
    "id" : "9c875c26-1b86-4a88-8fc1-bea264fb0c01",
    "prId" : 30173,
    "prUrl" : "https://github.com/apache/spark/pull/30173#pullrequestreview-519039559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ed20241-b316-4484-a9a1-7ad365e0ca0d",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "nit: Is this needed to be parameterized? Seems we only need check unresolved logical plan.",
        "createdAt" : "2020-10-28T17:00:34Z",
        "updatedAt" : "2020-10-28T17:00:35Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "14f6be23-fd83-4ebd-add6-8c8dce3a90ee",
        "parentId" : "9ed20241-b316-4484-a9a1-7ad365e0ca0d",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Do you mean something like\r\n```\r\nval canGetOutput = plan match {\r\n  case l: LogicalPlan => l.resolved\r\n  case _ => true\r\n}\r\n```",
        "createdAt" : "2020-10-28T17:55:49Z",
        "updatedAt" : "2020-10-28T17:56:19Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "57f48015-3264-4510-b4dc-7244b997aa0b",
        "parentId" : "9ed20241-b316-4484-a9a1-7ad365e0ca0d",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "One advantage of the current way is we can skip the check for optimizer rules (use the default value true).",
        "createdAt" : "2020-10-28T17:57:20Z",
        "updatedAt" : "2020-10-28T17:57:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "e49c2cc6-0423-4471-a7ba-3ce78aae0382",
        "parentId" : "9ed20241-b316-4484-a9a1-7ad365e0ca0d",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Oh, I see. Make sense.",
        "createdAt" : "2020-10-28T20:04:25Z",
        "updatedAt" : "2020-10-28T20:04:25Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f94664ab2736475af1ca74b2707496d6bc005e8",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +183,187 @@   * @param canGetOutput a boolean condition to indicate if we can get the output of a plan node\n   *                     to prune the attributes mapping to be propagated. The default value is true\n   *                     as only unresolved logical plan can't get output.\n   */\n  def transformUpWithNewOutput("
  }
]