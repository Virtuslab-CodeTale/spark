[
  {
    "id" : "3e8c78f9-a597-43a1-90d9-75cd816853e3",
    "prId" : 27632,
    "prUrl" : "https://github.com/apache/spark/pull/27632#pullrequestreview-361764975",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19d7d8e4-1ea6-4635-86c1-497bfd4273fc",
        "parentId" : null,
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "If the `constraint` contains `a = b`. This change is to filter out `b = a`.\r\n",
        "createdAt" : "2020-02-20T09:53:11Z",
        "updatedAt" : "2020-02-26T08:44:37Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf7b8e561029791daa17ffb90aac9e970f002cf9",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +86,90 @@      case _ => // No inference\n    }\n    (inferredConstraints -- constraints).filterNot(i => constraints.exists(_.semanticEquals(i)))\n  }\n"
  },
  {
    "id" : "8de58f82-b888-4634-849c-ebd621184ffc",
    "prId" : 27518,
    "prUrl" : "https://github.com/apache/spark/pull/27518#pullrequestreview-483242896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7903b41-9bba-45fb-8258-24729533811c",
        "parentId" : null,
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "`EqualTo` should not be needed here, as the `inferEqualityConstraints` should cover all cases including it.",
        "createdAt" : "2020-09-06T14:29:57Z",
        "updatedAt" : "2020-09-06T14:44:42Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "0be05165-2b2d-4ea1-ac44-268da2d452ab",
        "parentId" : "a7903b41-9bba-45fb-8258-24729533811c",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "`inferEqualityConstraints` can not handle all cases, such as constraint with cast.",
        "createdAt" : "2020-09-07T03:34:12Z",
        "updatedAt" : "2020-09-07T03:34:12Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      },
      {
        "id" : "c9a08b6a-af8d-45f1-98db-c121e10ec04b",
        "parentId" : "a7903b41-9bba-45fb-8258-24729533811c",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "For example: `cast(a as double) > cast(b as double) and cast(b as double) = 1`",
        "createdAt" : "2020-09-07T05:03:09Z",
        "updatedAt" : "2020-09-07T05:03:09Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c76b9d700d834182760906577951bcaed49d147",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +103,107 @@      case _: LessThan => true\n      case _: LessThanOrEqual => true\n      case _: EqualTo => true\n      case _ => false\n    }"
  },
  {
    "id" : "a602977d-88bb-46a0-8324-fc3bc5aab8f7",
    "prId" : 27518,
    "prUrl" : "https://github.com/apache/spark/pull/27518#pullrequestreview-483638882",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42fd2c40-8f75-4b7b-8af2-f52acee90533",
        "parentId" : null,
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "Doesn't this duplicate the `greaterThans` block? \r\nHere you have `a < b < c` and in the other block you have `c > b > a` ",
        "createdAt" : "2020-09-06T14:31:57Z",
        "updatedAt" : "2020-09-06T14:44:42Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "b371e90d-cae4-4b68-82dc-cc6237b55388",
        "parentId" : "42fd2c40-8f75-4b7b-8af2-f52acee90533",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "No. for example:\r\n`a > b and 5 > a`. we can not infer anything. but we can infer that `b < 5` after rewriting `a > b and 5 > a` as `b < a and a < 5`.\r\n",
        "createdAt" : "2020-09-07T03:44:24Z",
        "updatedAt" : "2020-09-07T03:44:24Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      },
      {
        "id" : "f80d1d01-7cd6-401f-9905-b13dd942e58d",
        "parentId" : "42fd2c40-8f75-4b7b-8af2-f52acee90533",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "Is it because of the foldable check? Without it, it should be inferable.",
        "createdAt" : "2020-09-07T15:41:40Z",
        "updatedAt" : "2020-09-07T15:41:57Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c76b9d700d834182760906577951bcaed49d147",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +119,123 @@      case GreaterThanOrEqual(l, r) => LessThanOrEqual(r, l)\n      case other => other\n    }\n\n    var inferredConstraints = Set.empty[Expression]"
  },
  {
    "id" : "e049ed99-3ce5-4220-be31-8387c74b71cc",
    "prId" : 27518,
    "prUrl" : "https://github.com/apache/spark/pull/27518#pullrequestreview-483643424",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3efd8efc-63d0-4ec9-9282-6b78cd379aa6",
        "parentId" : null,
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "I think that the foldability is not needed here. The new constraints do not have to only involve constants, but also any attribute. ",
        "createdAt" : "2020-09-06T14:33:43Z",
        "updatedAt" : "2020-09-06T14:44:42Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "89479b19-30ee-4f5a-8490-e0f9c81b468c",
        "parentId" : "3efd8efc-63d0-4ec9-9282-6b78cd379aa6",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "To avoid generating too many constraints. For example: `a > b > c > 1`. The expected inferred constraints are: `a > 1 and b > 1`. ` a > c` is useless.\r\n\r\n",
        "createdAt" : "2020-09-07T03:38:33Z",
        "updatedAt" : "2020-09-07T03:38:34Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      },
      {
        "id" : "f8c4218a-881e-4cc1-a330-bd86ba36d004",
        "parentId" : "3efd8efc-63d0-4ec9-9282-6b78cd379aa6",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "If a and c are in tihe same side of a join, then it can be pushed down.",
        "createdAt" : "2020-09-07T14:36:49Z",
        "updatedAt" : "2020-09-07T14:36:50Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      },
      {
        "id" : "3ddb88da-1c0a-4a22-b965-307dad0c0a9d",
        "parentId" : "3efd8efc-63d0-4ec9-9282-6b78cd379aa6",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "How to push down `a > c` if  both `a` and `c` are not foldable?",
        "createdAt" : "2020-09-07T14:41:58Z",
        "updatedAt" : "2020-09-07T14:41:58Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      },
      {
        "id" : "b7caf707-b162-413b-9bb8-94da68a9a3fa",
        "parentId" : "3efd8efc-63d0-4ec9-9282-6b78cd379aa6",
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "I'm sorry, I used a wrong word. I meant pushed through the join into one of the sides.",
        "createdAt" : "2020-09-07T15:50:55Z",
        "updatedAt" : "2020-09-07T15:50:55Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c76b9d700d834182760906577951bcaed49d147",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +124,128 @@    greaterThans.foreach {\n      case op @ BinaryComparison(source: Attribute, destination: Expression)\n        if destination.foldable =>\n        inferredConstraints ++= (greaterThans - op).map {\n          case GreaterThan(l, r) if r.semanticEquals(source) =>"
  },
  {
    "id" : "388522de-2dec-4e09-8e6f-4ea5f10b51e2",
    "prId" : 27518,
    "prUrl" : "https://github.com/apache/spark/pull/27518#pullrequestreview-483148131",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39aada6d-e5dc-4cc2-a4b6-3baf081cb415",
        "parentId" : null,
        "authorId" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "body" : "Could you hit a infinite loop with non deterministic filters? As they are never semantically equal to any other expression (including themselves). I hit that problem in #29650, where I was also working on constraint inference , but from `EqualNullSafe`.",
        "createdAt" : "2020-09-06T14:41:39Z",
        "updatedAt" : "2020-09-06T14:44:42Z",
        "lastEditedBy" : "a8e23d47-3ae4-4385-848c-38a216d1bd08",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c76b9d700d834182760906577951bcaed49d147",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +65,69 @@      lastInequalityInferred = inferInequalityConstraints(constraints ++ inferred)\n      inferred ++= lastInequalityInferred\n    } while (lastInequalityInferred.nonEmpty)\n    inferred\n  }"
  },
  {
    "id" : "61688e14-2575-4835-b4e1-1b788d0631da",
    "prId" : 27252,
    "prUrl" : "https://github.com/apache/spark/pull/27252#pullrequestreview-357863555",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "according to https://github.com/apache/spark/pull/27252/files#r378111623\r\n\r\nIf we have `cast(a, dt) = b` and `b = 1`, we can definitely infer `cast(a, dt) = 1`.\r\nIf we have `cast(a, dt) = b` and `a = 1`, seems we can also infer `cast(1, dt) = b`.\r\n\r\nBut I'm a bit unsure about how to do it. We may need a variant of `replaceConstraints`, which holds an expression builder \"e => cast(e, dt) = b\". It looks for attribute `a`, and replace it with `cast(1, dt) = b`",
        "createdAt" : "2020-02-12T11:09:46Z",
        "updatedAt" : "2020-02-12T16:34:01Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "a53f3b9e-fef5-47c1-ab9e-2098a6f03c4a",
        "parentId" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I don't think we need to touch `replaceConstraints` at all. Please check https://github.com/apache/spark/pull/27518 that will do the trick because `a = 1` will be \"substituted\" into `cast(a, dt) = b` as a new `cast(1, dt) = b` constraint.",
        "createdAt" : "2020-02-12T11:32:14Z",
        "updatedAt" : "2020-02-12T16:34:01Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "2275981e-dd18-469d-9483-3aad141acb57",
        "parentId" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "I think both this PR and https://github.com/apache/spark/pull/27518 are beneficial. But I would use `val originalLeft = testRelation1.where('a < 1).subquery('left)` in test cases of this one instead of `val originalLeft = testRelation1.where('a === 1).subquery('left)` to avoid confusion. ",
        "createdAt" : "2020-02-12T11:38:52Z",
        "updatedAt" : "2020-02-12T16:34:01Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "c618d076-21e6-4c1a-babc-e697079eb8ca",
        "parentId" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "authorId" : "813f0961-9a16-4e42-a167-961d914c472c",
        "body" : "@cloud-fan This PR support `cast(1, dt) = b` before: \r\nhttps://github.com/apache/spark/compare/048a0ecc65763c6feaa939938e2dec6f4040d939..7dcfe915087dbe274b470928600197745a645f5e\r\n\r\nI removed it because:\r\n1. It may be broken the plan. [This is](https://github.com/apache/spark/compare/048a0ecc65763c6feaa939938e2dec6f4040d939..7dcfe915087dbe274b470928600197745a645f5e#diff-b40fcb6ac9b2e94b410f39a94a97e822R91-R93) how I handled it before.\r\n2. For `cast(a, dt) = b`, we support inferring many predicates, for example: `a > 1`, `a < 1`, `a in (2, 3)`. I'm not sure if it's safe.\r\n\r\nHow about only supporting `cast(a, dt) = 1` now?\r\n\r\n@peter-toth I'd like to support these cases in https://github.com/apache/spark/pull/27518:\r\n```\r\na < b && b < c infer a < c\r\na < b && b <= c infer a < c\r\na < b && b = c infer a < c\r\n...\r\n```",
        "createdAt" : "2020-02-12T13:27:36Z",
        "updatedAt" : "2020-02-12T16:34:01Z",
        "lastEditedBy" : "813f0961-9a16-4e42-a167-961d914c472c",
        "tags" : [
        ]
      },
      {
        "id" : "39214b4e-1470-40a8-9664-8bfef25f6994",
        "parentId" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "authorId" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "body" : "@wangyum I see, but I think currently you are doing something very different in https://github.com/apache/spark/pull/27518 see details here: https://github.com/apache/spark/pull/27518#issuecomment-585251432\r\n\r\nI would suggest keeping your https://github.com/apache/spark/pull/27518 in its current form (but amending its title) and open a new one to address inequalities.\r\n",
        "createdAt" : "2020-02-12T15:15:37Z",
        "updatedAt" : "2020-02-12T16:34:01Z",
        "lastEditedBy" : "3d4870da-39a8-4406-b00d-131930d14cd8",
        "tags" : [
        ]
      },
      {
        "id" : "6567a782-c99e-4a2a-b0b8-ef2dd7731f52",
        "parentId" : "bd8c6787-5b21-49f3-8ddd-3f0a652cc70b",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "> How about only supporting cast(a, dt) = 1 now?\r\n\r\n+1 for supporting the limited case only in this pr. Since this part of optimization can affect many queries, I think we need exhaustive discussions and tests for supporting wider cases.",
        "createdAt" : "2020-02-12T23:31:11Z",
        "updatedAt" : "2020-02-12T23:31:12Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b14b3f619af56babc981e729f43e165369cad01",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +71,75 @@        inferredConstraints ++= replaceConstraints(candidateConstraints, r, l)\n      case eq @ EqualTo(l @ Cast(_: Attribute, _, _), r: Attribute) =>\n        inferredConstraints ++= replaceConstraints(predicates - eq, r, l)\n      case eq @ EqualTo(l: Attribute, r @ Cast(_: Attribute, _, _)) =>\n        inferredConstraints ++= replaceConstraints(predicates - eq, l, r)"
  }
]