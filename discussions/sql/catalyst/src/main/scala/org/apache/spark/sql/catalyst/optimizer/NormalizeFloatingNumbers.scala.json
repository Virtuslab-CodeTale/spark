[
  {
    "id" : "b6817684-0604-4db5-bf27-6d6de8d19d72",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547337123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Not sure, can this just be a `def`?",
        "createdAt" : "2020-12-08T14:50:31Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "4dbe1a04-c16a-4a28-9a6b-42c8b5e355dc",
        "parentId" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is stateless and being a val is more efficient.",
        "createdAt" : "2020-12-08T15:20:15Z",
        "updatedAt" : "2020-12-08T15:20:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +145,149 @@  }\n\n  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {"
  },
  {
    "id" : "39787c7b-69a7-48ae-9cfc-a273b7df7f8f",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547338490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I think this check isn't necessary, as NaN won't equal -0.0f, so it will be returned on line 154 anyway. Or am I missing that there are different NaNs and this is normalizing them too?",
        "createdAt" : "2020-12-08T14:51:14Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "476538aa-f1c0-4888-9524-a9c49a75c176",
        "parentId" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is copied from the existing code. NaN is not a single value and we need to make sure all NaN values have the same binary representation in Spark unsafe row.",
        "createdAt" : "2020-12-08T15:21:37Z",
        "updatedAt" : "2020-12-08T15:21:37Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +147,151 @@  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {\n      Float.NaN\n    } else if (f == -0.0f) {"
  }
]