[
  {
    "id" : "b6817684-0604-4db5-bf27-6d6de8d19d72",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547337123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Not sure, can this just be a `def`?",
        "createdAt" : "2020-12-08T14:50:31Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "4dbe1a04-c16a-4a28-9a6b-42c8b5e355dc",
        "parentId" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is stateless and being a val is more efficient.",
        "createdAt" : "2020-12-08T15:20:15Z",
        "updatedAt" : "2020-12-08T15:20:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +145,149 @@  }\n\n  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {"
  },
  {
    "id" : "39787c7b-69a7-48ae-9cfc-a273b7df7f8f",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547338490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I think this check isn't necessary, as NaN won't equal -0.0f, so it will be returned on line 154 anyway. Or am I missing that there are different NaNs and this is normalizing them too?",
        "createdAt" : "2020-12-08T14:51:14Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "476538aa-f1c0-4888-9524-a9c49a75c176",
        "parentId" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is copied from the existing code. NaN is not a single value and we need to make sure all NaN values have the same binary representation in Spark unsafe row.",
        "createdAt" : "2020-12-08T15:21:37Z",
        "updatedAt" : "2020-12-08T15:21:37Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +147,151 @@  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {\n      Float.NaN\n    } else if (f == -0.0f) {"
  },
  {
    "id" : "ca177c2a-0a1e-4a5c-84c5-0cce880840c2",
    "prId" : 29780,
    "prUrl" : "https://github.com/apache/spark/pull/29780#pullrequestreview-491192739",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Looks logically fine but just to confirm that I understood correctly, it's just a cleanup fix to match the column names, right? and doesn't affect the final output?",
        "createdAt" : "2020-09-18T04:38:11Z",
        "updatedAt" : "2020-09-18T04:38:11Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "672c0590-4423-46ff-a394-33c8d08bfb6e",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Yea I think so. `CreateNamedStruct` allows you to specify the name for each field.",
        "createdAt" : "2020-09-18T04:48:48Z",
        "updatedAt" : "2020-09-18T04:48:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "498e4aee-8dee-4264-bfa4-3f374030e3f1",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Yeah, you're right and this is not an user-facing bug. When writing code to check paln integrity for `SparkPlan`s, I found this issue; canonicalized attributes between final/partial `HaashAggregate`s were not equal incorrectly because of this issue (schema mismatch).",
        "createdAt" : "2020-09-18T06:49:10Z",
        "updatedAt" : "2020-09-18T06:49:10Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bf4f32924df6a3a06623dfcd2e06b6749c6ebad",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +133,137 @@        case (name, i) => Seq(Literal(name), normalize(GetStructField(expr, i)))\n      }\n      val struct = CreateNamedStruct(fields.flatten.toSeq)\n      KnownFloatingPointNormalized(If(IsNull(expr), Literal(null, struct.dataType), struct))\n"
  },
  {
    "id" : "36cca190-f2a0-47c2-a5b5-f0f952c9c451",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446097391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09239699-c40f-49ce-97b9-09dafaa22fd9",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Could you narrow-down the PR title? For example, instead of `certain children expressions`, you can mention `IF` and `CaseWhen` specifically because this PR only handles those two.",
        "createdAt" : "2020-07-10T03:14:08Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "006ff1eb-4683-4362-b182-89f9df0ce143",
        "parentId" : "09239699-c40f-49ce-97b9-09dafaa22fd9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Updated. Thanks for the suggestion.",
        "createdAt" : "2020-07-10T03:20:07Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +120,124 @@      If(cond, normalize(trueValue), normalize(falseValue))\n\n    case CaseWhen(branches, elseVale) =>\n      CaseWhen(branches.map(br => (br._1, normalize(br._2))), elseVale.map(normalize))\n"
  },
  {
    "id" : "f314d091-e8c7-4713-9cbf-25c21b6b337d",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446171461",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b30289ca-67cf-48d1-9b46-0e65f1c39a49",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we consider more pass-through expressions? like `Coalesce`?",
        "createdAt" : "2020-07-10T06:59:16Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "c3dc9900-099b-411b-bcf6-c54e2e2b754b",
        "parentId" : "b30289ca-67cf-48d1-9b46-0e65f1c39a49",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Okay.",
        "createdAt" : "2020-07-10T07:12:44Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +122,126 @@    case CaseWhen(branches, elseVale) =>\n      CaseWhen(branches.map(br => (br._1, normalize(br._2))), elseVale.map(normalize))\n\n    case Coalesce(children) =>\n      Coalesce(children.map(normalize))"
  },
  {
    "id" : "d4ef63f3-725c-4d72-aa8f-c3325c6241af",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446915037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Although a `cond` is `boolean` typed expression. I'm wondering what happens when we have a deeper expression at `cond`. Maybe, `normalize(cond)` is required here?",
        "createdAt" : "2020-07-12T20:57:58Z",
        "updatedAt" : "2020-07-12T20:58:19Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "75a5236e-108c-4adc-90b2-96c40e142407",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Based on the doc of `NormalizeFloatingNumbers`, we handle that well during comparison. So the boolean condition is okay. We need normalize `trueValue` and `falseValue` because they could be passed through up to binary format in grouping/join/window partition.",
        "createdAt" : "2020-07-12T21:36:38Z",
        "updatedAt" : "2020-07-12T21:36:38Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "2dda36b9-2069-4df1-bc8c-3ff1268fcbe4",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "What happen when we have `If(If(If(cond, trueValue1, falseValue1), trueValue2, falseValue2), trueValue3, falseValue3)`? We don't need to invoke `normalize` at `trueValue1~2` and `falseValue1~2`?",
        "createdAt" : "2020-07-12T21:48:28Z",
        "updatedAt" : "2020-07-12T21:48:28Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "d527ffbf-4f44-43e9-8fb9-edd8848773de",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I think we only need to have normalization on `trueValue3` and `falseValue3`, as they are the only results passing through the top-level `If`. The inner `If`s are evaluated during executing the top-level `If`. ",
        "createdAt" : "2020-07-12T21:57:09Z",
        "updatedAt" : "2020-07-12T21:57:09Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "69582aed-8dc3-4628-9f15-128b34c9fcaa",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Got it. I was confused a little. Thank you, @viirya .",
        "createdAt" : "2020-07-12T22:33:54Z",
        "updatedAt" : "2020-07-12T22:33:54Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +117,121 @@      CreateMap(children.map(normalize), useStringTypeWhenEmpty)\n\n    case If(cond, trueValue, falseValue) =>\n      If(cond, normalize(trueValue), normalize(falseValue))\n"
  },
  {
    "id" : "6eb52509-874b-48c0-a96b-20400e7cae6f",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-447371359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d650f43a-22f8-4920-b746-5c2b80db36b2",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Shall we put these new cases after this case? The main goal of this optimization is to avoid constructing a new `CreateStruct` during normalization. If it's just a float/double type If/CashWhen/Coalesce, it's actually an overhead to duplicate the normalization work in each child.",
        "createdAt" : "2020-07-13T06:26:34Z",
        "updatedAt" : "2020-07-13T06:26:34Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7203c266-bbde-4cfb-8783-c8f98490f9b3",
        "parentId" : "d650f43a-22f8-4920-b746-5c2b80db36b2",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Okay.",
        "createdAt" : "2020-07-13T15:41:23Z",
        "updatedAt" : "2020-07-13T15:41:23Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +126,130 @@      Coalesce(children.map(normalize))\n\n    case _ if expr.dataType == FloatType || expr.dataType == DoubleType =>\n      KnownFloatingPointNormalized(NormalizeNaNAndZero(expr))\n"
  },
  {
    "id" : "37965348-1870-410d-9161-d0ed16ba6fe3",
    "prId" : 28785,
    "prUrl" : "https://github.com/apache/spark/pull/28785#pullrequestreview-428628883",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Does it also mean `This batch must be executed after the `RewriteSubquery` batch, which creates joins.` is not definitely true now?",
        "createdAt" : "2020-06-11T06:27:58Z",
        "updatedAt" : "2020-06-11T06:27:58Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "77865267-a30a-4715-8425-387017b3a85f",
        "parentId" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "it's still true, the correlated subquery becomes join, and may have new join keys.",
        "createdAt" : "2020-06-11T06:30:21Z",
        "updatedAt" : "2020-06-11T06:31:19Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ac913299-94e3-45e1-8c95-33d7e91c5364",
        "parentId" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I see. Makes sense.",
        "createdAt" : "2020-06-11T06:37:01Z",
        "updatedAt" : "2020-06-11T06:37:01Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4dc641393de0458b3fe4cfa980c8a8b2c3327ea0",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +54,58 @@ * new joins(the subquery rewrite) and new join conditions(the join reorder).\n */\nobject NormalizeFloatingNumbers extends Rule[LogicalPlan] {\n\n  def apply(plan: LogicalPlan): LogicalPlan = plan match {"
  },
  {
    "id" : "61741870-0293-42f5-9e84-0765dca01c3f",
    "prId" : 25080,
    "prUrl" : "https://github.com/apache/spark/pull/25080#pullrequestreview-259790989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "382c0e50-a35f-4bb2-aca0-58a11fab52e4",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Hm, from my understanding, we didn't quite like such approach though like analysis barrier. Scope here is small so might be fine but this doesn't particularly look like a good fix. ",
        "createdAt" : "2019-07-09T03:30:22Z",
        "updatedAt" : "2019-07-09T06:27:48Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "0f5479f5-9d87-4ad7-bde7-f6d97242a374",
        "parentId" : "382c0e50-a35f-4bb2-aca0-58a11fab52e4",
        "authorId" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "body" : "The problem is from `TransformArray`, since we can't easily tell whether a `TransformArray` is for FP normalization or not.  Otherwise we can just check for `NormalizeNaNAndZero`.",
        "createdAt" : "2019-07-09T03:38:46Z",
        "updatedAt" : "2019-07-09T06:27:48Z",
        "lastEditedBy" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "tags" : [
        ]
      },
      {
        "id" : "93116392-a7a4-4b3b-9041-c9e4cb3c5bdb",
        "parentId" : "382c0e50-a35f-4bb2-aca0-58a11fab52e4",
        "authorId" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "body" : "And we don't want to add a new kind of `TransformArray` node in the final logical plan either (and related logic)... I can't really think of an elegant approach.",
        "createdAt" : "2019-07-09T03:42:20Z",
        "updatedAt" : "2019-07-09T06:27:48Z",
        "lastEditedBy" : "88f0c774-9c59-4485-885d-f6aee36efcea",
        "tags" : [
        ]
      },
      {
        "id" : "58ef9f4c-ec17-4be9-8452-6eba994571a9",
        "parentId" : "382c0e50-a35f-4bb2-aca0-58a11fab52e4",
        "authorId" : "3a12ce0f-9e73-4cfb-a4b4-b19368cddc2f",
        "body" : "This has a much less impact than the `AnalysisBarrier` -- this only applies to expressions whereas the `AnalysisBarrier` applied to plans.\r\nWe'd to leave markers in place in case a plan gets re-optimized after the initial optimization, and we have to have something that provides such information persisted in the plan.\r\n\r\nThe alternative for providing this information would be something like having a new dedicated expression type for floating point array normalization, which would also be disruptive to the expression tree structure. In terms of code reuse and semantic clarity, I'd say Yesheng's current design strikes the best balance.",
        "createdAt" : "2019-07-09T22:26:56Z",
        "updatedAt" : "2019-07-09T22:26:57Z",
        "lastEditedBy" : "3a12ce0f-9e73-4cfb-a4b4-b19368cddc2f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f255c8ed5f22fa10acdf12994867303596ee696e",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +125,129 @@\n    case _ if expr.dataType == FloatType || expr.dataType == DoubleType =>\n      KnownFloatingPointNormalized(NormalizeNaNAndZero(expr))\n\n    case _ if expr.dataType.isInstanceOf[StructType] =>"
  }
]