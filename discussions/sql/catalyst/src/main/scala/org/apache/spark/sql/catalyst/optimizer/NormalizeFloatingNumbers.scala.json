[
  {
    "id" : "b6817684-0604-4db5-bf27-6d6de8d19d72",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547337123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Not sure, can this just be a `def`?",
        "createdAt" : "2020-12-08T14:50:31Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "4dbe1a04-c16a-4a28-9a6b-42c8b5e355dc",
        "parentId" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is stateless and being a val is more efficient.",
        "createdAt" : "2020-12-08T15:20:15Z",
        "updatedAt" : "2020-12-08T15:20:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +145,149 @@  }\n\n  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {"
  },
  {
    "id" : "39787c7b-69a7-48ae-9cfc-a273b7df7f8f",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547338490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I think this check isn't necessary, as NaN won't equal -0.0f, so it will be returned on line 154 anyway. Or am I missing that there are different NaNs and this is normalizing them too?",
        "createdAt" : "2020-12-08T14:51:14Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "476538aa-f1c0-4888-9524-a9c49a75c176",
        "parentId" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is copied from the existing code. NaN is not a single value and we need to make sure all NaN values have the same binary representation in Spark unsafe row.",
        "createdAt" : "2020-12-08T15:21:37Z",
        "updatedAt" : "2020-12-08T15:21:37Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +147,151 @@  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {\n      Float.NaN\n    } else if (f == -0.0f) {"
  },
  {
    "id" : "ca177c2a-0a1e-4a5c-84c5-0cce880840c2",
    "prId" : 29780,
    "prUrl" : "https://github.com/apache/spark/pull/29780#pullrequestreview-491192739",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Looks logically fine but just to confirm that I understood correctly, it's just a cleanup fix to match the column names, right? and doesn't affect the final output?",
        "createdAt" : "2020-09-18T04:38:11Z",
        "updatedAt" : "2020-09-18T04:38:11Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "672c0590-4423-46ff-a394-33c8d08bfb6e",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Yea I think so. `CreateNamedStruct` allows you to specify the name for each field.",
        "createdAt" : "2020-09-18T04:48:48Z",
        "updatedAt" : "2020-09-18T04:48:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "498e4aee-8dee-4264-bfa4-3f374030e3f1",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Yeah, you're right and this is not an user-facing bug. When writing code to check paln integrity for `SparkPlan`s, I found this issue; canonicalized attributes between final/partial `HaashAggregate`s were not equal incorrectly because of this issue (schema mismatch).",
        "createdAt" : "2020-09-18T06:49:10Z",
        "updatedAt" : "2020-09-18T06:49:10Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bf4f32924df6a3a06623dfcd2e06b6749c6ebad",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +133,137 @@        case (name, i) => Seq(Literal(name), normalize(GetStructField(expr, i)))\n      }\n      val struct = CreateNamedStruct(fields.flatten.toSeq)\n      KnownFloatingPointNormalized(If(IsNull(expr), Literal(null, struct.dataType), struct))\n"
  },
  {
    "id" : "36cca190-f2a0-47c2-a5b5-f0f952c9c451",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446097391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09239699-c40f-49ce-97b9-09dafaa22fd9",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Could you narrow-down the PR title? For example, instead of `certain children expressions`, you can mention `IF` and `CaseWhen` specifically because this PR only handles those two.",
        "createdAt" : "2020-07-10T03:14:08Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "006ff1eb-4683-4362-b182-89f9df0ce143",
        "parentId" : "09239699-c40f-49ce-97b9-09dafaa22fd9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Updated. Thanks for the suggestion.",
        "createdAt" : "2020-07-10T03:20:07Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +120,124 @@      If(cond, normalize(trueValue), normalize(falseValue))\n\n    case CaseWhen(branches, elseVale) =>\n      CaseWhen(branches.map(br => (br._1, normalize(br._2))), elseVale.map(normalize))\n"
  },
  {
    "id" : "f314d091-e8c7-4713-9cbf-25c21b6b337d",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446171461",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b30289ca-67cf-48d1-9b46-0e65f1c39a49",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "shall we consider more pass-through expressions? like `Coalesce`?",
        "createdAt" : "2020-07-10T06:59:16Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "c3dc9900-099b-411b-bcf6-c54e2e2b754b",
        "parentId" : "b30289ca-67cf-48d1-9b46-0e65f1c39a49",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Okay.",
        "createdAt" : "2020-07-10T07:12:44Z",
        "updatedAt" : "2020-07-12T16:07:08Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +122,126 @@    case CaseWhen(branches, elseVale) =>\n      CaseWhen(branches.map(br => (br._1, normalize(br._2))), elseVale.map(normalize))\n\n    case Coalesce(children) =>\n      Coalesce(children.map(normalize))"
  },
  {
    "id" : "d4ef63f3-725c-4d72-aa8f-c3325c6241af",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-446915037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Although a `cond` is `boolean` typed expression. I'm wondering what happens when we have a deeper expression at `cond`. Maybe, `normalize(cond)` is required here?",
        "createdAt" : "2020-07-12T20:57:58Z",
        "updatedAt" : "2020-07-12T20:58:19Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "75a5236e-108c-4adc-90b2-96c40e142407",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Based on the doc of `NormalizeFloatingNumbers`, we handle that well during comparison. So the boolean condition is okay. We need normalize `trueValue` and `falseValue` because they could be passed through up to binary format in grouping/join/window partition.",
        "createdAt" : "2020-07-12T21:36:38Z",
        "updatedAt" : "2020-07-12T21:36:38Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "2dda36b9-2069-4df1-bc8c-3ff1268fcbe4",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "What happen when we have `If(If(If(cond, trueValue1, falseValue1), trueValue2, falseValue2), trueValue3, falseValue3)`? We don't need to invoke `normalize` at `trueValue1~2` and `falseValue1~2`?",
        "createdAt" : "2020-07-12T21:48:28Z",
        "updatedAt" : "2020-07-12T21:48:28Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "d527ffbf-4f44-43e9-8fb9-edd8848773de",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I think we only need to have normalization on `trueValue3` and `falseValue3`, as they are the only results passing through the top-level `If`. The inner `If`s are evaluated during executing the top-level `If`. ",
        "createdAt" : "2020-07-12T21:57:09Z",
        "updatedAt" : "2020-07-12T21:57:09Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "69582aed-8dc3-4628-9f15-128b34c9fcaa",
        "parentId" : "2af23aa2-9b97-4567-92ba-5cd0be53bde9",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Got it. I was confused a little. Thank you, @viirya .",
        "createdAt" : "2020-07-12T22:33:54Z",
        "updatedAt" : "2020-07-12T22:33:54Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +117,121 @@      CreateMap(children.map(normalize), useStringTypeWhenEmpty)\n\n    case If(cond, trueValue, falseValue) =>\n      If(cond, normalize(trueValue), normalize(falseValue))\n"
  },
  {
    "id" : "6eb52509-874b-48c0-a96b-20400e7cae6f",
    "prId" : 29061,
    "prUrl" : "https://github.com/apache/spark/pull/29061#pullrequestreview-447371359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d650f43a-22f8-4920-b746-5c2b80db36b2",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Shall we put these new cases after this case? The main goal of this optimization is to avoid constructing a new `CreateStruct` during normalization. If it's just a float/double type If/CashWhen/Coalesce, it's actually an overhead to duplicate the normalization work in each child.",
        "createdAt" : "2020-07-13T06:26:34Z",
        "updatedAt" : "2020-07-13T06:26:34Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7203c266-bbde-4cfb-8783-c8f98490f9b3",
        "parentId" : "d650f43a-22f8-4920-b746-5c2b80db36b2",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Okay.",
        "createdAt" : "2020-07-13T15:41:23Z",
        "updatedAt" : "2020-07-13T15:41:23Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5dce7cdf7b5658687533b6ee5bbb76e0490a383",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +126,130 @@      Coalesce(children.map(normalize))\n\n    case _ if expr.dataType == FloatType || expr.dataType == DoubleType =>\n      KnownFloatingPointNormalized(NormalizeNaNAndZero(expr))\n"
  },
  {
    "id" : "37965348-1870-410d-9161-d0ed16ba6fe3",
    "prId" : 28785,
    "prUrl" : "https://github.com/apache/spark/pull/28785#pullrequestreview-428628883",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Does it also mean `This batch must be executed after the `RewriteSubquery` batch, which creates joins.` is not definitely true now?",
        "createdAt" : "2020-06-11T06:27:58Z",
        "updatedAt" : "2020-06-11T06:27:58Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "77865267-a30a-4715-8425-387017b3a85f",
        "parentId" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "it's still true, the correlated subquery becomes join, and may have new join keys.",
        "createdAt" : "2020-06-11T06:30:21Z",
        "updatedAt" : "2020-06-11T06:31:19Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ac913299-94e3-45e1-8c95-33d7e91c5364",
        "parentId" : "0f15a5b7-d0c1-47de-9811-1c16b1c0d18e",
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "I see. Makes sense.",
        "createdAt" : "2020-06-11T06:37:01Z",
        "updatedAt" : "2020-06-11T06:37:01Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4dc641393de0458b3fe4cfa980c8a8b2c3327ea0",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +54,58 @@ * new joins(the subquery rewrite) and new join conditions(the join reorder).\n */\nobject NormalizeFloatingNumbers extends Rule[LogicalPlan] {\n\n  def apply(plan: LogicalPlan): LogicalPlan = plan match {"
  }
]