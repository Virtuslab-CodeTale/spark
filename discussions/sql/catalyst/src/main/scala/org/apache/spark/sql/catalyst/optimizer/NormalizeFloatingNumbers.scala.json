[
  {
    "id" : "b6817684-0604-4db5-bf27-6d6de8d19d72",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547337123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Not sure, can this just be a `def`?",
        "createdAt" : "2020-12-08T14:50:31Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "4dbe1a04-c16a-4a28-9a6b-42c8b5e355dc",
        "parentId" : "096ae785-fe3b-4ee1-a4bf-088b2d9b038f",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is stateless and being a val is more efficient.",
        "createdAt" : "2020-12-08T15:20:15Z",
        "updatedAt" : "2020-12-08T15:20:15Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +145,149 @@  }\n\n  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {"
  },
  {
    "id" : "39787c7b-69a7-48ae-9cfc-a273b7df7f8f",
    "prId" : 30673,
    "prUrl" : "https://github.com/apache/spark/pull/30673#pullrequestreview-547338490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I think this check isn't necessary, as NaN won't equal -0.0f, so it will be returned on line 154 anyway. Or am I missing that there are different NaNs and this is normalizing them too?",
        "createdAt" : "2020-12-08T14:51:14Z",
        "updatedAt" : "2020-12-08T14:51:27Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "476538aa-f1c0-4888-9524-a9c49a75c176",
        "parentId" : "3a64a59f-e6b0-4646-90d7-21836e681d9b",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "This is copied from the existing code. NaN is not a single value and we need to make sure all NaN values have the same binary representation in Spark unsafe row.",
        "createdAt" : "2020-12-08T15:21:37Z",
        "updatedAt" : "2020-12-08T15:21:37Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "291e652db6e06c1fd6f69a96e2e1ebf1c7d8e90c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +147,151 @@  val FLOAT_NORMALIZER: Any => Any = (input: Any) => {\n    val f = input.asInstanceOf[Float]\n    if (f.isNaN) {\n      Float.NaN\n    } else if (f == -0.0f) {"
  },
  {
    "id" : "ca177c2a-0a1e-4a5c-84c5-0cce880840c2",
    "prId" : 29780,
    "prUrl" : "https://github.com/apache/spark/pull/29780#pullrequestreview-491192739",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Looks logically fine but just to confirm that I understood correctly, it's just a cleanup fix to match the column names, right? and doesn't affect the final output?",
        "createdAt" : "2020-09-18T04:38:11Z",
        "updatedAt" : "2020-09-18T04:38:11Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "672c0590-4423-46ff-a394-33c8d08bfb6e",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Yea I think so. `CreateNamedStruct` allows you to specify the name for each field.",
        "createdAt" : "2020-09-18T04:48:48Z",
        "updatedAt" : "2020-09-18T04:48:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "498e4aee-8dee-4264-bfa4-3f374030e3f1",
        "parentId" : "e792213f-479a-40e3-a2ba-6f1ff0ebfc99",
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Yeah, you're right and this is not an user-facing bug. When writing code to check paln integrity for `SparkPlan`s, I found this issue; canonicalized attributes between final/partial `HaashAggregate`s were not equal incorrectly because of this issue (schema mismatch).",
        "createdAt" : "2020-09-18T06:49:10Z",
        "updatedAt" : "2020-09-18T06:49:10Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bf4f32924df6a3a06623dfcd2e06b6749c6ebad",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +133,137 @@        case (name, i) => Seq(Literal(name), normalize(GetStructField(expr, i)))\n      }\n      val struct = CreateNamedStruct(fields.flatten.toSeq)\n      KnownFloatingPointNormalized(If(IsNull(expr), Literal(null, struct.dataType), struct))\n"
  }
]