[
  {
    "id" : "e25b838b-c8b3-47fa-be9a-ef6918ccbb2e",
    "prId" : 33070,
    "prUrl" : "https://github.com/apache/spark/pull/33070#pullrequestreview-704745765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d573b8aa-1fd2-46f8-8425-df46176a04f1",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "what if we don't call `.newInstance()`?",
        "createdAt" : "2021-07-08T17:53:44Z",
        "updatedAt" : "2021-07-08T17:53:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "cb9362ec-c17d-4e3c-aabc-2fb6d4f7c88a",
        "parentId" : "d573b8aa-1fd2-46f8-8425-df46176a04f1",
        "authorId" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "body" : "Because we are reusing the `a`'s exprId when constructing the alias, we would have the same `exprId` referencing two different expressions if not using `.newInstance()`. Another option is to use a new exprId for the Alias, but it requires updating parent nodes.\r\n```\r\nAlias(If(IsNull(alwaysTrueRef), default, ref), a.name)(a.exprId)\r\n```\r\n\r\n",
        "createdAt" : "2021-07-09T00:28:06Z",
        "updatedAt" : "2021-07-09T00:28:06Z",
        "lastEditedBy" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "tags" : [
        ]
      },
      {
        "id" : "3aa925b8-9c4f-48de-a8c9-c06992572e1b",
        "parentId" : "d573b8aa-1fd2-46f8-8425-df46176a04f1",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Got it.\r\n\r\nI think the assumption here is `a` must be an alias. If `a` is an attribute, then `a.newInstance()` will create a new attribute that refers to nothing and breaks the query. Can we add an assert?\r\n```\r\nassert(a.isInstanceOf[Alias])\r\nval newAlias = a.newInstance()\r\n...\r\n```",
        "createdAt" : "2021-07-09T08:02:35Z",
        "updatedAt" : "2021-07-09T08:02:35Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "8a8418db-6c0c-41ac-ae80-a555eaa3fc51",
        "parentId" : "d573b8aa-1fd2-46f8-8425-df46176a04f1",
        "authorId" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "body" : "Yes this holds because if `a` is an attribute, evaluating it with zero tuples will yield null:\r\nhttps://github.com/apache/spark/blob/c46342e3d057bcc949b4caf016514ff05e0a1ebd/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/subquery.scala#L407\r\nAnother possibility is OuterReference. Let me verify if outer works in this case. <- OuterReferences should already be replaced using the outer reference map. So the only possibility is Alias.",
        "createdAt" : "2021-07-13T05:00:45Z",
        "updatedAt" : "2021-07-13T06:32:19Z",
        "lastEditedBy" : "b3ba992a-312c-46eb-b3c3-8d861d15ac40",
        "tags" : [
        ]
      }
    ],
    "commit" : "6404affe712161655d4740990222de7656a5fa83",
    "line" : 223,
    "diffHunk" : "@@ -1,1 +521,525 @@                    assert(a.isInstanceOf[Alias], s\"Cannot have non-aliased expression $a in \" +\n                      s\"aggregate that evaluates to non-null value with zero tuples.\")\n                    val newAttr = a.newInstance()\n                    val ref = newAttr.toAttribute.withNullability(true)\n                    expressions += newAttr"
  },
  {
    "id" : "5fce681b-ed6c-4acb-9698-cbbf37a1c36f",
    "prId" : 32072,
    "prUrl" : "https://github.com/apache/spark/pull/32072#pullrequestreview-639528862",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa5876c4-013f-446f-821a-02cfdf2ccc0a",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "nit: `in the inner query` -> `the inner query`. the line above ends with `in`",
        "createdAt" : "2021-04-20T05:45:57Z",
        "updatedAt" : "2021-04-20T05:45:58Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "16281d8d-3db8-4370-a852-72f5b9442ca5",
        "parentId" : "fa5876c4-013f-446f-821a-02cfdf2ccc0a",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "We can address this typo in the next PR.",
        "createdAt" : "2021-04-20T05:55:41Z",
        "updatedAt" : "2021-04-20T05:55:41Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "f665a0d52953ea7927d0d5dee7f4742255173691",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +30,34 @@ * A correlated subquery can be viewed as a \"dependent\" nested loop join between the outer and\n * the inner query. For each row produced by the outer query, we bind the [[OuterReference]]s in\n * in the inner query with the corresponding values in the row, and then evaluate the inner query.\n *\n * Dependent Join"
  }
]