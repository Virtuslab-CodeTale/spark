[
  {
    "id" : "7bab03ae-1ab7-4c65-8905-cee3899bc19e",
    "prId" : 24331,
    "prUrl" : "https://github.com/apache/spark/pull/24331#pullrequestreview-225835657",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e1cecae-5310-4e01-a3fd-edf77d1a31f6",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "when can this happen?",
        "createdAt" : "2019-04-11T12:11:29Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "6e3c7d64-18d6-496e-9d11-36877ae18a19",
        "parentId" : "8e1cecae-5310-4e01-a3fd-edf77d1a31f6",
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan When we decide that we can't pushdown the parent join. For example this [test](https://github.com/apache/spark/pull/24331/files#diff-22926b689dfba1ee84b9c35601990e81R380) should exercise the default case.",
        "createdAt" : "2019-04-11T23:04:55Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +257,261 @@          Join(childLeft, newRight, childJoinType, childCondition, childHint)\n        case _ =>\n          // Do nothing\n          j\n      }"
  },
  {
    "id" : "0c4821c2-67c0-43dd-9391-e918e1476131",
    "prId" : 24331,
    "prUrl" : "https://github.com/apache/spark/pull/24331#pullrequestreview-226779203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e4595af-7a55-4b88-9e5c-bf72e62d7136",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "why can't we push to both legs if it's inner join?",
        "createdAt" : "2019-04-15T16:57:04Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "ed8f18fe-038f-4a45-8c01-4a63fb30e61d",
        "parentId" : "0e4595af-7a55-4b88-9e5c-bf72e62d7136",
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan Perhaps its possible. In this PR, i was focusing on what is happening today in `PushPredicateThroughJoin` and keep the behaviour same. We can look into improving both this rule and `PushPredicateThroughJoin` as follow-up. The reason i say it is, probably we need to test more and prove that pushdown to both sides don't create any side effects or can cause wrong results ?",
        "createdAt" : "2019-04-15T17:24:28Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +223,227 @@      /**\n       * When the join condition is empty,\n       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n       *    to the left leg of join.\n       * 2) if a right outer join, to the right leg of join,"
  },
  {
    "id" : "5bae9855-d428-4a85-bc01-461433b7a0c2",
    "prId" : 24331,
    "prUrl" : "https://github.com/apache/spark/pull/24331#pullrequestreview-226779753",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad731392-7e46-419d-82f9-dca3702bd71e",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "what if `commonConditions` is not empty? can we add a filter at top?",
        "createdAt" : "2019-04-15T17:00:01Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "23488f86-8a2a-4c14-a7a2-89f03fc40c25",
        "parentId" : "ad731392-7e46-419d-82f9-dca3702bd71e",
        "authorId" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "body" : "@cloud-fan Please refer to my answer above.",
        "createdAt" : "2019-04-15T17:25:38Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "a2fcc15e-a51a-42f0-87a6-137048a28e30",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +213,217 @@        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n        PushdownDirection.TO_LEFT_BRANCH\n      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n        // When the join conditions can be computed based on the attributes from right leg of\n        // leftsemi/anti join then push the leftsemi/anti join to the right side."
  },
  {
    "id" : "b26962b7-e6a2-4c3a-94f3-96d309eca1f7",
    "prId" : 24331,
    "prUrl" : "https://github.com/apache/spark/pull/24331#pullrequestreview-227132928",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "900609c7-4a89-4b86-8c5f-6bc435f297cd",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "since we can only push down left semi/anti join to either left or right side, there is no need to return the new join condition in this method, because the join condition won't change.",
        "createdAt" : "2019-04-16T11:24:59Z",
        "updatedAt" : "2019-04-17T04:23:26Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +196,200 @@   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n   */\n  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n    val left = leftChild.left\n    val right = leftChild.right"
  }
]