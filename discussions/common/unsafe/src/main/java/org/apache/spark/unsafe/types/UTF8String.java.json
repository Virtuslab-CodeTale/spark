[
  {
    "id" : "9988f6b3-78dd-4ff0-90d2-7488bfd0c0ef",
    "prId" : 28937,
    "prUrl" : "https://github.com/apache/spark/pull/28937#pullrequestreview-439760538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5911c5b7-61b1-4043-99db-13d3482f4cc1",
        "parentId" : null,
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "What happens if `len = 10` and `pos = Integer.MIN_VALUE`. I guess that `start` would have an incorrect value.",
        "createdAt" : "2020-06-28T06:41:43Z",
        "updatedAt" : "2020-06-28T07:23:38Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      },
      {
        "id" : "191d12bc-b00a-44c3-9880-6422ef644132",
        "parentId" : "5911c5b7-61b1-4043-99db-13d3482f4cc1",
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "The negative `pos` here `refers to the -ith element before the end of the sequence`, so if pos = Integer.MIN_VALUE, then the start should be `pos + len`. The final result of `EMPTY_UTF8` will be returned by `substring` when its param start and until are both negative. I also added a UT in 4dcfe81.",
        "createdAt" : "2020-06-28T07:32:52Z",
        "updatedAt" : "2020-06-28T07:32:52Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      },
      {
        "id" : "cd9a4e64-6568-4963-8169-78a6889c77d5",
        "parentId" : "5911c5b7-61b1-4043-99db-13d3482f4cc1",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "I made misunderstaning. Thank you for clarification and adding a test.",
        "createdAt" : "2020-06-28T10:24:46Z",
        "updatedAt" : "2020-06-28T10:24:46Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      },
      {
        "id" : "1b16a2ca-9470-48da-b915-91ae1bdfa973",
        "parentId" : "5911c5b7-61b1-4043-99db-13d3482f4cc1",
        "authorId" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "body" : "Thanks for reviewing!",
        "createdAt" : "2020-06-30T07:55:05Z",
        "updatedAt" : "2020-06-30T07:55:05Z",
        "lastEditedBy" : "cd38bd5a-0fae-4d8e-8acd-36dc13753759",
        "tags" : [
        ]
      }
    ],
    "commit" : "4dcfe814d319ef9f04c9148bf9c82a9df191ac8c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +342,346 @@    // refers to the first element.\n    int len = numChars();\n    // `len + pos` does not overflow as `len >= 0`.\n    int start = (pos > 0) ? pos -1 : ((pos < 0) ? len + pos : 0);\n"
  },
  {
    "id" : "9d8b881f-8a62-48ed-85e3-30543b38ae33",
    "prId" : 26933,
    "prUrl" : "https://github.com/apache/spark/pull/26933#pullrequestreview-338676546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb424b64-45f3-493a-adb2-ced253ecf244",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "I thought we decided to call `toLong` in `toLongExact`?",
        "createdAt" : "2020-01-06T14:18:41Z",
        "updatedAt" : "2020-01-08T13:27:44Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "e8daf8e9-2fe3-4ddd-857d-256a1f723815",
        "parentId" : "cb424b64-45f3-493a-adb2-ced253ecf244",
        "authorId" : "832e1988-205f-40f9-89d5-c37ea16224c9",
        "body" : "Oh. I misunderstood. I will update the code in a bit.",
        "createdAt" : "2020-01-06T14:23:51Z",
        "updatedAt" : "2020-01-08T13:27:44Z",
        "lastEditedBy" : "832e1988-205f-40f9-89d5-c37ea16224c9",
        "tags" : [
        ]
      },
      {
        "id" : "ede5ead9-9cab-4e27-ae00-1bec10fd7156",
        "parentId" : "cb424b64-45f3-493a-adb2-ced253ecf244",
        "authorId" : "832e1988-205f-40f9-89d5-c37ea16224c9",
        "body" : "@cloud-fan I have updated the code.",
        "createdAt" : "2020-01-06T14:36:50Z",
        "updatedAt" : "2020-01-08T13:27:44Z",
        "lastEditedBy" : "832e1988-205f-40f9-89d5-c37ea16224c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0cb4edc3a42badfff3f2ecca7b2ec468ad0f0c2d",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1301,1305 @@   * NumberFormatException  is thrown.\n   */\n  public long toLongExact() {\n    LongWrapper result = new LongWrapper();\n    if (toLong(result)) {"
  },
  {
    "id" : "68df2d1d-dfd4-4839-8ce7-28a9b8331b34",
    "prId" : 26626,
    "prUrl" : "https://github.com/apache/spark/pull/26626#pullrequestreview-321311076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9eefe057-90bb-4b05-bcfe-8bcf3ad64afc",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Interesting, so SQL trim just removes space, and java.lang.String.trim() removes everything <= 32. Maybe we could refer to that in this doc, that this is the purpose of this additional trim method.",
        "createdAt" : "2019-11-21T12:52:40Z",
        "updatedAt" : "2019-11-22T14:08:45Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "dfabfaf8-4774-415a-b7f0-0c18b3f8b635",
        "parentId" : "9eefe057-90bb-4b05-bcfe-8bcf3ad64afc",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "yea, let's mention it's the same as ` java.lang.String.trim`",
        "createdAt" : "2019-11-22T02:54:12Z",
        "updatedAt" : "2019-11-22T14:08:45Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cd5433a3058305d53ca6557e2d48a93f182d24d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +555,559 @@\n  /**\n   * Trims whitespaces (<= ASCII 32) from both ends of this string.\n   *\n   * Note that, this method is the same as java's {@link String#trim}, and different from"
  },
  {
    "id" : "e3d9b3d8-04b4-4195-ac4c-6c415bb90dd7",
    "prId" : 26622,
    "prUrl" : "https://github.com/apache/spark/pull/26622#pullrequestreview-320727451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "014655d0-ff2a-4f9e-a413-7650b4b2ef2c",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "let's not make this method has side effect. We should only change the local variable `offset` inside this method.",
        "createdAt" : "2019-11-21T08:59:15Z",
        "updatedAt" : "2019-11-22T06:18:06Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "3a03dfe9-1b25-4f50-9582-b4d0eb65615e",
        "parentId" : "014655d0-ff2a-4f9e-a413-7650b4b2ef2c",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "Do you mean copy this insideTrim logic here?",
        "createdAt" : "2019-11-21T09:01:05Z",
        "updatedAt" : "2019-11-22T06:18:06Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      },
      {
        "id" : "8f1a0985-b8e0-4d98-b28c-2b0c30d8a7de",
        "parentId" : "014655d0-ff2a-4f9e-a413-7650b4b2ef2c",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "I will make them method local",
        "createdAt" : "2019-11-21T09:06:25Z",
        "updatedAt" : "2019-11-22T06:18:06Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5c2a40b5bcbb095dca811b568255c5f30539fe7",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1077,1081 @@   * @return true if the parsing was successful else false\n   */\n  public boolean toLong(LongWrapper toLongResult) {\n    int offset = 0;\n    while (offset < this.numBytes && getByte(offset) <= ' ') offset++;"
  },
  {
    "id" : "bb538e72-25f5-43cb-8ca7-ac1e68945d66",
    "prId" : 26622,
    "prUrl" : "https://github.com/apache/spark/pull/26622#pullrequestreview-321361215",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8608f01d-2a7d-4f8b-b7c5-691ef7cfdc6b",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "You don't need to trim from the right explicitly here. Just break inside the loop https://github.com/apache/spark/pull/26622/files#diff-d2b5337b91f684b9e7fd5cc101e93fc8R1104 if b == ' '",
        "createdAt" : "2019-11-22T06:23:24Z",
        "updatedAt" : "2019-11-22T06:23:29Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "15b39d03-31be-4b29-9c1b-dc73303b11b4",
        "parentId" : "8608f01d-2a7d-4f8b-b7c5-691ef7cfdc6b",
        "authorId" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "body" : "Hm, I guess not, how do you know the ' ' is in the middle or end?",
        "createdAt" : "2019-11-22T06:40:43Z",
        "updatedAt" : "2019-11-22T06:40:44Z",
        "lastEditedBy" : "c62ded40-3015-4888-8e91-d671d0f615be",
        "tags" : [
        ]
      },
      {
        "id" : "751ceded-9a36-4ffa-b3cc-ef3195c672e9",
        "parentId" : "8608f01d-2a7d-4f8b-b7c5-691ef7cfdc6b",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "I see",
        "createdAt" : "2019-11-22T06:54:56Z",
        "updatedAt" : "2019-11-22T06:54:56Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5c2a40b5bcbb095dca811b568255c5f30539fe7",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1083,1087 @@\n    int end = this.numBytes - 1;\n    while (end > offset && getByte(end) <= ' ') end--;\n\n    byte b = getByte(offset);"
  },
  {
    "id" : "74110a10-8f4c-46d7-95b3-8f2a19970455",
    "prId" : 26478,
    "prUrl" : "https://github.com/apache/spark/pull/26478#pullrequestreview-316228064",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I don't think it's correct to fix it here since the issue is specific to `lpad` expression. Can you check `lpad` in other DBMSes? I think we shouldn't just blindly follow Hive",
        "createdAt" : "2019-11-12T11:15:50Z",
        "updatedAt" : "2019-11-12T11:15:50Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "7cefc4ba-2faf-4a79-862b-780102f9a056",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "body" : "@HyukjinKwon, fine i will check this point.",
        "createdAt" : "2019-11-12T11:37:23Z",
        "updatedAt" : "2019-11-12T11:40:03Z",
        "lastEditedBy" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "tags" : [
        ]
      },
      {
        "id" : "b15f149a-ac57-4570-9325-d4f04fb773c6",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "body" : "@HyukjinKwon, I checked in other DBMSes , please check below DBMSES output for lpad and rpad :\r\n1. Mysql : rpad ('hi', 5, '') => NULL  and  lpad ('hi', 5, '') => NULL\r\n2. Hive : rpad ('hi', 5, '') => NULL  and  lpad ('hi', 5, '') => NULL\r\n3. Postgresql : rpad ('hi', 5, '') => hi  and  lpad ('hi', 5, '') => hi\r\n",
        "createdAt" : "2019-11-12T12:18:50Z",
        "updatedAt" : "2019-11-13T04:20:13Z",
        "lastEditedBy" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "tags" : [
        ]
      },
      {
        "id" : "2dbb68d5-612c-4548-8a0e-a2c42c5b6a02",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I think it's fine not to fix for now.",
        "createdAt" : "2019-11-13T04:32:14Z",
        "updatedAt" : "2019-11-13T04:32:15Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "149aa753-0009-47fa-af45-0dde22982b2c",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "body" : "@HyukjinKwon, but later we need fix ?",
        "createdAt" : "2019-11-13T10:44:00Z",
        "updatedAt" : "2019-11-13T10:44:09Z",
        "lastEditedBy" : "20b33833-5417-4c8d-b239-5c3a1f547ffe",
        "tags" : [
        ]
      },
      {
        "id" : "4a07ff8e-a979-4d87-afcf-5bf11eb154ca",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Current implementation is at least reasonable. If we should do, we could add a configuration to control the behaviour but to me it doesn't look worthy.",
        "createdAt" : "2019-11-13T11:07:46Z",
        "updatedAt" : "2019-11-13T11:07:47Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "2db073d6-c71f-4b36-b7c6-ecfde47692fe",
        "parentId" : "19926588-cb52-4ee3-963c-8d07d086057e",
        "authorId" : "22ab4837-e86a-4aa2-8ddb-dbc09e778c43",
        "body" : "But as per rpad/lpad definition 'In case of empty pad string, the return value is null.'  If we are not going to handle in 3.0 we can move to handle this in next version",
        "createdAt" : "2019-11-13T13:05:51Z",
        "updatedAt" : "2019-11-13T13:05:52Z",
        "lastEditedBy" : "22ab4837-e86a-4aa2-8ddb-dbc09e778c43",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1a659468d0d2f7fed85389dc33112e4de7bfc91",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +886,890 @@      // no padding at all, return the null\n      return null;\n    } else if (spaces <= 0) {\n      // no padding at all, return the substring of the current string\n      return substring(0, len);"
  },
  {
    "id" : "4adabf5d-8bcf-426a-9adb-bb6401c90418",
    "prId" : 24884,
    "prUrl" : "https://github.com/apache/spark/pull/24884#pullrequestreview-250240950",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2184aa4f-7d08-4e6b-8a9e-1c18fd2a89d5",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "Can you avoid copying by changing `offset` if the string contains spaces at the left side, and changing `numBytes` for spaces at the right side?",
        "createdAt" : "2019-06-16T15:29:26Z",
        "updatedAt" : "2019-06-17T02:18:38Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "10b0c1ab-c9d5-4b8a-a886-e39afa51718e",
        "parentId" : "2184aa4f-7d08-4e6b-8a9e-1c18fd2a89d5",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "It looks non-safe if the string is shared by others.",
        "createdAt" : "2019-06-16T15:54:58Z",
        "updatedAt" : "2019-06-17T02:18:38Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      },
      {
        "id" : "300d7453-fc10-4897-a2e9-8402270dafa1",
        "parentId" : "2184aa4f-7d08-4e6b-8a9e-1c18fd2a89d5",
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "I mean creating new instance of `UTF8String` by passing new value of `offset` or `numBytes`, and the same reference to `base`. Does `UTF8String` modify underlying base object somewhere in place?",
        "createdAt" : "2019-06-16T16:16:17Z",
        "updatedAt" : "2019-06-17T02:18:38Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "d2c5d5c4-b6cb-45a9-b031-696a937c188b",
        "parentId" : "2184aa4f-7d08-4e6b-8a9e-1c18fd2a89d5",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "I see. My interpretation of `avoid copying` was `to update fieild in this object`. It functionally works well.\r\n\r\nSuch an optimization was done in `String.substring` in [previous JDKs](http://java-performance.info/changes-to-string-java-1-7-0_06/).   \r\nPros:  Avoid copying characters when `trim()`\r\nCons: Cannot free a `UTF8String` object object even if the  `UTF8String` object, which was referenced by the `trim`ed `UTF8String`, is dead under the case that `trim`ed `UTF8String` is live.\r\n\r\nI think that the current implementation is preferable since it does not increase # of live `UTF8String` objects.\r\n",
        "createdAt" : "2019-06-16T16:40:15Z",
        "updatedAt" : "2019-06-17T02:18:38Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      },
      {
        "id" : "b9a8f5a4-da9b-46b0-8bde-7010ab493261",
        "parentId" : "2184aa4f-7d08-4e6b-8a9e-1c18fd2a89d5",
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "What you're describing is kind of how the JVM implements \"compressed strings\". Interesting notes here on further optimizations in Java 9: https://www.baeldung.com/java-9-compact-string\r\nOne day we might revisit whether UTF8String is improving over String!",
        "createdAt" : "2019-06-16T17:03:18Z",
        "updatedAt" : "2019-06-17T02:18:38Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      }
    ],
    "commit" : "81edf561309cae081d96e0171226c776314db90b",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +550,554 @@      return this;\n    }\n    return copyUTF8String(s, e);\n  }\n"
  },
  {
    "id" : "a8b13a64-ddfc-4ed5-9b1e-f993358a7b2e",
    "prId" : 24709,
    "prUrl" : "https://github.com/apache/spark/pull/24709#pullrequestreview-242336101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0dd59a1e-8d33-40f4-a7ad-563c49947df2",
        "parentId" : null,
        "authorId" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "body" : "It would be interesting to benchmark your implementation against to:\r\n```scala\r\nprivate static boolean isAscii(byte[] bytes) {\r\n    int length = bytes.length;\r\n    int s = 0;\r\n    for (int i = 0; i < length; i++) {\r\n      s |= bytes[i] & 0x80;\r\n    }\r\n    return s == 0;\r\n  }\r\n```\r\nIt doesn't have the problem of branch mispredictions. Maybe it will be faster in general case. ",
        "createdAt" : "2019-05-26T07:23:50Z",
        "updatedAt" : "2019-05-26T19:36:50Z",
        "lastEditedBy" : "5c8bf89e-8bb3-4151-8b92-286da26c827e",
        "tags" : [
        ]
      },
      {
        "id" : "87891f3a-d52e-45cb-8972-f8d9d3f58558",
        "parentId" : "0dd59a1e-8d33-40f4-a7ad-563c49947df2",
        "authorId" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "body" : "Good idea! I think we can go one step further and move the `& 0x80` out of the loop body and into the final `return` statement, shaving a couple of instructions out of the loop body.\r\n\r\nJust pushed a change implementing this.",
        "createdAt" : "2019-05-26T19:37:33Z",
        "updatedAt" : "2019-05-26T19:37:33Z",
        "lastEditedBy" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "tags" : [
        ]
      },
      {
        "id" : "95ea895f-c222-4e96-8f81-09a030e23dc2",
        "parentId" : "0dd59a1e-8d33-40f4-a7ad-563c49947df2",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "I think that the HW branch predictor can reduce misprediction since the direction is mostly the same. If we assume that ASCII case is dominant, the compiler optimizer may apply simdization.\r\n\r\nIf this code is faster than the original one, how about applying this to `isAscii(String str)`?",
        "createdAt" : "2019-05-27T16:01:46Z",
        "updatedAt" : "2019-05-27T16:01:46Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      }
    ],
    "commit" : "0aa284fd033794fa35696ea7778e68b8c505e547",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +180,184 @@   * Returns true if the given UTF8 bytes consist entirely of ASCII characters, false otherwise.\n   */\n  private static boolean isAscii(byte[] bytes) {\n    int length = bytes.length;\n    int s = 0;"
  },
  {
    "id" : "4737962e-f51a-4813-8e0f-773c0c0ae06b",
    "prId" : 24709,
    "prUrl" : "https://github.com/apache/spark/pull/24709#pullrequestreview-243032770",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdbb1cee-c87e-4d36-8161-04cb73d2696b",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I get that we might want to go off-road here and call a deprecated method, but does it help meaningfully? the benchmark doesn't have the resolution to determine it. Is it as fast to, maybe, pass US_ASCII as the charset in this case?",
        "createdAt" : "2019-05-26T18:40:33Z",
        "updatedAt" : "2019-05-26T19:36:50Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "f1615760-8bed-41e5-932c-433c714af3b4",
        "parentId" : "bdbb1cee-c87e-4d36-8161-04cb73d2696b",
        "authorId" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "body" : "That's a good question. I think it might be a little bit slower because the `US_ASCII` encoder needs to perform error-checking to validate whether the bytes are actually ASCII characters. That validation is probably cheap (just checking the sign / highest order bit of the byte) but it's still technically a bit more work.\r\n\r\nGood point about benchmark resolution, especially for short strings: I probably need to run more benchmark iterations for short strings to smooth out variation / noise.",
        "createdAt" : "2019-05-26T19:41:28Z",
        "updatedAt" : "2019-05-26T19:41:28Z",
        "lastEditedBy" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "tags" : [
        ]
      },
      {
        "id" : "253e7c3c-88cf-4068-bdcd-1e20129073c1",
        "parentId" : "bdbb1cee-c87e-4d36-8161-04cb73d2696b",
        "authorId" : "99156419-7ce7-4671-b858-d0b5c4711f88",
        "body" : "it does have to check all bytes though? isn't this grow linearly to the length of bytes?",
        "createdAt" : "2019-05-29T04:21:55Z",
        "updatedAt" : "2019-05-29T04:22:02Z",
        "lastEditedBy" : "99156419-7ce7-4671-b858-d0b5c4711f88",
        "tags" : [
        ]
      }
    ],
    "commit" : "0aa284fd033794fa35696ea7778e68b8c505e547",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +1269,1273 @@    // skips charset encoder and simply casts each byte into a char.\n    if (isAscii(bytes)) {\n      return new String(bytes, 0);\n    } else {\n      return new String(bytes, StandardCharsets.UTF_8);"
  },
  {
    "id" : "e56bfb62-a22a-4d36-90eb-899323db3e1e",
    "prId" : 24709,
    "prUrl" : "https://github.com/apache/spark/pull/24709#pullrequestreview-242327652",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcdc4d98-1963-480e-9e5a-d45fc4d651e6",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Can this be package private?",
        "createdAt" : "2019-05-26T18:40:41Z",
        "updatedAt" : "2019-05-26T19:36:50Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "5f642a2c-149a-461f-bc1d-eaca7371b173",
        "parentId" : "fcdc4d98-1963-480e-9e5a-d45fc4d651e6",
        "authorId" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "body" : "I don't think so: the benchmarks that I added are in a different package (because it's hard to depend on our benchmarks package from the `unsafe` package), so this needs to be public.",
        "createdAt" : "2019-05-26T19:45:31Z",
        "updatedAt" : "2019-05-26T19:45:31Z",
        "lastEditedBy" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "tags" : [
        ]
      },
      {
        "id" : "089e869e-6dc6-4f6c-861c-63466e9eb46c",
        "parentId" : "fcdc4d98-1963-480e-9e5a-d45fc4d651e6",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "Can we use `@VisibleForTesting` annotation?",
        "createdAt" : "2019-05-27T15:33:14Z",
        "updatedAt" : "2019-05-27T15:33:14Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      }
    ],
    "commit" : "0aa284fd033794fa35696ea7778e68b8c505e547",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +1278,1282 @@   * Pre-SPARK-27841 version of toString(), retained for benchmarking purposes.\n   */\n  public String toStringSlow() {\n    return new String(getBytes(), StandardCharsets.UTF_8);\n  }"
  },
  {
    "id" : "b52b1e1f-f230-4b85-ba7c-dee5156e9939",
    "prId" : 24707,
    "prUrl" : "https://github.com/apache/spark/pull/24707#pullrequestreview-242050900",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89590784-6d62-442f-bfa0-6e8fd2cf1fc9",
        "parentId" : null,
        "authorId" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "body" : "One consideration here: do we need to make a defensive copy? If so, we can't do this optimization.\r\n\r\nWhy might we need to copy a `UTF8String`? The `UTF8String` instance itself is effectively immutable, but the underlying storage might be a region of potentially-not-exclusively-owned memory (either direct/off-heap memory or a region of a `long[]` array), so we might need to perform a copy in case we're going to buffer / otherwise hold onto the `UTF8String` past a point where the underlying underlying storage memory could be mutated.\r\n\r\nI think the most common case to worry about would be a UTF8String which is backed by memory that is part of a larger `UnsafeRow`. If we're doing row-at-a-time processing and aren't holding onto this `UTF8String` across rows then I think we're ok since changes to rows' memory _during_ single-row processing would impact many parts of Spark and would probably be detected. In the few places where we _do_ hold references across evaluations / rows then we need to copy, but I suspect most places already do this: for example, see the `regexp.clone()` in the `RegExpReplace` expression.\r\n\r\nMy intuition is that we probably _don't_ need to make a defensive copy here because I doubt we have parts of the code which _specifically assume that `replace()` will copy_ (i.e. which are abusing `replace()` as a slow `clone()` mechanism). Put differently, I suspect that any code which would fail due to lack of copying in `replace()` is also vulnerable to this problem from other sources (including simply reading a string from a row without further modification), so I don't think we need to add extra copying here.\r\n\r\nI'd love to get additional sets of eyes on this, though, and I'd ultimately be ok with changing `return this` to `return this.clone()` (and updating the other `return this` uses in `UTF8String`) if we conclude that this isn't safe (or are uncertain and want to err on the side of caution).",
        "createdAt" : "2019-05-25T15:55:48Z",
        "updatedAt" : "2019-06-09T22:41:24Z",
        "lastEditedBy" : "a11722a8-ecfa-4827-88e3-4d708f023846",
        "tags" : [
        ]
      },
      {
        "id" : "3ae3777f-7a25-49ce-978a-9bd539d36e15",
        "parentId" : "89590784-6d62-442f-bfa0-6e8fd2cf1fc9",
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "I think your intuition is right here.",
        "createdAt" : "2019-05-26T18:45:31Z",
        "updatedAt" : "2019-06-09T22:41:24Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      }
    ],
    "commit" : "6188dcdd321967eb78535d7cf55b73f20047f449",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +984,988 @@    if (end == -1) {\n      // Search string was not found, so string is unchanged.\n      return this;\n    }\n    // At least one match was found. Estimate space needed for result."
  }
]