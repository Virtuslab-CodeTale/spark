[
  {
    "id" : "c013e103-e48b-4e9e-a7ea-9a84f70ecae0",
    "prId" : 27765,
    "prUrl" : "https://github.com/apache/spark/pull/27765#pullrequestreview-368391245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0431c11a-b6a5-4c35-be3f-f80ac34f1f73",
        "parentId" : null,
        "authorId" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "body" : "This method is added to handle the deletion which checks the value as well while removing the entry, to follow the original code.",
        "createdAt" : "2020-03-03T23:04:22Z",
        "updatedAt" : "2020-03-04T08:27:19Z",
        "lastEditedBy" : "0c28e5da-df9b-4076-bb67-3b6878f1f4ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b618cf1a96e03e681a899755dfe708108316493",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +283,287 @@    }\n\n    public boolean delete(Object key, T value) {\n      boolean entryExists = data.remove(asKey(key), value);\n      if (entryExists) {"
  },
  {
    "id" : "509bcc4f-b1ab-4e73-bad0-06d510a2c6d0",
    "prId" : 27716,
    "prUrl" : "https://github.com/apache/spark/pull/27716#pullrequestreview-366166026",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6cb4ad5-4627-41fb-ab03-24418765f3af",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "what's the difference between just call `data.remove` and `data.forEach(callback)`?",
        "createdAt" : "2020-02-27T15:37:57Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "46f19665-9d05-46e3-be3d-5210e7030fef",
        "parentId" : "a6cb4ad5-4627-41fb-ab03-24418765f3af",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : " `data.forEach(callback)` is O(n) scan and there is a filter.",
        "createdAt" : "2020-02-27T20:55:49Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "058327ab-3a1d-46d7-a886-98f71cb8da41",
        "parentId" : "a6cb4ad5-4627-41fb-ab03-24418765f3af",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "then why the else branch can't use `data.remove`? Can we add some comments to highlight the difference between the if and else branches?",
        "createdAt" : "2020-02-28T03:59:04Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "0d649f4b-e519-4f0b-972e-8fee414cd1c2",
        "parentId" : "a6cb4ad5-4627-41fb-ab03-24418765f3af",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "ok, let me add comments.",
        "createdAt" : "2020-02-28T05:20:40Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0d375535d4cc20f8fd18a011fc3165da1ab2b7e",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +241,245 @@          NaturalKeys children = parentToChildrenMap.getOrDefault(parentKey, new NaturalKeys());\n          for (Comparable<Object> naturalKey : children.keySet()) {\n            data.remove(naturalKey);\n            count ++;\n          }"
  },
  {
    "id" : "db2b9053-a6a5-47ff-94e4-43e334b2f1f3",
    "prId" : 27716,
    "prUrl" : "https://github.com/apache/spark/pull/27716#pullrequestreview-366149213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ca04287-38cf-42c0-a6bb-69a80c9a98bc",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "is this faster than `data.values().stream()...`?",
        "createdAt" : "2020-02-27T15:54:02Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "48f13f95-5ed7-4f6f-8962-2819da46f8bf",
        "parentId" : "3ca04287-38cf-42c0-a6bb-69a80c9a98bc",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "That's a linear scan, which we are trying to avoid. ",
        "createdAt" : "2020-02-27T21:08:30Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "8706dac4-257a-4ab7-946b-d01f42ddd097",
        "parentId" : "3ca04287-38cf-42c0-a6bb-69a80c9a98bc",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "ditto, let's add comment to explain why we need to do linear scan in the else branch.\r\n\r\nSo linear scan can happen if an index has a parent but the parent is not indexed?",
        "createdAt" : "2020-02-28T04:00:42Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0d375535d4cc20f8fd18a011fc3165da1ab2b7e",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +391,395 @@          ArrayList<T> elements = new ArrayList<>();\n          for (Comparable<Object> naturalKey : children.keySet()) {\n            data.computeIfPresent(naturalKey, (k, v) -> {\n              elements.add(v);\n              return v;"
  },
  {
    "id" : "91d56c02-e0a1-474d-88bd-b46ea9f7b263",
    "prId" : 27716,
    "prUrl" : "https://github.com/apache/spark/pull/27716#pullrequestreview-367065832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f905576b-dc82-474c-91c4-6983cdb1feec",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "since there is no document, I still have problems understanding it.\r\n\r\nThe basic idea is: if the `index` is natural index, we can just look it up in O(1). For other index, we have to do linear scan, extract keys and find matches.\r\n\r\nThe extension here: if the `index` is parent of natural index, get the children natural indexes and do O(1) lookup.\r\n\r\nHowever, seems the basic idea is missing? Shall we avoid linear scan if `index` is natural index?",
        "createdAt" : "2020-02-28T10:16:23Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "86abc950-50c9-4da7-981a-cde3d21bfb86",
        "parentId" : "f905576b-dc82-474c-91c4-6983cdb1feec",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Yes and no.\r\nI am aware of the natural index is not handled properly here. But all the method calls of this method doesn't pass the natural index in. \r\nThere is a simpler API to use in `KVStore`\r\n```\r\nvoid delete(Class<?> type, Object naturalKey)\r\n```\r\n\r\nSo I think this is minor and I prefer to do it in another PR, since this one is complicated.",
        "createdAt" : "2020-02-28T18:13:56Z",
        "updatedAt" : "2020-03-01T02:30:20Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "796c3715-ab81-45ba-8c66-4540e0b3c34a",
        "parentId" : "f905576b-dc82-474c-91c4-6983cdb1feec",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "we should probably unify the `delete` method, but it's not related to this PR.",
        "createdAt" : "2020-03-02T07:37:03Z",
        "updatedAt" : "2020-03-02T07:37:03Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "7b918ade-825b-4266-a8db-b000eec47111",
        "parentId" : "f905576b-dc82-474c-91c4-6983cdb1feec",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Yes,  I will do it in another PR.",
        "createdAt" : "2020-03-02T09:49:25Z",
        "updatedAt" : "2020-03-02T09:49:25Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0d375535d4cc20f8fd18a011fc3165da1ab2b7e",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +231,235 @@    }\n\n    int countingRemoveAllByIndexValues(String index, Collection<?> indexValues) {\n      if (hasNaturalParentIndex && naturalParentIndexName.equals(index)) {\n        // If there is a parent index for the natural index and `index` happens to be it,"
  },
  {
    "id" : "f178de24-a1ac-4418-9666-6ac5ccc434ae",
    "prId" : 24982,
    "prUrl" : "https://github.com/apache/spark/pull/24982#pullrequestreview-255838062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Rather than leave the code above duplicating this, have it call this one with a null condition and handle it here. Subclasses would only override `viewWithCondition` then.",
        "createdAt" : "2019-06-27T14:39:17Z",
        "updatedAt" : "2019-06-28T11:03:40Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "429635dd-5775-4111-b7c0-1aa02e436436",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "body" : "I’ve tried like `view(Class<T> type, Optional<Predicate<T>> condition)`, but how can I add a default parameter value in Java like `condition: Option[Predicate[T]] = None` in Scala? Otherwise, it needs to change many places so I choose to add a new function called `viewWithCondition`.",
        "createdAt" : "2019-06-27T15:50:52Z",
        "updatedAt" : "2019-06-28T11:03:40Z",
        "lastEditedBy" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "tags" : [
        ]
      },
      {
        "id" : "56366538-8627-4323-a560-81f7d27ce427",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "You can't create a default parameter value, but you can keep both methods. I'm just suggesting there's no need to duplicate their logic here and in subclasses.",
        "createdAt" : "2019-06-27T16:10:10Z",
        "updatedAt" : "2019-06-28T11:03:40Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "449a2f63-4642-4957-b41d-ee80d8770481",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "body" : "Do you mean dedup like this?\r\n```scala\r\n  @Override\r\n  public <T> KVStoreView<T> view(Class<T> type){\r\n    return viewWithCondition(type, t -> true);\r\n  }\r\n```\r\nWe cannot invoke `view` in `viewWithCondition` since `list.view(type)` will create much more instances than `list.viewWithCondition` indeed.",
        "createdAt" : "2019-06-28T02:14:45Z",
        "updatedAt" : "2019-06-28T11:03:40Z",
        "lastEditedBy" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "tags" : [
        ]
      },
      {
        "id" : "bc48fbfb-ac2c-4a7b-a8f5-bc18291f53d7",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "body" : "Dedup like this causes thing worse since `view()` would traverse all items. It was just return `map.values()`",
        "createdAt" : "2019-06-28T07:17:19Z",
        "updatedAt" : "2019-06-28T11:03:40Z",
        "lastEditedBy" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "tags" : [
        ]
      },
      {
        "id" : "062dad04-5219-45ce-8371-4e14c5a307ab",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "You're still going to exam all items, right? I don't see where this can be pushed down enough to make it faster.",
        "createdAt" : "2019-06-28T13:00:28Z",
        "updatedAt" : "2019-06-28T13:00:31Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "6b08a1cd-ad86-4d78-ae2c-003f5c32c245",
        "parentId" : "3e1493d4-b790-4c72-a52c-255a14305151",
        "authorId" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "body" : "There are low level APIs, the different between their efficiencies doesn’t depend on the API self, it depends on the invocation layer. For example the logic of invocation layer uses `view` to get all items and creates some kinds of objects for them, then it executes multiple heavy logic, finally it uses a filter to get less result. So using `viewWithCondiction` is very like SQL prediction pushdown optimization rule. Even the cost of the filter operation itself always fixed. But filter out as earlier as possible still could save memory and time.",
        "createdAt" : "2019-06-28T15:36:14Z",
        "updatedAt" : "2019-06-28T15:36:14Z",
        "lastEditedBy" : "0223d15f-93d2-46b2-bee2-7f40fcd0335a",
        "tags" : [
        ]
      }
    ],
    "commit" : "dac3fe3ba6bd8ee270f92109333279d6510a6c43",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +109,113 @@  @Override\n  public <T> KVStoreView<T> viewWithCondition(Class<T> type, Predicate<T> condition) {\n    InstanceList<T> list = inMemoryLists.get(type);\n    return list != null ? list.viewWithCondition(condition) : emptyView();\n  }"
  },
  {
    "id" : "fff831ed-abb8-4894-9124-f8307be0e9f7",
    "prId" : 24616,
    "prUrl" : "https://github.com/apache/spark/pull/24616#pullrequestreview-240182431",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bbed14b-d53f-4ff5-ad2b-b45a5f5462db",
        "parentId" : null,
        "authorId" : "0b3111e2-9584-4813-8cb5-8f40e119f71c",
        "body" : "final",
        "createdAt" : "2019-05-21T17:08:35Z",
        "updatedAt" : "2019-05-21T17:15:40Z",
        "lastEditedBy" : "0b3111e2-9584-4813-8cb5-8f40e119f71c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +145,149 @@   */\n  private static class InMemoryLists {\n    private ConcurrentMap<Class<?>, InstanceList<?>> data = new ConcurrentHashMap<>();\n\n    @SuppressWarnings(\"unchecked\")"
  },
  {
    "id" : "91ebfa76-9e5c-4d61-a59f-0efb1edcf002",
    "prId" : 24616,
    "prUrl" : "https://github.com/apache/spark/pull/24616#pullrequestreview-240182431",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "467ad2bd-5897-4b3c-b15d-d3ffb1695698",
        "parentId" : null,
        "authorId" : "0b3111e2-9584-4813-8cb5-8f40e119f71c",
        "body" : "`@Override`",
        "createdAt" : "2019-05-21T17:09:10Z",
        "updatedAt" : "2019-05-21T17:15:40Z",
        "lastEditedBy" : "0b3111e2-9584-4813-8cb5-8f40e119f71c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e062cf939298684d2dd64ba73dc8a8a6b3b10f68",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +191,195 @@      }\n\n      public void accept(Comparable<Object> key, T value) {\n        if (filter.test(value)) {\n          if (data.remove(key, value)) {"
  }
]