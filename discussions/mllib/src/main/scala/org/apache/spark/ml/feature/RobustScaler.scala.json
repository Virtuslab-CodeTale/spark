[
  {
    "id" : "4d342b1d-79d1-4245-bd69-e9c2f3eaddd9",
    "prId" : 27947,
    "prUrl" : "https://github.com/apache/spark/pull/27947#pullrequestreview-376684584",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15ddf2c2-2570-4bca-b051-8146d7af766a",
        "parentId" : null,
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "here we can trigger compression at the _map_ side",
        "createdAt" : "2020-03-18T09:20:39Z",
        "updatedAt" : "2020-03-18T09:20:59Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "964b9f8c57eb11eac6326e49a1b42fe8e66dcab4",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +213,217 @@      ).mapPartitionsWithIndex { case (pid, iter) =>\n        val p = pid % scale\n        iter.map { case (col, s) => ((p, col), s.compress) }\n      }.reduceByKey { case (s1, s2) => s1.merge(s2)\n      }.map { case ((_, col), s) => (col, s)"
  },
  {
    "id" : "93d28a6a-c871-4562-8cb4-78fbe59d9b98",
    "prId" : 27947,
    "prUrl" : "https://github.com/apache/spark/pull/27947#pullrequestreview-376688307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db9fdfa0-fd34-49a6-80ea-03c10da48bbf",
        "parentId" : null,
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "then no longer to confirm compression like `s1.compress.merge(s2.compress)`",
        "createdAt" : "2020-03-18T09:25:33Z",
        "updatedAt" : "2020-03-18T09:25:34Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "964b9f8c57eb11eac6326e49a1b42fe8e66dcab4",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +214,218 @@        val p = pid % scale\n        iter.map { case (col, s) => ((p, col), s.compress) }\n      }.reduceByKey { case (s1, s2) => s1.merge(s2)\n      }.map { case ((_, col), s) => (col, s)\n      }.reduceByKey { case (s1, s2) => s1.merge(s2) }"
  },
  {
    "id" : "c3d09a4a-95a7-48d3-8556-e1b68b264a03",
    "prId" : 25160,
    "prUrl" : "https://github.com/apache/spark/pull/25160#pullrequestreview-262783409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d24a9ae2-644c-4c08-ac20-9e3e4f62f4cb",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "private?",
        "createdAt" : "2019-07-16T13:56:49Z",
        "updatedAt" : "2019-07-29T05:18:31Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "ea823092-1502-4bff-a92a-e23ab293fac9",
        "parentId" : "d24a9ae2-644c-4c08-ac20-9e3e4f62f4cb",
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "It should not be private, this param is expected to be exposed to users.",
        "createdAt" : "2019-07-17T03:11:29Z",
        "updatedAt" : "2019-07-29T05:18:31Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "45aa724d3f352c265840817d1b690162865f3ec1",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +42,46 @@   * @group param\n   */\n  val lower: DoubleParam = new DoubleParam(this, \"lower\",\n    \"Lower quantile to calculate quantile range\",\n    ParamValidators.inRange(0, 1, false, false))"
  },
  {
    "id" : "0131b6f0-8f20-492f-8719-648f5b1b91cc",
    "prId" : 25160,
    "prUrl" : "https://github.com/apache/spark/pull/25160#pullrequestreview-264689849",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28c576d2-d03f-4f8d-980a-eedd4521ade6",
        "parentId" : null,
        "authorId" : "24e1dd39-ae3f-4bbb-a391-f60afb62d075",
        "body" : "can we move this outside in order to avoid this check every time? we can change this to a `do` ... `while` maybe",
        "createdAt" : "2019-07-20T10:02:14Z",
        "updatedAt" : "2019-07-29T05:18:31Z",
        "lastEditedBy" : "24e1dd39-ae3f-4bbb-a391-f60afb62d075",
        "tags" : [
        ]
      },
      {
        "id" : "d34a47c7-df4f-48b0-bd6f-f718a6bd32d9",
        "parentId" : "28c576d2-d03f-4f8d-980a-eedd4521ade6",
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "we don't know the `numFeatures` before read the first item\r\nThe only approach I found to avoid follwing check is something like this:\r\n```\r\nval agg = \r\nif (iter.hasNext) {\r\nval vec = iter.next;\r\nval agg2 = Array.fill(vec.size)(new QuantileSummaries(QuantileSummaries.defaultCompressThreshold, 0.001))\r\n// update agg2 with first vec\r\nagg2\r\nwhile(iiter.haxNext) {\r\n//update on following vecs\r\n}\r\nagg2\r\n} else {\r\nnull\r\n}\r\n```\r\nbut I think it too complex, so I tend to keep it.\r\n",
        "createdAt" : "2019-07-22T09:14:30Z",
        "updatedAt" : "2019-07-29T05:18:31Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "45aa724d3f352c265840817d1b690162865f3ec1",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +151,155 @@      while (iter.hasNext) {\n        val vec = iter.next()\n        if (agg == null) {\n          agg = Array.fill(vec.size)(\n            new QuantileSummaries(QuantileSummaries.defaultCompressThreshold, 0.001))"
  }
]