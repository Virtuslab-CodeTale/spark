[
  {
    "id" : "7fcf0bd4-f7d1-4638-8eb2-139c6e8bcb5a",
    "prId" : 28349,
    "prUrl" : "https://github.com/apache/spark/pull/28349#pullrequestreview-400478156",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ca34489-bcbd-47cf-b324-247064bfc742",
        "parentId" : null,
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "directly update the first `numFeatures` elements in `localGradientSumArray`, avoiding creating a temp vector and then adding it to `localGradientSumArray`",
        "createdAt" : "2020-04-26T08:55:56Z",
        "updatedAt" : "2020-05-04T13:25:14Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8abb4ba6b3b03cc0a696dcf43ee5ede109f88ea",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +189,193 @@    block.matrix match {\n      case dm: DenseMatrix =>\n        BLAS.nativeBLAS.dgemv(\"N\", dm.numCols, dm.numRows, 1.0, dm.values, dm.numCols,\n          vec.values, 1, 1.0, gradientSumArray, 1)\n        if (fitIntercept) gradientSumArray(numFeatures) += interceptGradSum"
  },
  {
    "id" : "0caf1c46-794d-41c8-bc75-4f064c45cd04",
    "prId" : 28349,
    "prUrl" : "https://github.com/apache/spark/pull/28349#pullrequestreview-400482423",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9ada036-4494-4407-bd32-b1ebfefb3d73",
        "parentId" : null,
        "authorId" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "body" : "No avaiable method to update the first `numFeatures`, so need a temp output vector `linearGradSumVec`",
        "createdAt" : "2020-04-26T09:38:23Z",
        "updatedAt" : "2020-05-04T13:25:14Z",
        "lastEditedBy" : "685f805b-e4fa-4f21-b066-58afcecf9ce6",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8abb4ba6b3b03cc0a696dcf43ee5ede109f88ea",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +195,199 @@      case sm: SparseMatrix if fitIntercept =>\n        val linearGradSumVec = Vectors.zeros(numFeatures).toDense\n        BLAS.gemv(1.0, sm.transpose, vec, 0.0, linearGradSumVec)\n        BLAS.getBLAS(numFeatures).daxpy(numFeatures, 1.0, linearGradSumVec.values, 1,\n          gradientSumArray, 1)"
  }
]