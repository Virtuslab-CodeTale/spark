[
  {
    "id" : "eb24461f-04d4-4d9f-80f2-bf5edc9da2b6",
    "prId" : 33214,
    "prUrl" : "https://github.com/apache/spark/pull/33214#pullrequestreview-700519288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbe08729-7044-4bc1-99b3-f7de6cc3b20f",
        "parentId" : null,
        "authorId" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "body" : "Do we need to log warning if inferred value types are not inconsistent? We can recommend users to use the config.",
        "createdAt" : "2021-07-07T01:11:35Z",
        "updatedAt" : "2021-07-07T01:12:16Z",
        "lastEditedBy" : "5e28de51-305c-4276-b3a0-78bcc74eb6f2",
        "tags" : [
        ]
      },
      {
        "id" : "7b233d5e-2ce5-4f6a-b70a-92bb63e97531",
        "parentId" : "bbe08729-7044-4bc1-99b3-f7de6cc3b20f",
        "authorId" : "2d8ced12-ada1-43e1-9240-bf1c11a01e4c",
        "body" : "Thanks for the comment! :)\r\nActually PySpark merging one only handles null cases only (that's called out here) at \r\nhttps://github.com/apache/spark/blob/52a9a70fa3e5b720b41e2ff4e9177a5d201b471f/python/pyspark/sql/types.py#L1096-L1133\r\n\r\nIt actually fails for different types (unlike JSON or CSV type inference).\r\nI am not sure what's the ideal behavior for the null case pointed out here though.\r\nLet me separate it from this PR in any event if you're fine.",
        "createdAt" : "2021-07-07T02:20:47Z",
        "updatedAt" : "2021-07-07T02:20:47Z",
        "lastEditedBy" : "2d8ced12-ada1-43e1-9240-bf1c11a01e4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "52a9a70fa3e5b720b41e2ff4e9177a5d201b471f",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +1032,1036 @@                    return MapType(_infer_type(key, infer_dict_as_struct),\n                                   _infer_type(value, infer_dict_as_struct), True)\n            return MapType(NullType(), NullType(), True)\n    elif isinstance(obj, list):\n        for v in obj:"
  },
  {
    "id" : "c17f186a-eb13-42e7-a780-3ebe49acd516",
    "prId" : 29935,
    "prUrl" : "https://github.com/apache/spark/pull/29935#pullrequestreview-573860703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c444cd6c-4b48-48b0-a6fd-e7ae63a9a85d",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "There have been a lot of discussions about exposing interval type in other language APIs but I lost the track. @yaooqinn and @cloud-fan, are we going to make internal as a proper exposed type? Or only support it in some contexts?",
        "createdAt" : "2020-10-03T04:06:34Z",
        "updatedAt" : "2020-12-01T11:47:10Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "c57e9793-f2a9-4f83-a94d-e43cb72da85b",
        "parentId" : "c444cd6c-4b48-48b0-a6fd-e7ae63a9a85d",
        "authorId" : "981b170c-729a-429c-b115-0350ea50b32b",
        "body" : "Yes, I glanced over a few threads and couldn't really figure out where it is going, hence a limited scope of this PR. However, if the type is supported in multiple contexts, current behavior doesn't seem like an intended one.",
        "createdAt" : "2020-10-03T06:01:58Z",
        "updatedAt" : "2020-12-01T11:47:10Z",
        "lastEditedBy" : "981b170c-729a-429c-b115-0350ea50b32b",
        "tags" : [
        ]
      },
      {
        "id" : "a79ab2cb-8936-44bb-9953-55042e8d8f19",
        "parentId" : "c444cd6c-4b48-48b0-a6fd-e7ae63a9a85d",
        "authorId" : "fd6ebc48-7da4-490b-8d41-2e8530d92720",
        "body" : "Doesn't @zero323's example from the PR description show that Spark already exposes this type? \r\n\r\n```python\r\nspark.sql(\"SELECT current_date() - current_date()\")\r\n```\r\n\r\nFor the record, btw, Postgres supports [an `interval` type](https://www.postgresql.org/docs/current/datatype-datetime.html) and done so since at least [version 7.1](https://www.postgresql.org/docs/7.1/datatype-datetime.html), which was released in 2001. (I mention this since Postgres often comes up as a reference for whether Spark SQL should support a feature or not.)",
        "createdAt" : "2021-01-21T20:36:30Z",
        "updatedAt" : "2021-01-21T20:40:34Z",
        "lastEditedBy" : "fd6ebc48-7da4-490b-8d41-2e8530d92720",
        "tags" : [
        ]
      },
      {
        "id" : "cd7f48b0-51e4-4384-bca4-1ab78f2ff1e0",
        "parentId" : "c444cd6c-4b48-48b0-a6fd-e7ae63a9a85d",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "The problem is that it has been half-exposed so far. There have been many discussions up to which context we should support. e.g.) `CalendarInterval` is marked as `Unstable`.",
        "createdAt" : "2021-01-22T01:03:19Z",
        "updatedAt" : "2021-01-22T01:03:19Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "c61d5fcb-79e0-4426-bc14-939c34a03e82",
        "parentId" : "c444cd6c-4b48-48b0-a6fd-e7ae63a9a85d",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "BTW, I personally agree with adding this in particular due to @nchammas point https://github.com/apache/spark/pull/29935#discussion_r562175621 here",
        "createdAt" : "2021-01-22T01:04:56Z",
        "updatedAt" : "2021-01-22T01:04:56Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "69438b418aafa76d6d23f6ffbb146ac2b6e10019",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +187,191 @@\n\nclass CalendarIntervalType(DataType, metaclass=DataTypeSingleton):\n    \"\"\"Calendar Interval type\n    \"\"\""
  },
  {
    "id" : "556e1fb6-491f-4214-8001-92d181710580",
    "prId" : 29935,
    "prUrl" : "https://github.com/apache/spark/pull/29935#pullrequestreview-573760710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f00a6df-33eb-4379-9a14-46d2f3f8c00f",
        "parentId" : null,
        "authorId" : "fd6ebc48-7da4-490b-8d41-2e8530d92720",
        "body" : "I suppose in the future if we want to support conversion of Python's [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta), it would happen here, right?",
        "createdAt" : "2021-01-21T20:27:07Z",
        "updatedAt" : "2021-01-21T20:38:42Z",
        "lastEditedBy" : "fd6ebc48-7da4-490b-8d41-2e8530d92720",
        "tags" : [
        ]
      },
      {
        "id" : "261f589c-94ea-4343-ac16-9b73d227511d",
        "parentId" : "2f00a6df-33eb-4379-9a14-46d2f3f8c00f",
        "authorId" : "981b170c-729a-429c-b115-0350ea50b32b",
        "body" : "For full support we might need both Python and JVM component. If I recall correctly `timedelta` has razrovine mapping to their internal `net.razorvine.pickle.objects.TimeDelta`.\r\n\r\nIn the opposite direction we could, if I am not mistaken, start with making `CalendarInterval` bean compatible, but there is compatibility issue â€’ we'd have to map from Spark's months to Python's days.\r\n\r\n",
        "createdAt" : "2021-01-21T21:43:43Z",
        "updatedAt" : "2021-01-21T21:43:44Z",
        "lastEditedBy" : "981b170c-729a-429c-b115-0350ea50b32b",
        "tags" : [
        ]
      }
    ],
    "commit" : "69438b418aafa76d6d23f6ffbb146ac2b6e10019",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +203,207 @@        raise NotImplementedError(\n            \"Conversion from external Python types to interval not supported\"\n        )\n\n    def fromInternal(self, v):"
  },
  {
    "id" : "ebfca0e8-37d7-487c-bccd-b790576d8167",
    "prId" : 29720,
    "prUrl" : "https://github.com/apache/spark/pull/29720#pullrequestreview-490238723",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Just to clarify, does this cause any user-facing error? As long as we can roundtrip jsonValue and fromJson, I think we're good.",
        "createdAt" : "2020-09-11T06:11:06Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "812f2b24-3894-461f-9063-325c18e9db97",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "Nope it won't cause any user-facing error. By doing:\r\n```python\r\njson.get(\"containsNull\", True)\r\n```\r\nThe code is getting the value of the `containsNull` key from the JSON if it exists. If the key does not, it will be `True`. This matches the constructor of `ArrayType` which has `True` as the default argument for `containsNull`. With this approach, the `fromJson` call to the constructors of the changes classes emulates the default arguments so the `jsonValue` function will behave in the same way when called upon.\r\n\r\nI'm happy to add some tests if you believe it is needed but this is be a no-op change.",
        "createdAt" : "2020-09-11T16:14:20Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "c9590a8e-0cbf-4643-abac-19b28d549cd9",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "@HyukjinKwon I refactored the test to include a roundtrip test for `jsonValue()` ðŸ‘ ",
        "createdAt" : "2020-09-11T23:37:16Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "a07ee569-d531-4100-8afe-d6c76838cdce",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "In which case `containsNull` does not exist?",
        "createdAt" : "2020-09-14T02:25:10Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "39389c44-da70-47cd-9721-c84a263f5858",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "The first test case:\r\n```python\r\n(\r\n  \"ArrayType with default values\", ArrayType,\r\n  {\"elementType\": \"string\"},\r\n  ArrayType(StringType())\r\n ),\r\n```\r\nShows that is `containsNull` is not populated in the incoming JSON it will behave the same as if the argument is not given to the `ArrayType` constructor.",
        "createdAt" : "2020-09-15T01:07:03Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "e031e8e6-032c-4d8a-b8ca-df2f4d40ccdf",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "It has:\r\n\r\n```python\r\n>>> ArrayType(StringType()).jsonValue()\r\n{'type': 'array', 'elementType': 'string', 'containsNull': True}\r\n```",
        "createdAt" : "2020-09-15T01:12:09Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "bfbfde07-d674-4830-b2b2-2a8fe14cd8b6",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "Right so the default value for `containsNull` for `ArrayType` is `True` so this test shows that without supplying it in the JSON or Constructor you get the same result. I will add another `assert` for the resulting JSON.",
        "createdAt" : "2020-09-15T01:19:01Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "c4e3968f-4dfa-4614-bb21-c2ddd243cdf5",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I mean I am trying to understand why you want this change. For example, does it affect anything in the roundtrip between `jsonValue` and `fromJson`, or are you trying to build up the JSON by yourself somewhere?",
        "createdAt" : "2020-09-15T01:22:41Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "330a3506-9763-4ecf-a5cb-ef4275df60a5",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "Added!",
        "createdAt" : "2020-09-15T01:23:03Z",
        "updatedAt" : "2020-09-15T01:23:51Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "564ecd61-77b1-4c40-aea2-be5f41242d2c",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "Correct we have a use case where we build up the JSON elsewhere and we don't want to have to require the default keys. It drives down complexity when defining schemas in external JSON files",
        "createdAt" : "2020-09-15T01:27:30Z",
        "updatedAt" : "2020-09-15T01:27:56Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "c16845dc-22e0-4a7b-a1c7-9b1c3fc89bac",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I don't think the format is meant to be exposed from end users. It's just for internal ser/de purpose that is supposed to be roundtrip between `jsonValue` and `fromJson` to workaround Py4J limitation.\r\n\r\nBTW, here isn't only place where you should handle JSON ser/de. For example, you should also change Scala side at `DataType.parseDataType`. ",
        "createdAt" : "2020-09-15T01:51:14Z",
        "updatedAt" : "2020-09-15T01:51:14Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "24cdee63-f4ae-406c-a554-bf04835645b2",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "@HyukjinKwon I think going down the rabbit hole of use case is a bad approach. Taking a step back from the use case, the motivation behind this change is for a **consistent API when creating DataTypes** (namely `StructField`, `ArrayType`, & `MapType`). It seems a bit inconsistent that I can do:\r\n```python\r\n>> MapType(StringType(), StringType()) # notice I omit the valueContainsNull argument\r\nMapType(StringType,StringType,true) # valueContainsNull has a default value of True\r\n```\r\nBut when using `.fromJson` which is essentially a constructor for `MapType`, with an equivalent JSON:\r\n```python\r\n>> MapType.fromJson({\"keyType\": \"string\", \"valueType\": \"string\"}) # No valueContainsNull key\r\nKeyError: 'valueContainsNull' # Error thrown tell me I need valueContainsNull in my JSON\r\n```\r\nThe same inconsistencies hold true for `StructField` keys `metadata` & `nullable` **_AND_** `ArrayType` key `containsNull`.\r\n\r\n_On the flip side_, lets say I omit the required parameter `valueType`:\r\n```python\r\n>> MapType(StringType()) # notice I omit the valueType argument\r\nTypeError: __init__() missing 1 required positional argument: 'valueType' # Error throw telling me I need valueType\r\n```\r\nAnd when I do the same using a JSON constructing:\r\n```python\r\n>> MapType({\"keyType\": \"string\"}) # omit the valueType key\r\nKeyError: 'valueType' # Error throw telling me I need it in my JSON\r\n```\r\n\r\nThis change proposes making the constructors, both the Python class constructor and the classMethod `.fromJson`, consistent on what they expect for input.",
        "createdAt" : "2020-09-15T15:10:06Z",
        "updatedAt" : "2020-09-15T16:22:23Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "f274c16a-498a-4aa4-90ff-ae9a60c07c66",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "The JSON format itself isn't supposed to be manually constructed. I think it doesn't necessarily have to be consistent with the constructor.",
        "createdAt" : "2020-09-16T01:29:47Z",
        "updatedAt" : "2020-09-16T01:29:48Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "558d9c44-8c2f-41be-965f-2e50f2854935",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "body" : "> The JSON format itself isn't supposed to be manually constructed\r\n\r\nI see where you're coming from here but the function `.fromJson` for for `ArrayType`, `MapType`, `StructField`, and `StructType` is exposed to developers so it _can_ be used. I have a strong hunch people do use it as it is an easy way to generate and store schemas. I'm curious what it would take to get this through? It's _seems_ like a fairly logical change to make the interface for these types more flexible. There is no user facing changes as it only creates a default value when the key does not exist.",
        "createdAt" : "2020-09-16T15:57:18Z",
        "updatedAt" : "2020-09-17T00:12:45Z",
        "lastEditedBy" : "0213eea8-0d0a-480f-86a0-f61d2266e109",
        "tags" : [
        ]
      },
      {
        "id" : "d7e74acc-05e8-44eb-98cd-2eaf95fa73ab",
        "parentId" : "87cd68e7-39b2-4af0-8dca-3061b96584df",
        "authorId" : "46a9e4e8-1a07-4207-8752-959ac7b91f82",
        "body" : "Unless there are plans to remove `.fromJson`, it is a publicly exposed interface and, I dare say, a rather useful one.\r\n\r\nJSON is currently the only schema definition structure that is a) human readable, b) machine readable without `exec`, and c) easy to generate with anything other than Python / Java.\r\n\r\nAs far as I can tell, this PR:\r\n- Adds additional test coverage for an existing component\r\n- Makes an existing component more flexible for some use cases\r\n- Does not reduce any existing functionality\r\n\r\nGetting to use cases, I have frequently found value in providing a machine readable schema that can be validated with JSON schema and used as a unit and integration tests to verify expected schema against a SQL file.",
        "createdAt" : "2020-09-17T04:43:40Z",
        "updatedAt" : "2020-09-17T04:43:41Z",
        "lastEditedBy" : "46a9e4e8-1a07-4207-8752-959ac7b91f82",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f939f117455d29f58518f0ee0087e646e777b62",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +304,308 @@\n    @classmethod\n    def fromJson(cls, json):\n        return ArrayType(_parse_datatype_json_value(json[\"elementType\"]),\n                         json.get(\"containsNull\", True))"
  },
  {
    "id" : "237d3800-f006-4515-86b8-64e69937017a",
    "prId" : 27475,
    "prUrl" : "https://github.com/apache/spark/pull/27475#pullrequestreview-355037026",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff83bd98-9cf2-4539-8512-3d757bdf6390",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I think it was correct to omit `that` as well.",
        "createdAt" : "2020-02-07T07:17:57Z",
        "updatedAt" : "2020-02-07T07:25:09Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "bb0d1a01-a5a6-41ad-a7bf-4cd1bc65a10d",
        "parentId" : "ff83bd98-9cf2-4539-8512-3d757bdf6390",
        "authorId" : "35307f54-36ce-4d4a-bef6-fd378b2292d6",
        "body" : "yes, we can omit `that`, but adding it makes the sentence a little bit more explanatory.",
        "createdAt" : "2020-02-07T07:23:04Z",
        "updatedAt" : "2020-02-07T07:25:09Z",
        "lastEditedBy" : "35307f54-36ce-4d4a-bef6-fd378b2292d6",
        "tags" : [
        ]
      },
      {
        "id" : "744b61b9-32c8-4512-a5bb-bb4521cb33f5",
        "parentId" : "ff83bd98-9cf2-4539-8512-3d757bdf6390",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "@sharifahmad2061 I just merged this time but let's don't make unnecessary changes like this next time.",
        "createdAt" : "2020-02-07T09:44:52Z",
        "updatedAt" : "2020-02-07T09:44:52Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "497d0279c0e625c60dcad8c22b513d3bf724bbf9",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +1434,1438 @@\n    Row can be used to create a row object by using named arguments.\n    It is not allowed to omit a named argument to represent that the value is\n    None or missing. This should be explicitly set to None in this case.\n"
  }
]