[
  {
    "id" : "ebc403a3-a1fa-421e-a25b-081996cebf84",
    "prId" : 30552,
    "prUrl" : "https://github.com/apache/spark/pull/30552#pullrequestreview-541987898",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb973356-f7b0-4502-8585-7a3ccbcd0cfb",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "toString() is unnecesary here BTW.\r\nSo this relies on query already being escaped. That may be fine for the logic of this code, although in another world it would have been better to let this method take unescaped query strings and manage it here.",
        "createdAt" : "2020-12-01T14:42:40Z",
        "updatedAt" : "2020-12-01T14:42:41Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "d829c104-3922-4be4-93d0-f6049deee700",
        "parentId" : "fb973356-f7b0-4502-8585-7a3ccbcd0cfb",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Thanks for the suggestion, Sean.\r\n> toString() is unnecesary here BTW.\r\n\r\n`uri` is `StringBuilder` here. The original code also use toString().\r\n\r\n> So this relies on query already being escaped. That may be fine for the logic of this code, although in another world it would have been better to let this method take unescaped query strings and manage it here.\r\n\r\nThe query string here should be encoded already.  I am not very familiar with this topic. Is there any better solution to handle both escaped/unescaped query string?",
        "createdAt" : "2020-12-01T14:56:45Z",
        "updatedAt" : "2020-12-01T14:56:45Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "fcff36e7-a1b9-4aff-a29b-bd84cdd2f305",
        "parentId" : "fb973356-f7b0-4502-8585-7a3ccbcd0cfb",
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Oh right, OK, ignore the toString() comment.\r\nI just mean that semantically, encoding is a URI detail. The program should probably not worry about it except when going to and from URIs. But that's not how this code is structured. It clearly already expects and escaped string as argument, which then means callers have to deal with it. But, I don't think it's necessary to change. If it is escaped then yes this is a fix.",
        "createdAt" : "2020-12-01T15:01:32Z",
        "updatedAt" : "2020-12-01T15:01:32Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      }
    ],
    "commit" : "b34c0a5f1d18581ab71d38ac023a79fcc7378583",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +408,412 @@    }\n    // SPARK-33611: use method `URI.create` to avoid percent-encoding twice on the query string.\n    URI.create(uri.toString() + queryString).normalize()\n  }\n"
  },
  {
    "id" : "1c256c4b-16e4-40a7-b5f8-2428b65ec279",
    "prId" : 29271,
    "prUrl" : "https://github.com/apache/spark/pull/29271#pullrequestreview-459355688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b1c4381-96ed-442c-bffe-5d562dcc4c71",
        "parentId" : null,
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "Can we try to use the same approach in `createProxyURI`? Looks like we can try to create a method to share in  `createRedirectURI` and `createProxyURI`.\r\n```\r\n    val rewrittenURI = URI.create(uri.toString())\r\n    if (query != null) {\r\n      return new URI(\r\n          rewrittenURI.getScheme(),\r\n          rewrittenURI.getAuthority(),\r\n          rewrittenURI.getPath(),\r\n          query,\r\n          rewrittenURI.getFragment()\r\n        ).normalize()\r\n    }\r\n```",
        "createdAt" : "2020-07-30T18:29:26Z",
        "updatedAt" : "2020-07-31T08:38:11Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      },
      {
        "id" : "9da7ea0c-734a-4596-8e8a-03de1b5e017c",
        "parentId" : "9b1c4381-96ed-442c-bffe-5d562dcc4c71",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I tried but it doesn't do the decoding with URI.toString\r\n```\r\nscala> new URI(\"https://g.com/ctx%281%29?a%5B0%5D=b\").normalize().toString\r\nres28: String = https://g.com/ctx%281%29?a%5B0%5D=b\r\n```",
        "createdAt" : "2020-07-31T08:35:20Z",
        "updatedAt" : "2020-07-31T08:38:11Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "eefd9316-48e1-480e-bd56-9f4bc4eebf4a",
        "parentId" : "9b1c4381-96ed-442c-bffe-5d562dcc4c71",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "We can build a URI and call get `getPath` and `getQuery`, and then build a new URI string from the decode result. ```\r\nscala> new URI(\"https://g.com/ctx%281%29?a%5B0%5D=b\").getPath\r\nres31: String = /ctx(1)\r\n\r\nscala> new URI(\"https://g.com/ctx%281%29?a%5B0%5D=b\").getQuery\r\nres33: String = a[0]=b\r\n```\r\nBut it seems equivalent of the current code.",
        "createdAt" : "2020-07-31T08:37:32Z",
        "updatedAt" : "2020-07-31T08:38:11Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "a9eff167-506d-4d0e-af49-17d3aa7e9fb1",
        "parentId" : "9b1c4381-96ed-442c-bffe-5d562dcc4c71",
        "authorId" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "body" : "> I tried but it doesn't do the decoding with URI.toString\r\n\r\nURI.toString doesn't do the decoding. It will encode characters if necessary. For example,\r\n\r\n```\r\nscala> val uri = new java.net.URI(null, null, \"foo bar\", \"foo bar\", null).toString\r\nuri: String = foo%20bar?foo%20bar\r\n```\r\n\r\nAnyway, this doesn't matter. I tried to consolidate these two method but it didn't look better.",
        "createdAt" : "2020-07-31T17:52:48Z",
        "updatedAt" : "2020-07-31T17:52:53Z",
        "lastEditedBy" : "2d6b46ba-4100-4c4d-9341-fff5e39647ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef6cb87d6b786fba8a56f92b7caf3d191eb6ab09",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +457,461 @@    }\n    val authority = s\"$redirectServer:$port\"\n    val queryEncoding = if (request.getQueryEncoding != null) {\n      request.getQueryEncoding\n    } else {"
  },
  {
    "id" : "c26fa584-bc02-4e7c-90a5-5aa7b2f05771",
    "prId" : 28585,
    "prUrl" : "https://github.com/apache/spark/pull/28585#pullrequestreview-414961480",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96522f52-28ed-43b0-969b-14d94d92944c",
        "parentId" : null,
        "authorId" : "3a227965-84e0-47cf-9974-11293764f028",
        "body" : "I noticed that as of Jetty 9.4.21, the implementation of `QueuedThreadPool`.\r\nWhen `QueuedThreadPool#setIdleTimeout` is called, `QueuedThreadPool#_idleTimeout` is set to the new timeout as well as [`ReservedThreadExecutor#_idleTimeout`](https://github.com/eclipse/jetty.project/blob/jetty-9.4.28.v20200408/jetty-util/src/main/java/org/eclipse/jetty/util/thread/QueuedThreadPool.java#L312).\r\n\r\nIf `ReservedThreadExecutor#_idleTImeout` is tried to be set after Jetty has started, [`IllegalStateException` will be thrown](https://github.com/eclipse/jetty.project/blob/jetty-9.4.28.v20200408/jetty-util/src/main/java/org/eclipse/jetty/util/thread/ReservedThreadExecutor.java#L149).\r\n\r\nBut `QueuedThreadPool#_idleTimeout` will be set so this workaround will still work by ignoring the exception.\r\n\r\n",
        "createdAt" : "2020-05-20T03:06:41Z",
        "updatedAt" : "2020-06-03T07:28:20Z",
        "lastEditedBy" : "3a227965-84e0-47cf-9974-11293764f028",
        "tags" : [
        ]
      }
    ],
    "commit" : "955a14714daced032fa23f54997c15745e11214f",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +506,510 @@        // will be thrown if we try to set idle timeout after the server has started.\n        // But this workaround works for Jetty 9.4.28 by ignoring the exception.\n        Try(pool.setIdleTimeout(0))\n      case _ =>\n    }"
  },
  {
    "id" : "9abdd8fd-43a6-4bfa-8dfa-991a22f2c987",
    "prId" : 28437,
    "prUrl" : "https://github.com/apache/spark/pull/28437#pullrequestreview-407244483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa830967-9807-4672-886b-eb7b9e91ad95",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "How about setting the idel timeout after \r\n```\r\nserver.stop()\r\n```\r\nIs there any difference?",
        "createdAt" : "2020-05-07T07:28:28Z",
        "updatedAt" : "2020-05-07T07:28:28Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      },
      {
        "id" : "afa42765-055f-401d-a4ee-bac9c17eaf6c",
        "parentId" : "fa830967-9807-4672-886b-eb7b9e91ad95",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "then there will be a chance that we trigger the bug before setting the idle timeout?",
        "createdAt" : "2020-05-07T07:42:06Z",
        "updatedAt" : "2020-05-07T07:42:06Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "045a8045-7469-4095-abc7-1b54a235c801",
        "parentId" : "fa830967-9807-4672-886b-eb7b9e91ad95",
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "Ah, I see. This is a bit complex..",
        "createdAt" : "2020-05-07T08:13:32Z",
        "updatedAt" : "2020-05-07T08:13:32Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4903285bafc08810b723f08cabd5759c8abeb25",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +497,501 @@\n  def stop(): Unit = {\n    val threadPool = server.getThreadPool\n    threadPool match {\n      case pool: QueuedThreadPool =>"
  },
  {
    "id" : "09ab8b3f-f1ee-4972-a2fe-f1b6d7cb80e3",
    "prId" : 25045,
    "prUrl" : "https://github.com/apache/spark/pull/25045#pullrequestreview-257601053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c8b7747-6fd8-40e7-aae9-9bf55307cc0f",
        "parentId" : null,
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Hi, @gaborgsomogyi . You need this in the older branches, too? Did I understand correct?",
        "createdAt" : "2019-07-03T15:56:23Z",
        "updatedAt" : "2019-07-03T15:56:23Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "0d14cc86-1e54-4197-be66-df66506d84ee",
        "parentId" : "6c8b7747-6fd8-40e7-aae9-9bf55307cc0f",
        "authorId" : "e6f86365-3ac2-48b4-94f9-21ce737cf1ac",
        "body" : "You understand it correctly, it's needed in previous versions as well.",
        "createdAt" : "2019-07-03T16:19:50Z",
        "updatedAt" : "2019-07-03T16:19:51Z",
        "lastEditedBy" : "e6f86365-3ac2-48b4-94f9-21ce737cf1ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "48405c95aca7961d92304c7e45147f0264bbcb5f",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +300,304 @@      val requestHeaderSize = conf.get(UI_REQUEST_HEADER_SIZE).toInt\n      logDebug(s\"Using requestHeaderSize: $requestHeaderSize\")\n      httpConfig.setRequestHeaderSize(requestHeaderSize)\n\n      // If SSL is configured, create the secure connector first."
  }
]