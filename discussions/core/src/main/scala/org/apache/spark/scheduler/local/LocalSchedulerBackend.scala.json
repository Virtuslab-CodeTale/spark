[
  {
    "id" : "67649035-84ba-4f02-8f4e-6ff2255380bf",
    "prId" : 27773,
    "prUrl" : "https://github.com/apache/spark/pull/27773#pullrequestreview-371935155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d88538c-9f7b-403f-9f33-e57725cd21a9",
        "parentId" : null,
        "authorId" : "d35df420-57a9-43e8-b8d5-cad0f4002681",
        "body" : "Curious, in future are we planning to support resource profiles for local mode ? With local gpu for example ?",
        "createdAt" : "2020-03-09T09:46:56Z",
        "updatedAt" : "2020-03-19T20:03:38Z",
        "lastEditedBy" : "d35df420-57a9-43e8-b8d5-cad0f4002681",
        "tags" : [
        ]
      },
      {
        "id" : "090f194b-402c-414a-a4a8-f0c28ab37026",
        "parentId" : "6d88538c-9f7b-403f-9f33-e57725cd21a9",
        "authorId" : "bea80117-7be3-4703-8d54-02b7bf73632c",
        "body" : "not currently planned but someone did just say they were going to add the generic resource scheduling work in local mode.  I think for testing purposes so they can keep production code same. did you have specific use case or concern? ",
        "createdAt" : "2020-03-09T16:09:38Z",
        "updatedAt" : "2020-03-19T20:03:38Z",
        "lastEditedBy" : "bea80117-7be3-4703-8d54-02b7bf73632c",
        "tags" : [
        ]
      },
      {
        "id" : "a9d4cd20-7e26-4742-9a97-92925528c6fe",
        "parentId" : "6d88538c-9f7b-403f-9f33-e57725cd21a9",
        "authorId" : "d35df420-57a9-43e8-b8d5-cad0f4002681",
        "body" : "If possible, feature parity in whatever practical/constrained way of local mode with cluster mode would be nice - it allows for an quick prototyping/testing before launching on a cluster.\r\nOfcourse, not coupling with this work - but particularly for rapid prototyping, local mode is invaluable.",
        "createdAt" : "2020-03-10T10:57:50Z",
        "updatedAt" : "2020-03-19T20:03:38Z",
        "lastEditedBy" : "d35df420-57a9-43e8-b8d5-cad0f4002681",
        "tags" : [
        ]
      },
      {
        "id" : "424503f5-2abe-4e73-a3ae-9a2aa033e01a",
        "parentId" : "6d88538c-9f7b-403f-9f33-e57725cd21a9",
        "authorId" : "bea80117-7be3-4703-8d54-02b7bf73632c",
        "body" : "yeah the main issue right now is this is tied to dynamic allocation, so we would just need to figure out we would want that to behave.",
        "createdAt" : "2020-03-10T13:11:25Z",
        "updatedAt" : "2020-03-19T20:03:38Z",
        "lastEditedBy" : "bea80117-7be3-4703-8d54-02b7bf73632c",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a4a73385ee948d81e51091990a37ebbc8010f61",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +167,171 @@  override def maxNumConcurrentTasks(rp: ResourceProfile): Int = {\n    val cpusPerTask = ResourceProfile.getTaskCpusOrDefaultForProfile(rp, conf)\n    totalCores / cpusPerTask\n  }\n"
  }
]