[
  {
    "id" : "fc5ab280-9e2c-448e-a47e-fa84bce35337",
    "prId" : 32877,
    "prUrl" : "https://github.com/apache/spark/pull/32877#pullrequestreview-681954969",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8f37eb5-bec8-49dc-b2a1-542996a791b8",
        "parentId" : null,
        "authorId" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "body" : "Hm, the issue is that remove() blocks indefinitely, so this would never let it check `stopped` again if nothing is in the queue?",
        "createdAt" : "2021-06-11T12:41:41Z",
        "updatedAt" : "2021-06-11T12:41:41Z",
        "lastEditedBy" : "707cf6e1-750c-4aea-8774-f79c13fb7add",
        "tags" : [
        ]
      },
      {
        "id" : "19586f45-c8d2-47f1-a1da-d9b5578722d8",
        "parentId" : "d8f37eb5-bec8-49dc-b2a1-542996a791b8",
        "authorId" : "6a8d0007-eb0f-4236-a65a-2174a14ac689",
        "body" : "Hm, This is a issue too, I'm thinking, `while (!stopped)` means `while (true)`  if there is no stop all the time, the will lead to some ineffective loop, I'm not sure if there are some ineffective effects?",
        "createdAt" : "2021-06-11T13:57:30Z",
        "updatedAt" : "2021-06-11T13:57:30Z",
        "lastEditedBy" : "6a8d0007-eb0f-4236-a65a-2174a14ac689",
        "tags" : [
        ]
      },
      {
        "id" : "82fa50a1-ede7-4bdb-ae10-35c1ed87f91f",
        "parentId" : "d8f37eb5-bec8-49dc-b2a1-542996a791b8",
        "authorId" : "ddb80038-2da6-4937-8c45-4d52fbe0300f",
        "body" : "+1 with @srowen -- it seems to me that the current behavior is intentional, to allow for periodic checking of `stopped` to allow for the loop to exit. ",
        "createdAt" : "2021-06-11T15:25:46Z",
        "updatedAt" : "2021-06-11T15:25:46Z",
        "lastEditedBy" : "ddb80038-2da6-4937-8c45-4d52fbe0300f",
        "tags" : [
        ]
      }
    ],
    "commit" : "303fcfcd50c40bc54473cb6bb8423ab6403be1c0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +189,193 @@    while (!stopped) {\n      try {\n        val reference = Option(referenceQueue.remove())\n          .map(_.asInstanceOf[CleanupTaskWeakReference])\n        // Synchronize here to avoid being interrupted on stop()"
  }
]