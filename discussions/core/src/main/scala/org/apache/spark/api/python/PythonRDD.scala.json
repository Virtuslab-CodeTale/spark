[
  {
    "id" : "0f1f1c3f-0209-49db-ac61-d638453682d2",
    "prId" : 25593,
    "prUrl" : "https://github.com/apache/spark/pull/25593#pullrequestreview-281789816",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4264ea80-bd2d-4326-8ec5-1653aac9dbe3",
        "parentId" : null,
        "authorId" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "body" : "Nit: only -> but",
        "createdAt" : "2019-08-29T17:02:42Z",
        "updatedAt" : "2019-08-29T17:02:42Z",
        "lastEditedBy" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "tags" : [
        ]
      },
      {
        "id" : "a948ecf3-e14a-42c3-a18a-89c7bdf6fc54",
        "parentId" : "4264ea80-bd2d-4326-8ec5-1653aac9dbe3",
        "authorId" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "body" : "Can we update the comment of serveToStream in the master branch? This might be a common mistake if the contributors are not aware of the trap. ",
        "createdAt" : "2019-08-29T17:03:46Z",
        "updatedAt" : "2019-08-29T17:08:06Z",
        "lastEditedBy" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "tags" : [
        ]
      },
      {
        "id" : "8a2720b5-6390-44b5-98a4-e54618af8b2c",
        "parentId" : "4264ea80-bd2d-4326-8ec5-1653aac9dbe3",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I think the comment was updated at the PR against master branch -https://github.com/apache/spark/pull/24834/files#diff-1f54938136d72cd234ae55003c91d565R111-R122\r\n\r\n",
        "createdAt" : "2019-08-30T01:09:40Z",
        "updatedAt" : "2019-08-30T01:09:40Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd3031750cea363eb6ffc76c0158b270e8133f1e",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +445,449 @@   * with the given OutputStream.\n   *\n   * This is the same as serveToStream, only it returns a server object that\n   * can be used to sync in Python.\n   */"
  },
  {
    "id" : "845b1569-787a-43ad-94b6-01155c0362b8",
    "prId" : 25593,
    "prUrl" : "https://github.com/apache/spark/pull/25593#pullrequestreview-282414704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "parentId" : null,
        "authorId" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "body" : "SocketAuthServer.setupOneConnectionServer sets the timeout 15 seconds. This one does not set it. What is the reason we set it in the past? ",
        "createdAt" : "2019-08-29T17:58:45Z",
        "updatedAt" : "2019-08-29T17:58:46Z",
        "lastEditedBy" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "tags" : [
        ]
      },
      {
        "id" : "a012d22e-a0f0-4a7b-97bc-6f62e8084900",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "I don't think there was a specific reason about the timeout. Cc @vanzin and @squito ",
        "createdAt" : "2019-08-30T00:45:37Z",
        "updatedAt" : "2019-08-30T00:45:37Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "a24140b9-7649-4666-a8e2-6b1df65fde1f",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "BTW, there are multiple pleases for such hardcoded timeout - e.g. https://github.com/apache/spark/blob/a950570f91db56cbae488c82def49cd0da16e996/core/src/main/scala/org/apache/spark/api/python/PythonWorkerFactory.scala#L171\r\n\r\n I suspect it won't be a major issue.",
        "createdAt" : "2019-08-30T02:26:17Z",
        "updatedAt" : "2019-08-30T02:27:22Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "36813f7e-a1a3-4524-8699-96b5206a402f",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Oh, the question was why it is not set? It still sets:\r\n\r\nhttps://github.com/apache/spark/blob/branch-2.4/core/src/main/scala/org/apache/spark/api/python/PythonRDD.scala#L852\r\n\r\nhttps://github.com/apache/spark/blob/branch-2.4/core/src/main/scala/org/apache/spark/api/python/PythonRDD.scala#L899",
        "createdAt" : "2019-08-30T02:35:53Z",
        "updatedAt" : "2019-08-30T02:36:05Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "bcf0d713-6ccb-4bb0-a38b-0ae33174f419",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "body" : "FYI. @HyukjinKwon and @cloud-fan also found the timeout value only affects `accept()`",
        "createdAt" : "2019-08-30T17:17:11Z",
        "updatedAt" : "2019-08-30T17:17:11Z",
        "lastEditedBy" : "d19fc546-1296-40ce-befb-9eca847aeceb",
        "tags" : [
        ]
      },
      {
        "id" : "2bd36cdb-f921-4791-8e3f-d67676128d4f",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "7694af3d-5af2-4788-8413-c0558915c452",
        "body" : "Hi, @gatorsmile . Do you mean it affects the on-going `2.4.4` vote?",
        "createdAt" : "2019-08-30T17:20:25Z",
        "updatedAt" : "2019-08-30T17:20:26Z",
        "lastEditedBy" : "7694af3d-5af2-4788-8413-c0558915c452",
        "tags" : [
        ]
      },
      {
        "id" : "f0f6be8f-d4f0-4a1c-b86f-0998d8844107",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "e913f9af-103d-40d4-976e-9aa8e12e7211",
        "body" : "sorry I think I'm a bit lost in the discussion -- @gatorsmile do you think something is wrong here or not?  seems OK to me, the timeout is the same as before, just in a different spot.\r\n\r\nI don't think the timeout is crucial for correctness, its more about getting sane errors if there is some bug and nothing connects back.  Rather than having things block forever, you'll get a timeout exception.",
        "createdAt" : "2019-08-30T19:28:13Z",
        "updatedAt" : "2019-08-30T19:28:14Z",
        "lastEditedBy" : "e913f9af-103d-40d4-976e-9aa8e12e7211",
        "tags" : [
        ]
      },
      {
        "id" : "7dca4d31-6edd-47e7-a61f-3c767a956ca1",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "IIUC the timeout is for establishing the socket connection. Given we build local socket connection between JVM and Python, 10 seconds is fine.\r\n\r\nAnd agree with @squito it's nothing about correctness, if weird thing happens users will get an error instead of wrong result.",
        "createdAt" : "2019-09-02T06:08:12Z",
        "updatedAt" : "2019-09-02T06:08:12Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "72e87e68-d9bc-478d-9129-bbb6b0559b2b",
        "parentId" : "e455460d-3128-4d22-bbb2-1c6f8ee25305",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Yea, it's fine. I don't think there's any major issue with that.",
        "createdAt" : "2019-09-02T06:13:28Z",
        "updatedAt" : "2019-09-02T06:13:28Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd3031750cea363eb6ffc76c0158b270e8133f1e",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +983,987 @@/**\n * Create a socket server class and run user function on the socket in a background thread.\n * This is the same as calling SocketAuthServer.setupOneConnectionServer except it creates\n * a server object that can then be synced from Python.\n */"
  },
  {
    "id" : "363e9a72-0944-4368-9100-80f84cca5024",
    "prId" : 25515,
    "prUrl" : "https://github.com/apache/spark/pull/25515#pullrequestreview-288303857",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee03b1ae-e84c-4fcd-a896-25ef5c1cf681",
        "parentId" : null,
        "authorId" : "0c293c45-22a6-4358-8a40-adbf7c470575",
        "body" : "It might be best to avoid `awaitResult` if possible. Could you make a buffered iterator yourself? \r\nmaybe something like\r\n\r\n```scala\r\nvar next = collectPartitionIter.next()\r\nval prefetchIter = collectPartitionIter.map { part =>\r\n  val tmp = next\r\n  next = part\r\n  tmp\r\n} ++ Iterator(next)\r\n```",
        "createdAt" : "2019-08-22T21:41:11Z",
        "updatedAt" : "2019-09-10T18:55:25Z",
        "lastEditedBy" : "0c293c45-22a6-4358-8a40-adbf7c470575",
        "tags" : [
        ]
      },
      {
        "id" : "dad5479e-c6a1-4f0b-8fbb-5bb7645ab59f",
        "parentId" : "ee03b1ae-e84c-4fcd-a896-25ef5c1cf681",
        "authorId" : "ae55b635-dd0e-41aa-9272-372de9a35f38",
        "body" : "So the awaitFuture (or something similar) is required for us to use futures. If we just used a buffered iterator without allowing the job to schedule separately we'd just block for both partitions right away instead of evaluating the other future in the background while we block on the first. (Implicitly this awaitResult is already effectively done inside of the previous DAGScheduler's runJob.",
        "createdAt" : "2019-08-23T00:04:12Z",
        "updatedAt" : "2019-09-10T18:55:25Z",
        "lastEditedBy" : "ae55b635-dd0e-41aa-9272-372de9a35f38",
        "tags" : [
        ]
      },
      {
        "id" : "6ae0d8e2-633d-4d40-a336-581bff8100f4",
        "parentId" : "ee03b1ae-e84c-4fcd-a896-25ef5c1cf681",
        "authorId" : "0c293c45-22a6-4358-8a40-adbf7c470575",
        "body" : "Ah yes, you are totally right. That would block while getting the prefetched partition. This looks pretty good to me then.\r\n\r\nOne question though, when should the first job be triggered? I think the old behavior used to start the first job as soon as `toLocalIterator()` was called. From what I can tell, this will wait until the first iteration and then trigger the first 2 jobs. Either way is probably fine, but you might get slightly better performance by starting the first job immediately.",
        "createdAt" : "2019-08-26T19:15:46Z",
        "updatedAt" : "2019-09-10T18:55:25Z",
        "lastEditedBy" : "0c293c45-22a6-4358-8a40-adbf7c470575",
        "tags" : [
        ]
      },
      {
        "id" : "27e0a46b-4d06-4e56-8283-3752b5a12709",
        "parentId" : "ee03b1ae-e84c-4fcd-a896-25ef5c1cf681",
        "authorId" : "ae55b635-dd0e-41aa-9272-372de9a35f38",
        "body" : "In either case it waits for reading a request of data from the Python side before starting a job, because the map on the partition indices is lazily evaluated.",
        "createdAt" : "2019-09-14T02:43:14Z",
        "updatedAt" : "2019-09-14T02:44:47Z",
        "lastEditedBy" : "ae55b635-dd0e-41aa-9272-372de9a35f38",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8e67f30f03437cdac248695ee75d42e6f96df66",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +213,217 @@              prefetchIter.headOption\n            }\n            val partitionArray = ThreadUtils.awaitResult(partitionFuture, Duration.Inf)\n\n            // Send response there is a partition to read"
  }
]