[
  {
    "id" : "c05142e0-9d03-4c19-95c5-1531e11200d4",
    "prId" : 33518,
    "prUrl" : "https://github.com/apache/spark/pull/33518#pullrequestreview-715403024",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfb7709f-5ef5-413c-a06e-0f479bef1b46",
        "parentId" : null,
        "authorId" : "957f9c71-6f42-4d35-9de9-a731f295e818",
        "body" : "nit: Can we add a description: \"individual interval fields are non-negative but interval itself can have a sign, and be negative.\"?",
        "createdAt" : "2021-07-27T01:21:58Z",
        "updatedAt" : "2021-07-27T01:22:15Z",
        "lastEditedBy" : "957f9c71-6f42-4d35-9de9-a731f295e818",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b226030e92f64aa1491d64e8073f73b46d0150e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +50,54 @@  - `DateType`: Represents values comprising values of fields year, month and day, without a\n  time-zone.\n* Interval types\n  - `YearMonthIntervalType(startField, endField)`: Represents a year-month interval which is made up of a contiguous subset of the following fields:\n    - MONTH, months within years `[0..11]`,"
  },
  {
    "id" : "605f813e-7927-436a-9277-df499bf8acd1",
    "prId" : 31221,
    "prUrl" : "https://github.com/apache/spark/pull/31221#pullrequestreview-570564689",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f926c56a-ce00-46b4-ac59-1b9918c00530",
        "parentId" : null,
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Interesting .. why do we have to escape this alone?\r\nLooks good anyway as it works ..",
        "createdAt" : "2021-01-18T03:36:34Z",
        "updatedAt" : "2021-01-18T03:36:38Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "15caf9f3-6804-471e-967c-9b6a812f3c62",
        "parentId" : "f926c56a-ce00-46b4-ac59-1b9918c00530",
        "authorId" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "body" : "Oh, it thinks it's an HTML.",
        "createdAt" : "2021-01-18T03:40:14Z",
        "updatedAt" : "2021-01-18T04:06:41Z",
        "lastEditedBy" : "5e07d5ab-b4b3-41e4-beca-fefd635980c6",
        "tags" : [
        ]
      },
      {
        "id" : "7fa6e938-fa98-4549-824c-79fbbe615742",
        "parentId" : "f926c56a-ce00-46b4-ac59-1b9918c00530",
        "authorId" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "body" : "I am also curious about why `STRUCT` and `Map` do not require escape.",
        "createdAt" : "2021-01-18T04:14:51Z",
        "updatedAt" : "2021-01-18T04:14:51Z",
        "lastEditedBy" : "99e31844-a5b3-48a2-af71-412edb607a13",
        "tags" : [
        ]
      },
      {
        "id" : "c3fa8053-9519-4668-a701-bafc6f53c99d",
        "parentId" : "f926c56a-ce00-46b4-ac59-1b9918c00530",
        "authorId" : "75a0c43e-6b44-49db-9fff-c670c70750e3",
        "body" : "This behavior comes from [kramdown](https://kramdown.gettalong.org/) which is used by Jekyll.\r\n\r\nThe `element_type` is interpreted as an html tag because it consists of only alphabet characters.\r\nOn the other hand, `field1_name: field1_type, field2_name: field2_type, ...`(STRUCT) and `key_type, value_type`(MAP) contain bare comma, so they cannot be interpreted as html tags.\r\n\r\nStrictly speaking, kramdown uses the following regular expression to determine whether it is an html tag or not.\r\n\r\n```\r\n(?m-ix:<((?>(?:[[:alpha:]_][-[:alnum:]._]*:)?[[:alpha:]_][-[:alnum:]._]*))\\\\s*((?>\\\\s+(?:[[:alpha:]_][-[:alnum:]._]*:)?[[:alpha:]_][-[:alnum:]._]*(?:\\\\s*=\\\\s*(?:\\\\p{Word}+|(\\\"|').*?\\\\3))?)*)\\\\s*(\\\\/)?>)\r\n```\r\n",
        "createdAt" : "2021-01-18T14:57:58Z",
        "updatedAt" : "2021-01-18T14:57:59Z",
        "lastEditedBy" : "75a0c43e-6b44-49db-9fff-c670c70750e3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b4698a6103e7727dfcf73097c2a2ce33070a129",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +194,198 @@|**DecimalType**|DECIMAL, DEC, NUMERIC|\n|**CalendarIntervalType**|INTERVAL|\n|**ArrayType**|ARRAY\\<element_type>|\n|**StructType**|STRUCT<field1_name: field1_type, field2_name: field2_type, ...>|\n|**MapType**|MAP<key_type, value_type>|"
  },
  {
    "id" : "0c516aca-90c8-4118-8543-532a620f0a08",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-506093406",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "003b9a37-16da-4c65-a70d-9e44deff054e",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you describe what' a type coercion at the beginning?",
        "createdAt" : "2020-10-10T12:28:02Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +321,325 @@\n#### Type Coercion in Operations between Different Types \n\nType Coercion refers to the automatic or implicit conversion of values from one type to another when you need to to resolve type mismatches.\nThe following matrix shows the resulting type to which they are implicitly converted to resolve an expression involving different data types."
  },
  {
    "id" : "2e056f8b-3fb1-4b05-aed1-b3b8dd5f265e",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-506104489",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a98156e7-b4b8-4ea1-ac54-186c93ef6328",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you put the output for following the other doc examples?",
        "createdAt" : "2020-10-10T12:46:00Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      },
      {
        "id" : "b85d44e3-2127-4484-aa0b-ee9b04eca229",
        "parentId" : "a98156e7-b4b8-4ea1-ac54-186c93ef6328",
        "authorId" : "51be1be0-7c72-4f32-a21f-91b1707ec363",
        "body" : "I don't added it because the result is an integer and it don't add anything interesting for the reader about type coercion between timestamp and date types. don't you think?",
        "createdAt" : "2020-10-10T15:12:44Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "51be1be0-7c72-4f32-a21f-91b1707ec363",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +416,420 @@|months_between(CAST(CAST(2020-10-10 AS DATE) AS TIMESTAMP), CAST(2020-08-13 AS TIMESTAMP), true)|double   |null   |\n+------------------------------------------------------------------------------------------------+---------+-------+\n\n```\n"
  },
  {
    "id" : "4032f0ae-9639-4b09-b246-7616cde0fd3f",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-509850794",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d67c623-22cc-406f-92a0-b6ccc2ae7a79",
        "parentId" : null,
        "authorId" : "99765afe-8dbe-4d5f-9ad3-d5bc40f0462b",
        "body" : "super nit: Possible implicit conversions -> Possible Implicit Conversions?",
        "createdAt" : "2020-10-15T22:25:21Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "99765afe-8dbe-4d5f-9ad3-d5bc40f0462b",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +371,375 @@\n\n**Possible implicit conversions**:\n\n|                  |ByteType  |ShortType |IntegerType |LongType |FloatType |DoubleType |DecimalType|StringType |BinaryType |BooleanType |TimestampType |DateType|"
  },
  {
    "id" : "760d1e13-ad61-49b4-bb59-fd6fc2934c6d",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-518683471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a95ae6f-3753-4dbb-a340-ad063f0c0049",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "I think we need to make it clear that the String type will be implicit cast as Double type.",
        "createdAt" : "2020-10-28T13:53:12Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +345,349 @@    |               |ByteType   |ShortType  |IntegerType |LongType   |FloatType    |DoubleType  |\n    |---------------|-----------|-----------|------------|-----------|-------------|------------|\n    |**StringType** |DoubleType |DoubleType |DoubleType  |DoubleType |DoubleType   |DoubleType  |\n\n* Comparison: When we have a comparison expression with an operand of type StringType, the operand StringType will be casted implicitly according to the following table."
  },
  {
    "id" : "732ac7a2-c1f9-466e-ac38-2610bdc5cf6b",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-518683584",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27b3eff2-ef3d-46b0-958e-f5fdb4dec53e",
        "parentId" : null,
        "authorId" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "body" : "ditto",
        "createdAt" : "2020-10-28T13:53:18Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "15acce7d-132b-48c9-894b-9bc3f4c2b09d",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +351,355 @@    |               |ByteType   |ShortType  |IntegerType |LongType   |FloatType    |DoubleType  |DecimalType |DateType             |TimestampType             |\n    |---------------|-----------|-----------|------------|-----------|-------------|------------|------------|---------------------|--------------------------|\n    |**StringType** |ByteType   |ShortType  |IntegerType |LongType   |FloatType    |DoubleType  |DoubleType  |DateType<sup>1</sup> |TimestampType<sup>1</sup> |\n\n    **Note 1**: If `spark.sql.legacy.typeCoercion.datetimeToString` is true, DateType and TimestampType will be casted to StringType"
  },
  {
    "id" : "292a66f3-ac88-4add-82d0-3db9decc9d27",
    "prId" : 29837,
    "prUrl" : "https://github.com/apache/spark/pull/29837#pullrequestreview-523505996",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c5ac356-2129-40f6-95dc-58ed1704149c",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "Ansi mode is off by default, and Store Assignment is using ANSI policy by default. That said, these two have different behaviors by default.",
        "createdAt" : "2020-11-04T07:02:59Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      },
      {
        "id" : "2a2682e2-ef00-49ea-bc4f-ec46427c412b",
        "parentId" : "4c5ac356-2129-40f6-95dc-58ed1704149c",
        "authorId" : "51be1be0-7c72-4f32-a21f-91b1707ec363",
        "body" : "Ok, thanks, I'll explain it in the table notes",
        "createdAt" : "2020-11-04T16:03:41Z",
        "updatedAt" : "2020-11-04T17:42:30Z",
        "lastEditedBy" : "51be1be0-7c72-4f32-a21f-91b1707ec363",
        "tags" : [
        ]
      }
    ],
    "commit" : "58ef5d75b313d9688dd55609ebffe4e49a45ce47",
    "line" : 143,
    "diffHunk" : "@@ -1,1 +454,458 @@\n\n#### Explicit Casting and Store Assignment Casting\n\nWhen you are using explicit casting by CAST or doing INSERT INTO operations that need to cast types to different store types, the following matrix shows if the conversion is allowed"
  },
  {
    "id" : "d871c6dd-345f-4a86-be4c-eaaa1c9f7f10",
    "prId" : 28264,
    "prUrl" : "https://github.com/apache/spark/pull/28264#pullrequestreview-396086638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe5247d-bc04-42c8-b392-9945d9367aaa",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you add examples, too, here?",
        "createdAt" : "2020-04-20T00:58:51Z",
        "updatedAt" : "2020-04-24T17:03:49Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "0499c08eb4597c3591858e9c2f5ff5cd5ff680e3",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +723,727 @@   * ```FloatType```: equivalent to Scala <code>Float.NaN</code>.\n   * ```DoubleType```:  equivalent to Scala <code>Double.NaN</code>.\n\n#### Positive/Negative Infinity Semantics\n"
  },
  {
    "id" : "31639f5a-63c5-45d9-bba5-89a9e785ebe7",
    "prId" : 28264,
    "prUrl" : "https://github.com/apache/spark/pull/28264#pullrequestreview-398723365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72705471-be40-4d38-aec6-6d884a39a374",
        "parentId" : null,
        "authorId" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "body" : "Could you leave a short description about what this section is.",
        "createdAt" : "2020-04-23T02:51:12Z",
        "updatedAt" : "2020-04-24T17:03:49Z",
        "lastEditedBy" : "044062b3-9d96-4ec3-a1e2-3a2f595bbc02",
        "tags" : [
        ]
      }
    ],
    "commit" : "0499c08eb4597c3591858e9c2f5ff5cd5ff680e3",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +727,731 @@\nThere is special handling for positive and negative infinity. They have the following semantics:\n\n * Positive infinity multiplied by any positive value returns positive infinity.\n * Negative infinity multiplied by any positive value returns negative infinity."
  },
  {
    "id" : "1e2907eb-6dfc-4bfc-a2a8-76adb161a213",
    "prId" : 28264,
    "prUrl" : "https://github.com/apache/spark/pull/28264#pullrequestreview-399710405",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec2faff9-bd4e-4fc3-9743-2c4473119fe1",
        "parentId" : null,
        "authorId" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "body" : "can we put the example section at the end? then we can also put examples about the behaviors like `SELECT double('infinity') * 0`",
        "createdAt" : "2020-04-24T07:40:07Z",
        "updatedAt" : "2020-04-24T17:03:49Z",
        "lastEditedBy" : "b1f2cebb-db23-4759-b446-886279d07e99",
        "tags" : [
        ]
      }
    ],
    "commit" : "0499c08eb4597c3591858e9c2f5ff5cd5ff680e3",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +750,754 @@ * NaN values go last when in ascending order, larger than any other numeric value.\n\n#### Examples\n\n{% highlight sql %}"
  }
]